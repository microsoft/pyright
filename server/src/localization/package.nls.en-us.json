{
    "Diagnostic": {
        "annotatedTypeArgMissing": "Expected at least one type argument after \"Annotated\"",
        "annotationFormatString": "Type annotations cannot use format string literals (f-strings)",
        "annotationNotSupported": "Type annotation not supported for this type of expression",
        "annotationSpansStrings": "Type annotations cannot span multiple string literals",
        "annotationStringEscape": "Type annotations cannot contain escape characters",
        "annotationTripleQuote": "Type annotations cannot use triple quotes",
        "argAssignment": "Argument of type \"{argType}\" cannot be assigned to parameter of type \"{paramType}\"",
        "argAssignmentFunction": "Argument of type \"{argType}\" cannot be assigned to parameter of type \"{paramType}\" in function \"{functionName}\"",
        "argAssignmentParam": "Argument of type \"{argType}\" cannot be assigned to parameter \"{paramName}\" of type \"{paramType}\"",
        "argAssignmentParamFunction": "Argument of type \"{argType}\" cannot be assigned to parameter \"{paramName}\" of type \"{paramType}\" in function \"{functionName}\"",
        "argMissingForParam": "Argument missing for parameter {name}",
        "argMissingForParams": "Arguments missing for parameters {names}",
        "argPositional": "Expected positional argument",
        "argPositionalExpectedCount": "Expected {expected} positional arguments",
        "argPositionalExpectedOne": "Expected 1 positional argument",
        "argTypePartiallyUnknown": "Argument type is partially unknown",
        "argTypeUnknown": "Argument type is unknown",
        "assertAlwaysTrue": "Assert expression always evaluates to true",
        "assignmentExprContext": "Assignment expression must be within module, function or lambda",
        "assignmentExprComprehension": "Assignment expression target \"{name}\" cannot use same name as comprehension for target",
        "assignmentInProtocol": "Assignment to instance or class variables not allowed within a Protocol class",
        "assignmentTargetExpr": "Expression cannot be assignment target",
        "awaitIllegal": "Use of \"await\" requires Python 3.5 or newer",
        "awaitNotInAsync": "\"await\" allowed only within async function",
        "backticksIllegal": "Expressions surrounded by backticks are not supported in Python 3.x; use repr instead",
        "baseClassCircular": "Class cannot derive from itself",
        "baseClassDoubleGeneric": "Class cannot derive from \"Generic\" more than once",
        "baseClassFinal": "Base class \"{type}\" is marked final and cannot be subclassed",
        "baseClassInvalid": "Argument to class must be a base class",
        "baseClassUnknown": "Base class type is unknown, obscuring type of derived class",
        "breakOutsideLoop": "\"break\" can be used only within a loop",
        "callableExtraArgs": "Expected only two type arguments to \"Callable\"",
        "callableFirstArg": "Expected parameter type list or \"...\"",
        "classDecoratorTypeUnknown": "Untyped class decorator obscures type of class; ignoring decorator",
        "classMethodClsParam": "Class methods should take a \"cls\" parameter",
        "classVarFirstArgMissing": "Expected a type argument after \"ClassVar\"",
        "classVarTooManyArgs": "Expected only one type argument after \"ClassVar\"",
        "comprehensionInDict": "Comprehension cannot be used with other dictionary entries",
        "comprehensionInSet": "Comprehension cannot be used with other set entries",
        "constantRedefinition": "\"{name}\" is constant and cannot be redefined",
        "continueInFinally": "\"continue\" cannot be used within a finally clause",
        "continueOutsideLoop": "\"continue\" can be used only within a loop",
        "constructorNoArgs": "Expected no arguments to \"{type}\" constructor",
        "dataClassFieldWithDefault": "Data class fields without default value cannot appear after data fields with default values",
        "declaredReturnTypePartiallyUnknown": "Declared return type, \"{returnType}\", is partially unknown",
        "declaredReturnTypeUnknown": "Declared return type is unknown",
        "defaultValueContainsCall": "Function calls within default value initializer are not permitted",
        "defaultValueNotAllowed": "Parameter with \"*\" or \"**\" cannot have default value",
        "delTargetExpr": "Expression cannot be deleted",
        "dictInAnnotation": "Dictionary expression not allowed in type annotation",
        "dictKeyValuePairs": "Dictionary entries must contain key/value pairs",
        "duplicateArgsParam": "Only one \"*\" parameter is allowed",
        "duplicateCatchAll": "Only one catch-all except clause is allowed",
        "duplicateImport": "\"{importName}\" is imported more than once",
        "duplicateKwargsParam": "Only one \"**\" parameter is allowed",
        "duplicateNameOnly": "Only one \"*\" separator is allowed",
        "duplicateParam": "Duplicate parameter \"{name}\"",
        "duplicatePositionOnly": "Only one \"/\" parameter is allowed",
        "duplicateUnpack": "Only one unpack operation allowed in list",
        "ellipsisContext": "\"...\" not allowed in this context",
        "ellipsisSecondArg": "\"...\" allowed only as the second of two arguments",
        "enumFirstArg": "Expected enum class name as first argument",
        "enumSecondArg": "Expected enum item string as second parameter",
        "exceptionTypeIncorrect": "\"{type}\" does not derive from BaseException",
        "exceptionTypeNotClass": "\"{type}\" is not valid exception class",
        "expectedAfterDecorator": "Expected function or class declaration after decorator",
        "expectedAsAfterException": "Expected \"as\" after exception type",
        "expectedAssignRightHandExpr": "Expected expression to the right of \"=\"",
        "expectedBinaryRightHandExpr": "Expected expression to the right of operator",
        "expectedBoolLiteral": "Expected True or False",
        "expectedClassName": "Expected class name",
        "expectedCloseBrace": "Expected \"}\"",
        "expectedCloseBracket": "Expected \"]\"",
        "expectedCloseParen": "Expected \")\"",
        "expectedColon": "Expected \":\"",
        "expectedDecoratorName": "Expected decorator name",
        "expectedDecoratorNewline": "Expected new line at end of decorator",
        "expectedDelExpr": "Expected expression after \"del\"",
        "expectedElse": "Expected \"else\"",
        "expectedExceptionClass": "Expected exception class or object",
        "expectedExceptionObj": "Expected exception object or None",
        "expectedExpr": "Expected expression",
        "expectedIdentifier": "Expected identifier",
        "expectedImport": "Expected \"import\"",
        "expectedImportAlias": "Expected symbol after \"as\"",
        "expectedImportSymbols": "Expected one or more symbol names after import",
        "expectedIndentedBlock": "Expected indented block",
        "expectedInExpr": "Expected expression after \"in\"",
        "expectedIn": "Expected \"in\"",
        "expectedFunctionAfterAsync": "Expected function definition after \"async\"",
        "expectedFunctionName": "Expected function name after \"def\"",
        "expectedMemberName": "Expected member name after \".\"",
        "expectedModuleName": "Expected module name",
        "expectedNameAfterAs": "Expected symbol name after \"as\"",
        "expectedNamedArgument": "Named argument must follow \"*\"",
        "expectedNewlineOrSemicolon": "Statements must be separated by newlines or semicolons",
        "expectedOpenParen": "Expected \"(\"",
        "expectedParamName": "Expected parameter name",
        "expectedReturnExpr": "Expected expression after \"return\"",
        "expectedSliceIndex": "Expected index or slice expression",
        "expectedTypeNotString": "Expected type but received a string literal",
        "expectedYieldExpr": "Expected expression in yield statement",
        "finalContext": "\"Final\" is not allowed in this context",
        "finalMethodOverride": "Method \"{name}\" cannot override final method defined in class \"{className}\"",
        "finalReassigned": "\"{name}\" is declared as Final and cannot be reassigned",
        "finalRedeclaration": "\"{name}\" was previously declared as Final",
        "finalRedeclarationBySubclass": "\"{name}\" cannot be redeclared because parent class \"{className}\" declares it as Final",
        "finalTooManyArgs": "Expected a single type argument after \"Final\"",
        "finalUnassigned": "\"{name}\" is declared Final, but value is not assigned",
        "formatStringBrace": "Single close brace not allowed within f-string literal; use double close brace",
        "formatStringBytes": "Format string literals (f-strings) cannot be binary",
        "formatStringEscape": "Escape sequence (backslash) not allowed in expression portion of f-string",
        "formatStringUnicode": "Format string literals (f-strings) cannot be unicode",
        "formatStringIllegal": "Format string literals (f-strings) require Python 3.6 or newer",
        "formatStringUnterminated": "Unterminated expression in f-string; missing close brace",
        "functionDecoratorTypeUnknown": "Untyped function decorator obscures type of function; ignoring decorator",
        "genericClassAssigned": "Generic class type cannot be assigned",
        "genericClassDeleted": "Generic class type cannot be deleted",
        "genericTypeArgMissing": "\"Generic\" requires at least one type argument",
        "genericTypeArgTypeVar": "Type argument for \"Generic\" must be a type variable",
        "genericTypeArgUnique": "Type arguments for \"Generic\" must be unique",
        "globalReassignment": "\"{name}\" is assigned before global declaration",
        "globalRedefinition": "\"{name}\" was already declared global",
        "implicitStringConcat": "Implicit string concatenation not allowed",
        "importCycleDetected": "Cycle detected in import chain",
        "importDepthExceeded": "Import chain depth exceeded {depth}",
        "importResolveFailure": "Import \"{importName}\" could not be resolved",
        "importSourceResolveFailure": "Import \"{importName}\" could not be resolved from source",
        "importSymbolUnknown": "\"{name}\" is unknown import symbol",
        "incompatibleMethodOverride": "Method \"{name}\" overrides class \"{className}\" in an incompatible manner",
        "inconsistentIndent": "Unindent amount does not match previous indent",
        "inconsistentTabs": "Inconsistent use of tabs and spaces in indentation",
        "initSubclassClsParam": "__init_subclass__ override should take a \"cls\" parameter",
        "instanceMethodSelfParam": "Instance methods should take a \"self\" parameter",
        "invalidIdentifierChar": "Invalid character in identifier",
        "invalidTokenChars": "Invalid character in token \"{text}\"",
        "keyRequiredDeleted": "\"{name}\" is a required key and cannot be deleted",
        "keywordInAnnotation": "Keyword not allowed in type annotation",
        "keyValueInSet": "Key/value pairs are not allowed within a set",
        "lambdaReturnTypeUnknown": "Return type of lambda is unknown",
        "lambdaReturnTypePartiallyUnknown": "Return type of lambda, \"{returnType}\", is partially unknown",
        "listInAnnotation": "List expression not allowed in type annotation",
        "literalUnsupportedType": "Type arguments for \"Literal\" must be None, a literal value (int, bool, str, or bytes), or an enum value",
        "literalEmptyArgs": "Expected one or more type arguments after \"Literal\"",
        "memberAccess": "Cannot access member \"{name}\" for type \"{type}\"",
        "memberDelete": "Cannot delete member \"{name}\" for type \"{type}\"",
        "memberSet": "Cannot assign member \"{name}\" for type \"{type}\"",
        "metaclassDuplicate": "Only one metaclass can be provided",
        "methodNotDefined": "\"{name}\" method not defined",
        "methodNotDefinedOnType": "\"{name}\" method not defined on type \"{type}\"",
        "methodOrdering": "Cannot create consistent method ordering",
        "methodReturnsNonObject": "\"{name}\" method does not return an object",
        "moduleContext": "Module not allowed in this context",
        "moduleUnknownMember": "\"{name}\" is not a known member of module",
        "namedExceptAfterCatchAll": "A named except clause cannot appear after catch-all except clause",
        "namedTupleEmptyName": "Names within a named tuple cannot be empty",
        "namedTupleFirstArg": "Expected named tuple class name as first argument",
        "namedTupleNameString": "Expected string literal for tuple entry name",
        "namedTupleNameType": "Expected two-entry tuple specifying entry name and type",
        "namedTupleNameUnique": "Names within a named tuple must be unique",
        "namedTupleNoTypes": "\"namedtuple\" provides no types for tuple entries; use \"NamedTuple\" instead",
        "namedTupleSecondArg": "Expected named tuple entry list as second argument",
        "newClsParam": "__new__ override should take a \"cls\" parameter",
        "nonDefaultAfterDefault": "Non-default argument follows default argument",
        "noneNotCallable": "Object of type \"None\" cannot be called",
        "noneNotIterable": "Object of type \"None\" cannot be used as iterable value",
        "noneOperator": "Operator \"{operator}\" not supported for \"None\"",
        "noneNotSubscriptable": "Object of type \"None\" cannot be subscripted",
        "noneNotUsableWith": "Object of type \"None\" cannot be used with \"with\"",
        "noneUnknownMember": "\"{name}\" is not a known member of \"None\"",
        "nonLocalNoBinding": "No binding for nonlocal \"{name}\" found",
        "nonLocalReassignment": "\"{name}\" is assigned before nonlocal declaration",
        "nonLocalRedefinition": "\"{name}\" was already declared nonlocal",
        "nonLocalInModule": "Nonlocal declaration not allowed at module level",
        "noOverload": "No overloads for \"{expression}\" match parameters",
        "noReturnContainsReturn": "Function with declared return type \"NoReturn\" cannot include a return statement",
        "noReturnContainsYield": "Function with declared return type \"NoReturn\" cannot include a yield statement",
        "noReturnReturnsNone": "Function with declared type of \"NoReturn\" cannot return \"None\"",
        "numericLiteralInAnnotation": "Numeric literal not allowed in type annotation",
        "objectNotCallable": "object of \"{type}\" is not callable",
        "obscuredClassDeclaration": "Class declaration \"{name}\" is obscured by a declaration of the same name",
        "obscuredFunctionDeclaration": "Function declaration \"{name}\" is obscured by a declaration of the same name",
        "obscuredParameterDeclaration": "Parameter declaration \"{name}\" is obscured by a declaration of the same name",
        "obscuredVariableDeclaration": "Declaration \"{name}\" is obscured by a declaration of the same name",
        "optionalExtraArgs": "Expected one type argument after \"Optional\"",
        "paramAfterKwargsParam": "Parameter cannot follow \"**\" parameter",
        "paramAlreadyAssigned": "Parameter \"{name}\" is already assigned",
        "paramNameMissing": "No parameter named \"{name}\"",
        "paramSpecAssignedName": "ParameterSpecification must be assigned to a variable named \"{name}\"",
        "paramSpecContext": "ParameterSpecification not allowed in this context",
        "paramSpecIllegal": "ParameterSpecification requires Python 3.9 or newer",
        "paramSpecFirstArg": "Expected name of ParameterSpecification as first argument",
        "paramSpecUnknownArg": "ParameterSpecification does not support more than one argument",
        "paramSpecUnknownMember": "\"{name}\" is not a known member of ParameterSpecification",
        "paramSpecUnknownParam": "\"{name}\" is unknown parameter to ParameterSpecification",
        "paramAssignmentMismatch": "Expression of type \"{sourceType}\" cannot be assigned to parameter of type \"{paramType}\"",
        "paramTypeUnknown": "Type of parameter \"{paramName}\" is unknown",
        "paramTypePartiallyUnknown": "Type of parameter \"{paramName}\" is partially unknown",
        "positionArgAfterNamedArg": "Positional argument cannot appear after named arguments",
        "positionOnlyAfterNameOnly": "\"/\" parameter must appear before \"*\" parameter",
        "positionOnlyIncompatible": "Position-only argument separator requires Python 3.8 or greater",
        "privateUsedOutsideOfClass": "\"{name}\" is private and used outside of the class in which it is declared",
        "privateUsedOutsideOfModule": "\"{name}\" is private and used outside of the module in which it is declared",
        "protectedUsedOutsideOfClass": "\"{name}\" is protected and used outside of the class in which it is declared",
        "protocolUsedInCall": "Protocol class cannot be used in \"{name}\" call",
        "protocolIllegal": "Use of \"Protocol\" requires Python 3.7 or newer",
        "raiseParams": "\"raise\" requires one or more parameters when used outside of except clause",
        "returnOutsideFunction": "\"return\" can be used only within a function",
        "returnMissing": "Function with declared type of \"{returnType}\" must return value",
        "returnTypeMismatch": "Expression of type \"{exprType}\" cannot be assigned to return type \"{returnType}\"",
        "returnTypeUnknown": "Return type is unknown",
        "returnTypePartiallyUnknown": "Return type, \"{returnType}\", is partially unknown",
        "staticClsSelfParam": "Static methods should not take a \"self\" or \"cls\" parameter",
        "stringNonAsciiBytes": "Non-ASCII character not allowed in bytes string literal",
        "stringUnsupportedEscape": "Unsupported escape sequence in string literal",
        "stringUnterminated": "String literal is unterminated",
        "stubFileMissing": "Stub file not found for \"{importName}\"",
        "sublistParamsIncompatible": "Sublist parameters are not supported in Python 3.x",
        "superCallArgCount": "Expected no more than two arguments to \"super\" call",
        "superCallFirstArg": "Expected class type as first argument to \"super\" call but received \"{type}\"",
        "superCallSecondArg": "Second argument to \"super\" call must be object or class that derives from \"{type}\"",
        "superCallZeroArgForm": "Zero-argument form of \"super\" call is valid only within a class",
        "symbolIsUnbound": "\"{name}\" is unbound",
        "symbolIsUndefined": "\"{name}\" is not defined",
        "symbolIsPossiblyUnbound": "\"{name}\" is possibly unbound",
        "tupleInAnnotation": "Tuple expression not allowed in type annotation",
        "tupleSizeMismatch": "Tuple size mismatch: expected {expected} but received {received}",
        "typeAbstract": "Cannot instantiate abstract class \"{type}\"",
        "typeAliasNotInModule": "A TypeAlias can be defined only within a module scope",
        "typeAliasRedeclared": "\"{name}\" is declared as a TypeAlias and can be assigned only once",
        "typeAliasInvalidType": "Expression is is not valid type for TypeAlias",
        "typeArgsExpectingNone": "Expected no type arguments",
        "typeArgsMismatchOne": "Expected one type argument but received {received}",
        "typeArgsTooMany": "Too many type arguments provided; expected {expected} but received {received}",
        "typeAssignmentMismatch": "Expression of type \"{sourceType}\" cannot be assigned to declared type \"{destType}\"",
        "typeCallNotAllowed": "type() call should not be used in type annotation",
        "typeClassFirstArg": "Expected name of type as first argument",
        "typeClassSecondArg": "Expected tuple of base class types as second argument",
        "typedDictAccess": "Could not access item in TypedDict",
        "typedDictBadVar": "TypedDict classes can contain only type annotations",
        "typedDictBaseClass": "All base classes for \"TypedDict\" classes must also be \"TypedDict\" classes",
        "typedDictDelete": "Could not delete item in TypedDict",
        "typedDictEmptyName": "Names within a TypedDict cannot be empty",
        "typedDictEntryName": "Expected string literal for dictionary entry name",
        "typedDictEntryUnique": "Names within a dictionary must be unique",
        "typedDictExtraArgs": "Extra TypedDict arguments not supported",
        "typedDictFirstArg": "Expected TypedDict class name as first argument",
        "typedDictSecondArgDict": "Expected dict or named parameter as second parameter",
        "typedDictSecondArgDictEntry": "Expected simple dictionary entry",
        "typedDictSet": "Could not assign item in TypedDict",
        "typedDictTotalParam": "Expected \"total\" parameter to have a value of True or False",
        "typeExpectedClass": "Expected class type but received \"{type}\"",
        "typeNotAwaitable": "\"{type}\" is not awaitable",
        "typeNotCallable": "\"{expression}\" has type \"{type}\" and is not callable",
        "typeNotIntantiable": "\"{type}\" cannot be instantiated",
        "typeNotIterable": "\"{type}\" is not iterable",
        "typeNotSpecializable": "Could not specialize type \"{type}\"",
        "typeNotSubscriptable": "Object of type \"{type}\" cannot be subscripted",
        "typeNotUsableWith": "Object of type \"{type}\" cannot be used with \"with\" because it does not implement {method}",
        "typeNotSupportBinaryOperator": "Operator \"{operator}\" not supported for types \"{leftType}\" and \"{rightType}\"",
        "typeNotSupportUnaryOperator": "Operator \"{operator}\" not supported for type \"{type}\"",
        "typePartiallyUnknown": "Type of \"{name}\" is partially unknown",
        "typeUnknown": "Type of \"{name}\" is unknown",
        "typeVarAssignedName": "TypeVar must be assigned to a variable named \"{name}\"",
        "typeVarAssignmentMismatch": "Type \"{type}\" cannot be assigned to TypeVar \"{name}\"",
        "typeVarBoundAndConstrained": "TypeVar cannot be both bound and constrained",
        "typeVarFirstArg": "Expected name of TypeVar as first argument",
        "typeVarGeneric": "TypeVar bound type cannot be generic",
        "typeVarUnknownParam": "\"{name}\" is unknown parameter to TypeVar",
        "typeVarVariance": "TypeVar cannot be both covariant and contravariant",
        "unaccessedClass": "Class \"{name}\" is not accessed",
        "unaccessedFunction": "Function \"{name}\" is not accessed",
        "unaccessedImport": "Import \"{name}\" is not accessed",
        "unaccessedSymbol": "\"{name}\" is not accessed",
        "unaccessedVariable": "Variable \"{name}\" is not accessed",
        "unexpectedAsyncToken": "Expected \"def\", \"with\" or \"for\" to follow \"async\"",
        "unexpectedExprToken": "Unexpected token at end of expression",
        "unexpectedIndent": "Unexpected indentation",
        "unexpectedUnindent": "Unindent not expected",
        "unionSyntaxIllegal": "Alternative syntax for unions requires Python 3.9 or newer",
        "unnecessaryCast": "Unnecessary \"cast\" call; type is already \"{type}\"",
        "unnecessaryIsInstanceAlways": "Unnecessary isinstance call; \"{testType}\" is always an instance of \"{classType}\"",
        "unnecessaryIsInstanceNever": "Unnecessary isinstance call; \"{testType}\" is never an instance of \"{classType}\"",
        "unnecessaryIsSubclassAlways": "Unnecessary issubclass call; \"{testType}\" is always a subclass of \"{classType}\"",
        "unnecessaryIsSubclassNever": "Unnecessary issubclass call; \"{testType}\" is never a subclass of \"{classType}\"",
        "unpackInDict": "Unpack operation not allowed in dictionaries",
        "unpackInSet": "Unpack operator not allowed within a set",
        "unpackTuplesIllegal": "Unpack operation not allowed in tuples prior to Python 3.8",
        "unreachableCode": "Code is unreachable",
        "varAnnotationIllegal": "Type annotations for variables requires Python 3.6 or newer; use type comment for compatibility with previous versions",
        "walrusIllegal": "Operator \":=\" requires Python 3.8 or newer",
        "walrusNotAllowed": "Operator \":=\" not allowed in this context",
        "wildcardInFunction": "Wildcard import is not allowed within a class or function",
        "yieldFromIllegal": "Use of \"yield from\" requires Python 3.3 or newer",
        "yieldFromOutsideAsync": "\"yield from\" not allowed in an async function",
        "yieldOutsideFunction": "\"yield\" not allowed outside of a function",
        "yieldTypeMismatch": "Expression of type \"{exprType}\" cannot be assigned to yield type \"{yieldType}\""
    },
    "DiagnosticAddendum": {
        "argParam": "Argument corresponds to parameter \"{paramName}\"",
        "argParamFunction": "Argument corresponds to parameter \"{paramName}\" in function \"{functionName}\"",
        "argumentType": "Argument type is \"{type}\"",
        "argumentTypes": "Argument types: ({types})",
        "assignToNone": "Cannot assign to \"None\"",
        "asyncHelp": "Did you mean \"async with\"?",
        "finalMethod": "Final method",
        "keyUndefined": "\"{name}\" is not a defined key in \"{type}\"",
        "functionReturnTypeMismatch": "Function return type \"{sourceType}\" is not compatible with type \"{destType}\"",
        "functionTooFewParams": "Function accepts too few parameters; expected {expected} but received {received}",
        "functionTooManyParams": "Function accepts too many parameters; expected {expected} but received {received}",
        "literalAssignmentMismatch": "\"{sourceType}\" cannot be assigned to type \"{destType}\"",
        "memberSetClassVar": "Member \"{name}\" cannot be assigned through a class instance because it is a ClassVar",
        "memberAssignment": "Expression of type \"{type}\" cannot be assigned to member \"{name}\" of class \"{classType}\"",
        "memberIsAbstract": "\"{type}.{name}\" is abstract",
        "memberIsAbstractMore": "and {count} more...",
        "memberTypeMismatch": "\"{name}\" is an incompatible type",
        "memberUnknown": "Member \"{name}\" is unknown",
        "namedParamMissingInDest": "Named parameter \"{name}\" is missing in destination",
        "namedParamMissingInSource": "Named parameter \"{name}\" is missing in source",
        "namedParamTypeMismatch": "Named parameter \"{name}\" of type \"{sourceType}\" cannot be assigned to type \"{destType}\"",
        "noOverloadAssignable": "No overloaded function matches type \"{type}\"",
        "overriddenMethod": "Overridden method",
        "overrideParamCount": "Parameter count mismatch; base method has {baseCount}, but override has {overrideCount}",
        "overrideParamName": "Parameter {index} name mismatch: base parameter is named \"{baseName}\", override parameter is named \"{overrideName}\"",
        "overrideParamType": "Parameter {index} type mismatch: base parameter is type \"{baseType}\", override parameter is type \"{overrideType}\"",
        "overrideReturnType": "Return type mismatch: base method returns type \"{baseType}\", override returns type \"{overrideType}\"",
        "overrideType": "Base class defines type as \"{type}\"",
        "paramAssignment": "Parameter {index} of type \"{sourceType}\" cannot be assigned to type \"{destType}\"",
        "paramType": "Parameter type is \"{paramType}\"",
        "propertyMissingDeleter": "Property \"{name}\" has no defined deleter",
        "propertyMissingSetter": "Property \"{name}\" has no defined setter",
        "protocolMemberMissing": "\"{name}\" is not present",
        "protocolMemberClassVar": "\"{name}\" is not a class variable",
        "seeDeclaration": "See declaration",
        "seeClassDeclaration": "See class declaration",
        "seeFunctionDeclaration": "See function declaration",
        "seeMethodDeclaration": "See method declaration",
        "seeParameterDeclaration": "See parameter declaration",
        "seeVariableDeclaration": "See variable declaration",
        "tupleEntryTypeMismatch": "Tuple entry {entry} is incorrect type",
        "tupleSizeMismatch": "Tuple size mismatch; expected {expected} but received {received}",
        "typeAssignmentMismatch": "Type \"{sourceType}\" cannot be assigned to type \"{destType}\"",
        "typeBound": "Type \"{sourceType}\" is not compatible with bound type \"{destType}\" for TypeVar \"{name}\"",
        "typeConstrainedTypeVar": "Type \"{type}\" is not compatible with constrained TypeVar \"{name}\"",
        "typeConstraint": "Type \"{type}\" is not compatible with constrained type \"{name}\"",
        "typedDictFieldMissing": "\"{name}\" is missing from \"{type}\"",
        "typedDictFieldNotRequired": "\"{name}\" is not required in \"{type}\"",
        "typedDictFieldRequired": "\"{name}\" is required in \"{type}\"",
        "typedDictFieldTypeMismatch": "Type \"{type}\" is not assignable to field \"{name}\"",
        "typedDictFieldUndefined": "\"{name}\" is an undefined field in type \"{type}\"",
        "typeIncompatible": "\"{sourceType}\" is incompatible with \"{destType}\"",
        "typeParamSpec": "Type \"{type}\" is not compatible with ParameterSpecification \"{name}\"",
        "typeNotStringLiteral": "\"{type}\" is not a string literal",
        "typeOfSymbol": "Type of \"{name}\" is \"{type}\"",
        "typeUnsupported": "Type \"{type}\" is unsupported",
        "typeVarIsContravariant": "TypeVar \"{name}\" is contravariant",
        "typeVarIsCovariant": "TypeVar \"{name}\" is covariant",
        "typeVarIsInvariant": "TypeVar \"{name}\" is invariant",
        "useDictInstead": "Use Dict[T1, T2] instead",
        "useListInstead": "Use List[T] instead",
        "useTupleInstead": "Use Tuple[T1, ..., Tn] instead",
        "useTypeInstead": "Use Type[T] instead"
    },
    "CodeAction": {
        "addOptionalToAnnotation": "Add \"Optional\" to Type Annotation",
        "createTypeStub": "Create Type Stub",
        "createTypeStubFor": "Create Type Stub For \"{moduleName}\"",
        "executingCommand": "Executing command",
        "filesToAnalyzeOne": "1 file to analyze",
        "filesToAnalyzeCount": "{count} files to analyze",
        "findingReferences": "Finding references",
        "organizeImports": "Organize Imports"
    }
}
