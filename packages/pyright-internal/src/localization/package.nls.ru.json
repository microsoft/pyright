{
    "CodeAction": {
        "createTypeStub": "Создать заглушку типа",
        "createTypeStubFor": "Создать заглушку типа для \"{moduleName}\"",
        "executingCommand": "Производится выполнение команды",
        "filesToAnalyzeCount": "{count} файлов для анализа",
        "filesToAnalyzeOne": "1 файл для анализа",
        "findingReferences": "Производится поиск ссылок",
        "organizeImports": "Упорядочение импорта",
        "renameShadowedFile": "Переименовать \"{oldFile}\" в \"{newFile}\""
    },
    "Completion": {
        "autoImportDetail": "Автоматический импорт",
        "indexValueDetail": "Значение индекса"
    },
    "Diagnostic": {
        "abstractMethodInvocation": "Невозможно вызвать метод \"{method}\", так как он является абстрактным и нереализованным",
        "annotatedParamCountMismatch": "Несоответствие числа аннотаций параметра: ожидается {expected}, но получено {received}",
        "annotatedTypeArgMissing": "Для \"Annotated\" ожидается один аргумент типа и одна или несколько заметок типа",
        "annotationBytesString": "Заметки с типом не могут использовать строковые литералы байтов",
        "annotationFormatString": "В заметках типа не могут использоваться строковые литералы формата (f-строки)",
        "annotationNotSupported": "Заметка типа не поддерживается для этой инструкции",
        "annotationRawString": "Заметки с типом не могут использовать необработанные строковые литералы",
        "annotationSpansStrings": "Заметки с типом не могут охватывать несколько строковых литералов",
        "annotationStringEscape": "Заметки с типом не могут содержать escape-символы",
        "argAssignment": "Аргумент типа \"{argType}\" нельзя присвоить параметру типа \"{paramType}\"",
        "argAssignmentFunction": "Аргумент типа \"{argType}\" нельзя присвоить параметру типа \"{paramType}\" в функции \"{functionName}\"",
        "argAssignmentParam": "Аргумент типа \"{argType}\" нельзя присвоить параметру \"{paramName}\" типа \"{paramType}\"",
        "argAssignmentParamFunction": "Аргумент типа \"{argType}\" нельзя присвоить параметру \"{paramName}\" типа \"{paramType}\" в функции \"{functionName}\"",
        "argMissingForParam": "Отсутствует аргумент для параметра {name}",
        "argMissingForParams": "Отсутствуют аргументы для параметров {names}",
        "argMorePositionalExpectedCount": "Ожидаются еще позиционные аргументы: {expected}",
        "argMorePositionalExpectedOne": "Ожидается еще 1 позиционный аргумент",
        "argPositional": "Ожидается позиционный аргумент",
        "argPositionalExpectedCount": "Ожидаемые позиционные аргументы: {expected}",
        "argPositionalExpectedOne": "Ожидается 1 позиционный аргумент",
        "argTypePartiallyUnknown": "Тип аргумента частично неизвестен",
        "argTypeUnknown": "Тип аргумента неизвестен",
        "assertAlwaysTrue": "Выражение assert всегда вычисляется как true",
        "assertTypeArgs": "Для \"assert_type\" ожидается два позиционных аргумента",
        "assertTypeTypeMismatch": "Несоответствие типов \"assert_type\": ожидается \"{expected}\", но получено \"{received}\"",
        "assignmentExprComprehension": "Цель выражения назначения \"{name}\" не может использовать то же имя, что и понимание для целевого объекта",
        "assignmentExprContext": "Выражение присваивания должно находиться в модуле, функции или лямбде",
        "assignmentExprInSubscript": "Выражения назначения внутри оператора получения подстроки можно использовать в Python версии не ниже 3.10",
        "assignmentInProtocol": "Переменные экземпляра или класса в классе Protocol должны быть явно объявлены в тексте класса",
        "assignmentTargetExpr": "Выражение не может быть целевым объектом присваивания",
        "asyncNotInAsyncFunction": "Использование \"async\" не разрешено вне асинхронной функции",
        "awaitIllegal": "Инструкцию \"await\" можно использовать в Python версии не ранее 3.5",
        "awaitNotAllowed": "Заметки типов не могут использовать \"await\"",
        "awaitNotInAsync": "Ключевое слово \"await\" допускается только в асинхронной функции",
        "backticksIllegal": "Выражения, окруженные одиночными обратными кавычками, не поддерживаются в Python 3.x; используйте вместо этого функцию repr",
        "baseClassCircular": "Класс не может быть производным от себя",
        "baseClassFinal": "Базовый класс \"{type}\" помечен как окончательный, и от него нельзя создать производный класс",
        "baseClassIncompatible": "Базовые классы {type} взаимно несовместимы",
        "baseClassInvalid": "Аргумент класса должен быть базовым классом",
        "baseClassMethodTypeIncompatible": "Базовые классы класса \"{classType}\" определяют метод \"{name}\" несовместимым способом",
        "baseClassUnknown": "Неизвестный тип базового класса скрывает тип производного класса",
        "baseClassVariableTypeIncompatible": "Базовые классы класса \"{classType}\" определяют переменную \"{name}\" несовместимым способом",
        "binaryOperationNotAllowed": "Бинарный оператор нельзя использовать в заметке типа",
        "bindTypeMismatch": "Не удалось привязать метод \"{methodName}\", \"{type}\" не может быть назначен параметру \"{paramName}\"",
        "breakOutsideLoop": "\"break\" можно использовать только внутри цикла",
        "callableExtraArgs": "В \"Callable\" ожидается только два аргумента типа",
        "callableFirstArg": "Ожидается список типов параметров или \"...\"",
        "callableNotInstantiable": "Невозможно создать экземпляр типа \"{type}\"",
        "callableSecondArg": "В качестве аргумента второго типа для \"Callable\" ожидается возвращаемый тип",
        "casePatternIsIrrefutable": "Неопровержимый шаблон допускается только для последнего оператора case",
        "classAlreadySpecialized": "Тип \"{type}\" уже специализирован",
        "classDecoratorTypeUnknown": "Нетипизированный декоратор класса скрывает тип класса. Игнорирование декоратора",
        "classDefinitionCycle": "Определение класса для \"{name}\" зависит от себя",
        "classGetItemClsParam": "Переопределение метода __class_getitem__ должно принимать параметр \"cls\"",
        "classMethodClsParam": "Методы класса должны принимать параметр cls",
        "classNotRuntimeSubscriptable": "Операция взятия подстроки для класса \"{name}\" создаст исключение среды выполнения; заключите заметку типа в кавычки",
        "classPatternBuiltInArgPositional": "Шаблон класса принимает только позиционный вложенный шаблон",
        "classPatternPositionalArgCount": "Слишком много позиционных шаблонов для класса \"{type}\"; ожидается {expected}, но получено {received}",
        "classPatternTypeAlias": "\"{type}\" нельзя использовать в шаблоне класса, поскольку это псевдоним специализированного типа",
        "classPropertyDeprecated": "Свойства класса упразднены в Python 3.11 и не будут поддерживаться в Python 3.13",
        "classTypeParametersIllegal": "Синтаксис параметра типа класса может использоваться в Python версии не ниже 3.12.",
        "classVarFirstArgMissing": "Ожидается аргумент типа после \"ClassVar\"",
        "classVarNotAllowed": "Использование \"ClassVar\" в этом контексте не допускается",
        "classVarOverridesInstanceVar": "Переменная класса \"{name}\" переопределяет переменную экземпляра с тем же именем в классе \"{className}\"",
        "classVarTooManyArgs": "Ожидается только один аргумент типа после \"ClassVar\"",
        "classVarWithTypeVar": "Тип \"ClassVar\" не может включать переменные типа",
        "clsSelfParamTypeMismatch": "Тип параметра \"{name}\" должен быть супертипом своего класса \"{classType}\"",
        "codeTooComplexToAnalyze": "Код слишком сложен для анализа; уменьшите сложность, разбив его на фрагменты (вложенные процедуры) или сократите количество условных конструкций",
        "collectionAliasInstantiation": "Тип \"{type}\" не может быть создан, вместо этого используйте \"{alias}\"",
        "comparisonAlwaysFalse": "Условие всегда будет оцениваться как ЛОЖЬ, поскольку типы \"{leftType}\" и \"{rightType}\" не перекрываются",
        "comparisonAlwaysTrue": "Выражение всегда будет возвращать значение True, поскольку типы \"{leftType}\" и \"{rightType}\" не перекрываются",
        "comprehensionInDict": "Понимание не может использоваться с другими записями словаря",
        "comprehensionInSet": "Понимание не может использоваться с другими записями набора",
        "concatenateContext": "\"Concatenate\" не допускается в этом контексте",
        "concatenateParamSpecMissing": "Последний аргумент типа для \"Concatenate\" должен быть ParamSpec или \"...\"",
        "concatenateTypeArgsMissing": "Для \"Concatenate\" требуется по крайней мере два аргумента типа",
        "conditionalOperandInvalid": "Недопустимый условный операнд типа \"{type}\"",
        "constantRedefinition": "\"{name}\" является константой (поскольку оно в верхнем регистре) и не может быть переопределено.",
        "constructorNoArgs": "Для конструктора \"{type}\" не ожидается аргументов",
        "constructorParametersMismatch": "Несоответствие подписи __new__ и __init__ в классе \"{classType}\"",
        "containmentAlwaysFalse": "Выражение всегда будет оцениваться как ЛОЖЬ, так как типы \"{leftType}\" и \"{rightType}\" не перекрываются",
        "containmentAlwaysTrue": "Выражение всегда будет оцениваться как ИСТИНА, так как типы \"{leftType}\" и \"{rightType}\" не перекрываются",
        "continueInFinally": "Невозможно использовать \"continue\" в предложении finally",
        "continueOutsideLoop": "Ключевое слово \"continue\" можно использовать только внутри цикла",
        "coroutineInConditionalExpression": "Условное выражение ссылается на сопрограмму, которая всегда возвращает значение True",
        "dataClassBaseClassFrozen": "Незафиксированный класс не может наследоваться от зафиксированного класса",
        "dataClassBaseClassNotFrozen": "Незафиксированный класс не может наследоваться от зафиксированного класса",
        "dataClassConverterFunction": "Аргумент типа \"{argType}\" не является допустимым преобразователем для поля \"{fieldName}\" типа \"{fieldType}\"",
        "dataClassConverterOverloads": "Ни одна перегрузка \"{funcName}\" не является допустимым преобразователем поля \"{fieldName}\" типа \"{fieldType}\"",
        "dataClassFieldInheritedDefault": "\"{fieldName}\" переопределяет поле с тем же именем, но в нем отсутствует значение по умолчанию",
        "dataClassFieldWithDefault": "Поля без значений по умолчанию не могут отображаться после полей со значениями по умолчанию.",
        "dataClassFieldWithPrivateName": "Поле класса данных не может использовать закрытое имя",
        "dataClassFieldWithoutAnnotation": "Поле dataclass без заметки с типом вызовет исключение среды выполнения",
        "dataClassPostInitParamCount": "Неверное число параметров в методе __post_init__ класса данных; ожидается число, соответствующее числу полей InitVar {expected}",
        "dataClassPostInitType": "Тип параметра метода __post_init__ в классе данных не соответствует типу поля \"{fieldName}\"",
        "dataClassSlotsOverwrite": "__slots__ уже определен в классе",
        "dataClassTransformExpectedBoolLiteral": "Ожидается выражение, статически оцениваемое как ИСТИНА или ЛОЖЬ",
        "dataClassTransformFieldSpecifier": "Ожидается кортеж классов или функций, но получен тип \"{type}\"",
        "dataClassTransformPositionalParam": "Все аргументы \"dataclass_transform\" должны быть аргументами типа \"ключевое слово\"",
        "dataClassTransformUnknownArgument": "Аргумент \"{name}\" не поддерживается в dataclass_transform",
        "dataProtocolInSubclassCheck": "Протоколы данных (включающие атрибуты, не связанные с методами) запрещены в вызовах issubclass",
        "declaredReturnTypePartiallyUnknown": "Объявленный тип возвращаемого значения \"{returnType}\" частично неизвестен",
        "declaredReturnTypeUnknown": "Объявленный тип возвращаемого значения неизвестен",
        "defaultValueContainsCall": "Вызовы функций и изменяемые объекты не разрешены в выражении значения параметра по умолчанию",
        "defaultValueNotAllowed": "Параметр с \"*\" или \"**\" не может иметь значение по умолчанию",
        "delTargetExpr": "Не удается удалить выражение",
        "deprecatedClass": "Класс \"{name}\" является нерекомендуемым",
        "deprecatedConstructor": "Конструктор для класса \"{name}\" больше не рекомендуется к использованию",
        "deprecatedDescriptorDeleter": "Метод \"__delete__\" для дескриптора \"{name}\" не рекомендуется",
        "deprecatedDescriptorGetter": "Метод \"__get__\" для дескриптора \"{name}\" не рекомендуется",
        "deprecatedDescriptorSetter": "Метод \"__set__\" для дескриптора \"{name}\" не рекомендуется",
        "deprecatedFunction": "Функция \"{name}\" больше не рекомендуется к использованию",
        "deprecatedMethod": "Метод \"{name}\" в классе \"{className}\" не рекомендуется к использованию",
        "deprecatedPropertyDeleter": "Метод удаления для свойства \"{name}\" не рекомендуется",
        "deprecatedPropertyGetter": "Метод получения для свойства \"{name}\" не рекомендуется",
        "deprecatedPropertySetter": "Метод задания для свойства \"{name}\" не рекомендуется",
        "deprecatedType": "Этот тип больше не рекомендуется к использованию начиная с версии Python {version}; используйте вместо него \"{replacement}\"",
        "dictExpandIllegalInComprehension": "Расширение словаря в понимании не допускается",
        "dictInAnnotation": "Словарные выражения не разрешены в заметках типа",
        "dictKeyValuePairs": "Записи словаря должны содержать пары \"ключ-значение\"",
        "dictUnpackIsNotMapping": "Ожидается сопоставление для оператора распаковки словаря",
        "dunderAllSymbolNotPresent": "\"{name}\" указано в методе __all__, но отсутствует в модуле",
        "duplicateArgsParam": "Разрешен только один параметр \"*\"",
        "duplicateBaseClass": "Дублирование базового класса не допускается",
        "duplicateCapturePatternTarget": "Целевой объект захвата \"{name}\" не может появляться более одного раза в одном шаблоне",
        "duplicateCatchAll": "В блоке except допускается только одно предложение catch-all",
        "duplicateEnumMember": "Элемент перечислимого типа \"{name}\" уже объявлен",
        "duplicateGenericAndProtocolBase": "Допускается только один базовый класс Generic[...] или Protocol[...]",
        "duplicateImport": "\"{importName}\" импортируется несколько раз",
        "duplicateKeywordOnly": "Разрешен только один разделитель \"*\"",
        "duplicateKwargsParam": "Разрешен только один параметр \"**\"",
        "duplicateParam": "Параметр \"{name}\" повторяется",
        "duplicatePositionOnly": "Разрешен только один параметр \"/\"",
        "duplicateStarPattern": "В последовательности шаблонов допускается только один шаблон \"*\"",
        "duplicateStarStarPattern": "Допускается только одна запись \"**\"",
        "duplicateUnpack": "В списке разрешена только одна операция распаковки",
        "ellipsisAfterUnpacked": "\"...\" не может использоваться с распакованным элементом TypeVarTuple или кортежем",
        "ellipsisContext": "\"...\" не допускается в данном контексте",
        "ellipsisSecondArg": "\"...\" разрешается только в качестве второго из двух аргументов",
        "enumClassOverride": "Перечислимый класс \"{name}\" является окончательным и не может иметь производных классов",
        "exceptionGroupIncompatible": "Синтаксис группы исключений (\"except*\") можно использовать в Python версии не ранее 3.11",
        "exceptionTypeIncorrect": "\"{type}\" не является производным от BaseException",
        "exceptionTypeNotClass": "\"{type}\" не является допустимым классом исключений",
        "exceptionTypeNotInstantiable": "Конструктору типа исключения \"{type}\" требуется один или несколько аргументов",
        "expectedAfterDecorator": "Ожидаемая функция или объявление класса после декоратора",
        "expectedArrow": "Ожидается \"->\", за которым следует заметка типа к возвращаемому типу",
        "expectedAsAfterException": "Ожидается \"as\" после типа исключения",
        "expectedAssignRightHandExpr": "Справа от \"=\" ожидается выражение",
        "expectedBinaryRightHandExpr": "Справа от оператора ожидается выражение",
        "expectedBoolLiteral": "Ожидается ИСТИНА или ЛОЖЬ",
        "expectedCase": "Ожидается оператор case",
        "expectedClassName": "Ожидается имя класса",
        "expectedCloseBrace": "Для скобки \"{\" отсутствует закрывающая скобка",
        "expectedCloseBracket": "Для скобки \"[\" отсутствует закрывающая скобка",
        "expectedCloseParen": "Для скобки \"(\" отсутствует закрывающая скобка",
        "expectedColon": "Ожидается \":\"",
        "expectedComplexNumberLiteral": "Для сопоставления шаблонов ожидается сложный числовой литерал",
        "expectedDecoratorExpr": "Форму выражения для декоратора можно использовать в Python версии не ниже 3.9",
        "expectedDecoratorName": "Ожидается имя декоратора",
        "expectedDecoratorNewline": "В конце декоратора ожидается символ перехода на новую строку",
        "expectedDelExpr": "После \"del\" ожидается выражение",
        "expectedElse": "Ожидается ключевое слово \"else\"",
        "expectedEquals": "Ожидается \"=\"",
        "expectedExceptionClass": "Недопустимый класс или объект исключения",
        "expectedExceptionObj": "Ожидается объект исключения, класс исключения или значение None",
        "expectedExpr": "Ожидается выражение",
        "expectedFunctionAfterAsync": "Ожидается определение функции после \"async\"",
        "expectedFunctionName": "После ключевого слова \"def\" ожидается имя функции",
        "expectedIdentifier": "Ожидается идентификатор",
        "expectedImport": "Ожидается \"import\"",
        "expectedImportAlias": "После \"as\" ожидается символ",
        "expectedImportSymbols": "После операторов импорта ожидается одно или несколько имен символов",
        "expectedIn": "Ожидается \"in\"",
        "expectedInExpr": "После ключевого слова \"in\" ожидается выражение",
        "expectedIndentedBlock": "Ожидается блок с отступом",
        "expectedMemberName": "Требуется указать имя атрибута после \".\"",
        "expectedModuleName": "Ожидаемое имя модуля",
        "expectedNameAfterAs": "Ожидается имя символа после \"as\"",
        "expectedNamedParameter": "За \"*\" должен следовать параметр типа \"ключевое слово\"",
        "expectedNewline": "Ожидается новая строка",
        "expectedNewlineOrSemicolon": "Операторы должны быть разделены символами перевода строки или точками с запятой",
        "expectedOpenParen": "Ожидается \"(\"",
        "expectedParamName": "Ожидается имя параметра",
        "expectedPatternExpr": "Ожидается выражение шаблона",
        "expectedPatternSubjectExpr": "Ожидаемое выражение субъекта шаблона",
        "expectedPatternValue": "Ожидается выражение значения шаблона в форме \"a.b\"",
        "expectedReturnExpr": "После \"return\" ожидается выражение",
        "expectedSliceIndex": "Ожидается выражение индекса или среза",
        "expectedTypeNotString": "Ожидался тип, но получен строковый литерал",
        "expectedTypeParameterName": "Ожидаемое имя параметра типа",
        "expectedYieldExpr": "Ожидаемое выражение в операторе yield",
        "finalClassIsAbstract": "Класс \"{type}\" помечен как final (окончательный) и должен реализовать все абстрактные символы.",
        "finalContext": "\"Final\" не допускается в данном контексте",
        "finalMethodOverride": "Метод \"{name}\" не может переопределять окончательный метод, определенный в классе \"{className}\"",
        "finalNonMethod": "Функцию \"{name}\" нельзя пометить как @окончательную, так как она не является методом",
        "finalReassigned": "\"{name}\" объявляется окончательным и не может быть переназначено",
        "finalRedeclaration": "\"{name}\" ранее объявлено как Final",
        "finalRedeclarationBySubclass": "\"{name}\" невозможно повторно объявить, поскольку в родительском классе \"{className}\" он объявлен как final",
        "finalTooManyArgs": "После \"Final\" ожидается один аргумент типа",
        "finalUnassigned": "\"{name}\" объявлен как Final, но ему не присвоено значение",
        "formatStringBrace": "Одиночная закрывающая скобка не допускается в литерале f-строки. Используйте двойную закрывающую скобку",
        "formatStringBytes": "Строковые литералы формата (f-строки) не могут быть двоичными",
        "formatStringDebuggingIllegal": "Для описателя отладки F-строки \"=\" требуется версия Python 3.8 или более новая",
        "formatStringEscape": "Escape-последовательность (обратная косая черта) не разрешена в части выражения f-строки до версии Python 3.12",
        "formatStringExpectedConversion": "После \"!\" в f-строке ожидался спецификатор преобразования",
        "formatStringIllegal": "Для строковых литералов формата (f-строки) требуется версия Python 3.6 или более новая",
        "formatStringInPattern": "Строка формата не разрешена в шаблоне",
        "formatStringNestedFormatSpecifier": "В строке спецификации формата слишком высок уровень вложенности выражений",
        "formatStringNestedQuote": "Строки, вложенные в f-строку, не могут использовать тот же символ кавычка, что и f-строка до Python 3.12",
        "formatStringUnicode": "Строковые литералы формата (f-строки) не могут быть в кодировке Unicode",
        "formatStringUnterminated": "Незавершенное выражение в f-строке; ожидается \"}\"",
        "functionDecoratorTypeUnknown": "Нетипизированный декоратор функции скрывает тип функции; декоратор будет игнорирован",
        "functionInConditionalExpression": "Условное выражение ссылается на функцию, которая всегда возвращает значение True",
        "functionTypeParametersIllegal": "Для синтаксиса параметра типа функции требуется версия Python 3.12 или более новая",
        "futureImportLocationNotAllowed": "Операторы импорта из __future__ должны находиться в начале файла",
        "generatorAsyncReturnType": "Возвращаемый тип функции асинхронного генератора должен быть совместим с \"AsyncGenerator[{yieldType}, Any]\"",
        "generatorNotParenthesized": "Выражения генератора следует взять в скобки, если аргументов больше одного",
        "generatorSyncReturnType": "Возвращаемый тип функции генератора должен быть совместим с \"Generator[{yieldType}, Any, Any]\"",
        "genericBaseClassNotAllowed": "Базовый класс \"Generic\" нельзя использовать с синтаксисом параметра типа",
        "genericClassAssigned": "Универсальный тип класса невозможно присвоить",
        "genericClassDeleted": "Не удается удалить универсальный тип класса",
        "genericInstanceVariableAccess": "Доступ к универсальной переменной экземпляра через класс является неоднозначным",
        "genericNotAllowed": "Ключевое слово \"Generic\" недопустимо в этом контексте",
        "genericTypeAliasBoundTypeVar": "Псевдоним универсального типа в классе не может использовать переменные привязанного типа {names}",
        "genericTypeArgMissing": "Для \"Generic\" требуется по крайней мере один аргумент типа",
        "genericTypeArgTypeVar": "Аргумент типа для \"Generic\" должен быть переменной типа",
        "genericTypeArgUnique": "Аргументы типа для \"Generic\" должны быть уникальными",
        "globalReassignment": "Присвоение \"{name}\" происходит раньше глобального объявления",
        "globalRedefinition": "Имя \"{name}\" уже объявлено ранее как глобальное",
        "implicitStringConcat": "Неявное объединение строк не разрешено",
        "importCycleDetected": "Обнаружен цикл в цепочке импорта",
        "importDepthExceeded": "Глубина цепочки импорта превысила {depth}",
        "importResolveFailure": "Не удается разрешить импорт \"{importName}\"",
        "importSourceResolveFailure": "Не удается разрешить импорт \"{importName}\" из источника",
        "importSymbolUnknown": "\"{name}\" — неизвестный символ импорта",
        "incompatibleMethodOverride": "Метод \"{name}\" переопределяет класс \"{className}\" несовместимым образом",
        "inconsistentIndent": "Сумма отступа не соответствует предыдущему отступу",
        "inconsistentTabs": "Непоследовательное использование вкладок и пробелов в отступах",
        "initMethodSelfParamTypeVar": "Заметка типа для параметра \"self\" метода \"__init__\" не может содержать переменные типа в области класса.",
        "initMustReturnNone": "Метод \"__init__\" должен возвращать тип None",
        "initSubclassCallFailed": "Неверные аргументы ключевых слов для метода __init_subclass__",
        "initSubclassClsParam": "Переопределение метода __init_subclass__ должно принимать параметр \"cls\"",
        "initVarNotAllowed": "Использование \"InitVar\" в этом контексте не допускается",
        "instanceMethodSelfParam": "Методы экземпляра должны принимать параметр \"self\"",
        "instanceVarOverridesClassVar": "Переменная экземпляра \"{name}\" переопределяет переменную класса с тем же именем в классе \"{className}\"",
        "instantiateAbstract": "Не удается создать экземпляр абстрактного класса \"{type}\"",
        "instantiateProtocol": "Не удается создать экземпляр класса протокола \"{type}\"",
        "internalBindError": "При привязке файла \"{file}\" произошла внутренняя ошибка: {message}",
        "internalParseError": "При разборе файла \"{file}\" произошла внутренняя ошибка: {message}",
        "internalTypeCheckingError": "При проверке файла \"{file}\" произошла внутренняя ошибка: {message}",
        "invalidIdentifierChar": "Недопустимый символ в идентификаторе",
        "invalidStubStatement": "Инструкция не имеет смысла в файле-заглушке типа",
        "invalidTokenChars": "Недопустимый символ \"{text}\" в маркере",
        "isInstanceInvalidType": "Второй аргумент \"isinstance\" должен быть классом или кортежем классов",
        "isSubclassInvalidType": "Второй аргумент в \"issubclass\" должен быть классом или кортежем классов",
        "keyValueInSet": "Пары \"ключ-значение\" не допускаются в наборе",
        "keywordArgInTypeArgument": "Аргументы ключевых слов нельзя использовать в списках аргументов типа",
        "keywordOnlyAfterArgs": "Разделитель аргументов типа \"только ключевое слово\" не разрешен после параметра \"*\"",
        "keywordParameterMissing": "За параметром \"*\" должен следовать один или несколько параметров ключевого слова.",
        "keywordSubscriptIllegal": "Аргументы ключевых слов в нижних индексах не поддерживаются",
        "lambdaReturnTypePartiallyUnknown": "Тип возвращаемого лямбдой значения \"{returnType}\" частично неизвестен",
        "lambdaReturnTypeUnknown": "Тип значения, возвращаемого лямбдой, неизвестен",
        "listAssignmentMismatch": "Выражение с типом \"{type}\" нельзя присвоить целевому списку",
        "listInAnnotation": "Списочное выражение не разрешено в заметке типа",
        "literalEmptyArgs": "Ожидается один или несколько аргументов типа после \"Literal\"",
        "literalNamedUnicodeEscape": "Именованные escape-последовательности Юникода не поддерживаются в аннотациях строк литералов",
        "literalNotAllowed": "Невозможно использовать \"Literal\" в этом контексте без аргумента типа",
        "literalNotCallable": "Не удается создать экземпляр типа литерала",
        "literalUnsupportedType": "Аргументы типа для \"Literal\" должны иметь значение None, литеральное значение (int, bool, str или bytes) или значение перечислимого типа",
        "matchIncompatible": "Операторы соответствия могут использоваться в Python версии не ниже 3.10",
        "matchIsNotExhaustive": "Блоки case в операторе match обрабатывают не все множество возможных значений",
        "maxParseDepthExceeded": "Превышена максимальная глубина разбора; разбейте выражение на составляющие выражения меньшего размера",
        "memberAccess": "Не удается получить доступ к атрибуту \"{name}\" для класса \"{type}\"",
        "memberDelete": "Не удается удалить атрибут \"{name}\" для класса \"{type}\"",
        "memberSet": "Не удается назначить атрибуту \"{name}\" для класса \"{type}\"",
        "metaclassConflict": "Метакласс производного класса должен быть производным классом метаклассов всех его базовых классов",
        "metaclassDuplicate": "Можно указать только один метакласс",
        "metaclassIsGeneric": "Метакласс не может быть универсальным",
        "methodNotDefined": "Метод \"{name}\" не определен",
        "methodNotDefinedOnType": "Метод \"{name}\" не определен для типа \"{type}\"",
        "methodOrdering": "Не удается создать согласованный порядок методов",
        "methodOverridden": "\"{name}\" переопределяет метод с тем же именем в классе \"{className}\" с несовместимым типом \"{type}\"",
        "methodReturnsNonObject": "Метод \"{name}\" не возвращает объект",
        "missingSuperCall": "Метод \"{methodName}\" не вызывает метод с тем же именем в родительском классе",
        "moduleAsType": "Модуль не может использоваться в качестве типа",
        "moduleNotCallable": "Модуль не является вызываемым",
        "moduleUnknownMember": "\"{memberName}\" не является известным атрибутом модуля \"{moduleName}\"",
        "namedExceptAfterCatchAll": "Именованное предложение исключения не может стоять после предложения catch-all except",
        "namedParamAfterParamSpecArgs": "Параметр ключевого слова \"{name}\" не может размещаться в сигнатуре после параметра аргументов ParamSpec",
        "namedTupleEmptyName": "Имена в именованном кортеже не могут быть пустыми",
        "namedTupleEntryRedeclared": "Не удается переопределить \"{name}\", так как родительский класс \"{className}\" является именованным кортежем",
        "namedTupleFirstArg": "В качестве первого аргумента ожидалось имя именованного класса кортежа",
        "namedTupleMultipleInheritance": "Множественное наследование для NamedTuple не поддерживается",
        "namedTupleNameKeyword": "Имена полей не могут быть ключевыми словами",
        "namedTupleNameType": "Ожидается двухфакторный кортеж с указанием имени и типа записи",
        "namedTupleNameUnique": "Имена внутри именованного кортежа должны быть уникальными",
        "namedTupleNoTypes": "\"namedtuple\" не предоставляет типов для записей кортежа; используйте вместо него \"NamedTuple\"",
        "namedTupleSecondArg": "В качестве второго аргумента ожидается список записей именованного кортежа",
        "newClsParam": "Переопределение метода __new__ должно принимать параметр \"cls\"",
        "newTypeAnyOrUnknown": "Второй аргумент для NewType должен быть известным классом, а не вариантом \"Любой\" или \"Неизвестный\"",
        "newTypeBadName": "Первый аргумент NewType должен быть строковым литералом",
        "newTypeLiteral": "NewType нельзя использовать с типом литерала",
        "newTypeNameMismatch": "NewType должен быть назначен переменной с тем же именем",
        "newTypeNotAClass": "В NewType в качестве второго аргумента ожидается класс",
        "newTypeParamCount": "Для NewType требуются два позиционных аргумента",
        "newTypeProtocolClass": "NewType нельзя использовать со структурным типом (протокол или класс TypedDict)",
        "noOverload": "Не существует перегрузок для \"{name}\", соответствующих указанным аргументам",
        "noReturnContainsReturn": "Функция с объявленным типом возвращаемого значения \"NoReturn\" не может содержать оператор return",
        "noReturnContainsYield": "Функция с объявленным типом возвращаемого значения \"NoReturn\" не может содержать инструкцию yield",
        "noReturnReturnsNone": "Функция с объявленным типом возвращаемого значения \"NoReturn\" не может возвращать \"None\"",
        "nonDefaultAfterDefault": "Аргумент, отличный от аргумента по умолчанию, следует за аргументом по умолчанию",
        "nonLocalInModule": "Нелокальные объявления на уровне модулей не разрешены",
        "nonLocalNoBinding": "Привязка для нелокального элемента \"{name}\" не найдена",
        "nonLocalReassignment": "Назначение \"{name}\" происходит раньше нелокального объявления",
        "nonLocalRedefinition": "\"{name}\" уже объявлено ранее как нелокальное",
        "noneNotCallable": "Объект типа \"None\" не может быть вызван",
        "noneNotIterable": "Объект типа \"None\" не может использоваться в качестве итерируемого значения",
        "noneNotSubscriptable": "Объект типа \"None\" не подлежит подписке",
        "noneNotUsableWith": "Объект типа \"None\" нельзя использовать с ключевым словом \"with\"",
        "noneOperator": "Оператор \"{operator}\" не поддерживается для \"None\"",
        "noneUnknownMember": "\"{name}\" не является известным атрибутом \"None\"",
        "notRequiredArgCount": "После \"NotRequired\" ожидается один аргумент типа",
        "notRequiredNotInTypedDict": "Использование \"NotRequired\" в этом контексте не допускается",
        "objectNotCallable": "Объект типа \"{type}\" не является вызываемым",
        "obscuredClassDeclaration": "Объявление класса \"{name}\" скрывается объявлением с тем же именем",
        "obscuredFunctionDeclaration": "Объявление функции \"{name}\" скрывается объявлением с тем же именем",
        "obscuredMethodDeclaration": "Объявление метода \"{name}\" скрывается объявлением с тем же именем",
        "obscuredParameterDeclaration": "Объявление параметра \"{name}\" скрывается объявлением с тем же именем",
        "obscuredTypeAliasDeclaration": "Объявление псевдонима типа \"{name}\" скрывается объявлением с тем же именем",
        "obscuredVariableDeclaration": "Объявление \"{name}\" скрывается объявлением с тем же именем",
        "operatorLessOrGreaterDeprecated": "Оператор \"<>\" не поддерживается в Python 3; используйте вместо него \"!=\"",
        "optionalExtraArgs": "Ожидается один аргумент типа после \"Optional\"",
        "orPatternIrrefutable": "Неопровержимый шаблон допускается только в качестве последнего вложенного шаблона в шаблоне \"or\"",
        "orPatternMissingName": "Все вложенные шаблоны в шаблоне \"or\" должны быть привязаны к одним и тем же именам",
        "overlappingKeywordArgs": "Типизированный словарь перекрывается с параметром ключевого слова: {names}",
        "overlappingOverload": "Перегрузка {obscured} для \"{name}\" никогда не будет использоваться, так как ее параметры перекрывают перегрузку {obscuredBy}",
        "overloadAbstractMismatch": "Все перегруженные методы должны быть абстрактными или не абстрактными",
        "overloadClassMethodInconsistent": "Перегрузки для \"{name}\" используют @classmethod несогласованно",
        "overloadFinalInconsistencyImpl": "Перегрузка для \"{name}\" помечена как @окончательная, но реализация — нет",
        "overloadFinalInconsistencyNoImpl": "Перегрузка {index} для \"{name}\" помечена как @окончательная, но перегрузка 1 — нет",
        "overloadImplementationMismatch": "Перегруженная реализация не согласована с сигнатурой перегрузки {index}",
        "overloadReturnTypeMismatch": "Перегрузка {prevIndex} для \"{name}\" перекрывает перегрузку {newIndex} и возвращает несовместимый тип",
        "overloadStaticMethodInconsistent": "Перегрузки для \"{name}\" используют @staticmethod несогласованно",
        "overloadWithoutImplementation": "\"{name}\" помечен как перегруженный, но реализация не предоставлена",
        "overriddenMethodNotFound": "Метод \"{name}\" помечен как переопределение, но базового метода с таким же именем нет.",
        "overrideDecoratorMissing": "Метод \"{name}\" не помечен в качестве переопределения, но переопределяет метод в классе \"{className}\"",
        "paramAfterKwargsParam": "Параметр не может следовать за параметром \"**\"",
        "paramAlreadyAssigned": "Параметр \"{name}\" уже назначен.",
        "paramAnnotationMissing": "Отсутствует заметка с типом для параметра \"{name}\"",
        "paramAssignmentMismatch": "Выражение типа \"{sourceType}\" не может быть назначено параметру типа \"{paramType}\"",
        "paramNameMissing": "Параметра с именем \"{name}\" не существует",
        "paramSpecArgsKwargsUsage": "Атрибуты \"args\" и \"kwargs\" ParamSpec должны одновременно присутствовать в сигнатуре функции",
        "paramSpecArgsMissing": "Отсутствуют аргументы для \"{type}\" ParamSpec",
        "paramSpecArgsUsage": "Атрибут \"args\" ParamSpec допустим только при использовании с параметром *args",
        "paramSpecAssignedName": "ParamSpec необходимо присвоить переменной с именем \"{name}\"",
        "paramSpecContext": "ParamSpec не допускается в этом контексте",
        "paramSpecDefaultNotTuple": "Для значения ParamSpec по умолчанию ожидается многоточие, выражение кортежа или ParamSpec",
        "paramSpecFirstArg": "Ожидается имя ParamSpec в качестве первого аргумента",
        "paramSpecKwargsUsage": "Атрибут \"kwargs\" ParamSpec допустим только при использовании с параметром *kwargs",
        "paramSpecNotUsedByOuterScope": "ParamSpec \"{name}\" не имеет смысла в этом контексте",
        "paramSpecUnknownArg": "ParamSpec не поддерживает более одного аргумента",
        "paramSpecUnknownMember": "\"{name}\" не является известным атрибутом ParamSpec",
        "paramSpecUnknownParam": "\"{name}\" является неизвестным параметром для ParamSpec",
        "paramTypeCovariant": "Переменную ковариантного типа нельзя использовать в типе параметра",
        "paramTypePartiallyUnknown": "Тип параметра \"{paramName}\" частично неизвестен",
        "paramTypeUnknown": "Тип параметра \"{paramName}\" неизвестен",
        "parenthesizedContextManagerIllegal": "Для скобок в операторе \"with\" требуется версия Python 3.9 или более новая",
        "patternNeverMatches": "Шаблон никогда не будет совпадать для типа субъекта \"{type}\"",
        "positionArgAfterNamedArg": "Позиционный аргумент не может стоять после аргументов типа \"ключевое слово\"",
        "positionOnlyAfterArgs": "Разделитель чисто позиционных параметров после параметра \"*\" не разрешен",
        "positionOnlyAfterKeywordOnly": "Параметр \"/\" должен располагаться перед параметром \"*\"",
        "positionOnlyAfterNon": "Чисто позиционный параметр не разрешен после параметра, который не является чисто позиционным",
        "positionOnlyFirstParam": "Разделитель чисто позиционных параметров в качестве первого параметра не разрешен",
        "positionOnlyIncompatible": "Разделитель чисто позиционных параметров можно использовать в Python версии не ниже 3.8",
        "privateImportFromPyTypedModule": "\"{name}\" не экспортируется из модуля \"{module}\"",
        "privateUsedOutsideOfClass": "Элемент \"{name}\" является закрытым, но используется вне класса, в котором объявлен",
        "privateUsedOutsideOfModule": "\"{name}\" является закрытым, но используется вне модуля, в котором объявлен",
        "propertyOverridden": "\"{name}\" неправильно переопределяет свойство с таким же именем в классе \"{className}\"",
        "propertyStaticMethod": "Статические методы не разрешены в методах получения, задания и удаления свойств",
        "protectedUsedOutsideOfClass": "\"{name}\" защищено и используется вне класса, в котором оно объявлено",
        "protocolBaseClass": "Класс протокола \"{classType}\" не может быть производным от непротокольного класса \"{baseType}\"",
        "protocolBaseClassWithTypeArgs": "Аргументы типа не допускаются с классом протокола при использовании синтаксиса параметра типа",
        "protocolIllegal": "Ключевое слово \"Protocol\" можно использовать в Python версии не ниже 3.7",
        "protocolNotAllowed": "Невозможно использовать \"Protocol\" в этом контексте",
        "protocolUnsafeOverlap": "Класс небезопасно перекрывает \"{name}\" и может вызвать совпадение во время выполнения",
        "protocolVarianceContravariant": "Переменная типа \"{variable}\", используемая в универсальном протоколе \"{class}\", должна быть контравариантной.",
        "protocolVarianceCovariant": "Переменная типа \"{variable}\", используемая в универсальном протоколе \"{class}\", должна быть ковариантной",
        "protocolVarianceInvariant": "Переменная типа \"{variable}\", используемая в универсальном протоколе \"{class}\", должна быть инвариантной",
        "pyrightCommentInvalidDiagnosticBoolValue": "За директивой комментария Pyright должно следовать \"=\" и значение true или false",
        "pyrightCommentInvalidDiagnosticSeverityValue": "За директивой комментария pyright должно следовать \"=\" и одно из следующих значений: true, false, error, warning, information или none",
        "pyrightCommentMissingDirective": "После комментария pyright должна следовать директива (обычная или строгая) или правило диагностики",
        "pyrightCommentNotOnOwnLine": "Комментарии Pyright, используемые для управления параметрами на уровне файлов, должны располагаться в отдельной строке",
        "pyrightCommentUnknownDiagnosticRule": "Правило диагностики \"{rule}\" для комментария pyright неизвестно",
        "pyrightCommentUnknownDiagnosticSeverityValue": "Значение \"{value}\" недопустимо для комментария pyright; ожидается одно из значений true, false, error, warning, information или none",
        "pyrightCommentUnknownDirective": "\"{directive}\" является неизвестной директивой для комментария pyright; ожидается \"strict\" или \"basic\"",
        "readOnlyArgCount": "Ожидается один аргумент типа после \"ReadOnly\"",
        "readOnlyNotInTypedDict": "Использование \"ReadOnly\" в этом контексте не допускается",
        "recursiveDefinition": "Не удалось определить тип \"{name}\", так как он ссылается на себя",
        "relativeImportNotAllowed": "Операции импорта с относительным путем нельзя использовать с формой \"import .a\"; используйте вместо этого \"from . import a\"",
        "requiredArgCount": "Ожидается один аргумент типа после \"Required\"",
        "requiredNotInTypedDict": "Использование \"Required\" в этом контексте не допускается",
        "returnInAsyncGenerator": "Оператор return со значением не допускается в асинхронном генераторе",
        "returnMissing": "Функция с объявленным типом возвращаемого значения \"{returnType}\" должна возвращать значение во всех путях кода",
        "returnOutsideFunction": "\"return\" можно использовать только внутри функции",
        "returnTypeContravariant": "Переменная контравариантного типа не может использоваться в возвращаемом типе",
        "returnTypeMismatch": "Выражение типа \"{exprType}\" несовместимо с возвращаемым типом \"{returnType}\"",
        "returnTypePartiallyUnknown": "Тип возвращаемого значения \"{returnType}\" частично неизвестен",
        "returnTypeUnknown": "Тип возвращаемого значения неизвестен",
        "revealLocalsArgs": "Не ожидаются аргументы для вызова \"reveal_locals\"",
        "revealLocalsNone": "В этой области нет локальных элементов",
        "revealTypeArgs": "Для вызова \"reveal_type\" ожидается один позиционный аргумент",
        "revealTypeExpectedTextArg": "Аргумент \"expected_text\" для функции \"reveal_type\" должен быть значением литерала str",
        "revealTypeExpectedTextMismatch": "Несоответствие текста в типе; ожидалось \"{expected}\", но получено \"{received}\"",
        "revealTypeExpectedTypeMismatch": "Несоответствие типов; ожидается \"{expected}\", но получено \"{received}\"",
        "selfTypeContext": "'В этом контексте ключевое слово \"Self\" недопустимо",
        "selfTypeMetaclass": "\"Self\" нельзя использовать в метаклассе (подкласс \"type\")",
        "selfTypeWithTypedSelfOrCls": "Ключевое слово \"Self\" нельзя использовать в функции с параметром \"self\" или \"cls\" с заметкой типа, отличной от \"Self\".",
        "setterGetterTypeMismatch": "Тип значения метода задания свойства нельзя присвоить типу возвращаемого значения метода получения",
        "singleOverload": "Элемент \"{name}\" помечен как перегруженный, но дополнительные перегрузки отсутствуют",
        "slotsAttributeError": "\"{name}\" не указано в __slots__",
        "slotsClassVarConflict": "\"{name}\" конфликтует с переменной экземпляра, объявленной в __slots__",
        "starPatternInAsPattern": "Шаблон \"звездочка\" не может использоваться с целевым объектом \"as\"",
        "starPatternInOrPattern": "Шаблон \"звездочка\" не может быть аргументом операции OR в других шаблонах",
        "starStarWildcardNotAllowed": "** нельзя использовать с символом подстановки \"_\"",
        "staticClsSelfParam": "Статические методы не принимают в качестве параметра \"self\" и \"cls\"",
        "stdlibModuleOverridden": "\"{path}\" переопределяет модуль stdlib \"{name}\"",
        "stringNonAsciiBytes": "Символы, отличные от ASCII, не допускаются в строковом литерале байтов",
        "stringNotSubscriptable": "От строкового выражения нельзя взять подстроку в заметке типа; заключите всю заметку в кавычки",
        "stringUnsupportedEscape": "Неподдерживаемая escape-последовательность в строковом литерале",
        "stringUnterminated": "В строковом литерале отсутствует символ конца строки",
        "stubFileMissing": "Файл-заглушка для \"{importName}\" не найден",
        "stubUsesGetAttr": "Файл-заглушка типа неполон; \"__getattr__\" скрывает ошибки типа для модуля",
        "sublistParamsIncompatible": "Параметры вложенного списка не поддерживаются в Python 3.x",
        "superCallArgCount": "Ожидается не более двух аргументов для вызова \"super\"",
        "superCallFirstArg": "В качестве первого аргумента для вызова \"super\" ожидался тип класса, но получен \"{type}\"",
        "superCallSecondArg": "Второй аргумент для вызова \"super\" должен быть объектом или классом, производным от \"{type}\"",
        "superCallZeroArgForm": "Форма вызова \"super\" с нулевым аргументом допустима только внутри метода",
        "superCallZeroArgFormStaticMethod": "Форма вызова \"super\" с нулевым аргументом недопустима в статическом методе",
        "symbolIsPossiblyUnbound": "Элемент \"{name}\", возможно, не привязан",
        "symbolIsUnbound": "Элемент \"{name}\" не привязан",
        "symbolIsUndefined": "\"{name}\" не определено",
        "symbolOverridden": "\"{name}\" переопределяет символ с тем же именем в классе \"{className}\"",
        "ternaryNotAllowed": "Тернарное выражение не разрешено в заметке типа",
        "totalOrderingMissingMethod": "Чтобы можно было использовать total_ordering, в классе должен быть определен один из операторов: \"__lt__\", \"__le__\", \"__gt__\" или \"__ge__\"",
        "trailingCommaInFromImport": "Конечные запятые можно использовать только при заключении в скобки",
        "tryWithoutExcept": "В операторе try должно быть хотя бы одно предложение exclude или finally.",
        "tupleAssignmentMismatch": "Выражение с типом \"{type}\" не может быть назначено целевому кортежу",
        "tupleInAnnotation": "Выражение кортежа не разрешено в заметке с типом",
        "tupleIndexOutOfRange": "Индекс {index} выходит за пределы допустимого диапазона для типа {type}",
        "typeAliasIllegalExpressionForm": "Недопустимая форма выражения для определения псевдонима типа",
        "typeAliasIsRecursiveDirect": "Псевдоним типа \"{name}\" не может использовать себя в своем определении",
        "typeAliasNotInModuleOrClass": "TypeAlias можно определить только внутри области модуля или класса",
        "typeAliasRedeclared": "\"{name}\" объявлен как TypeAlias и может быть присвоен только один раз",
        "typeAliasStatementBadScope": "Утверждение типа можно использовать только внутри области модуля или класса",
        "typeAliasStatementIllegal": "Оператор псевдонима типа можно использовать в Python версии не ниже 3.12",
        "typeAliasTypeBaseClass": "Псевдоним типа, определяемый в операторе \"type\", не может использоваться в качестве базового класса.",
        "typeAliasTypeMustBeAssigned": "TypeAliasType должен быть назначен переменной с тем же именем, что и псевдоним типа",
        "typeAliasTypeNameArg": "Первый аргумент TypeAliasType должен быть строковым литералом, представляющим имя псевдонима типа",
        "typeAliasTypeNameMismatch": "Имя псевдонима типа должно соответствовать имени переменной, которой оно назначено",
        "typeAliasTypeParamInvalid": "Список параметров типа должен быть кортежем, содержащим только TypeVar, TypeVarTuple или ParamSpec",
        "typeAnnotationCall": "Выражение вызова не разрешено в выражении типа",
        "typeAnnotationVariable": "Переменная не разрешена в выражении типа",
        "typeAnnotationWithCallable": "Аргумент типа для \"type\" должен быть классом. Вызываемые объекты не поддерживаются",
        "typeArgListExpected": "Ожидается ParamSpec, многоточие или список типов",
        "typeArgListNotAllowed": "Выражение списка не разрешено для аргумента этого типа",
        "typeArgsExpectingNone": "Для класса \"{name}\" не ожидается аргументов типа",
        "typeArgsMismatchOne": "Ожидается один аргумент типа, но получено {received}",
        "typeArgsMissingForAlias": "Для псевдонима универсального типа \"{name}\" ожидаются аргументы типа",
        "typeArgsMissingForClass": "Ожидаются аргументы типа для универсального класса \"{name}\"",
        "typeArgsTooFew": "Указано слишком мало аргументов типа для \"{name}\"; ожидалось {expected}, но получено {received}",
        "typeArgsTooMany": "Для \"{name}\" предоставлено слишком много аргументов типа. Ожидается {expected}, но получено {received}",
        "typeAssignmentMismatch": "Выражение типа \"{sourceType}\" несовместимо с объявленным типом \"{destType}\"",
        "typeAssignmentMismatchWildcard": "Символ импорта \"{name}\" имеет тип \"{sourceType}\", который несовместим с объявленным типом \"{destType}\"",
        "typeCallNotAllowed": "Вызов type() не разрешен в заметках типа",
        "typeCheckOnly": "\"{name}\" помечено как @type_check_only и может использоваться только в заметках с типом",
        "typeCommentDeprecated": "Комментарии типа больше не рекомендуются к использованию; вместо них используйте заметки типа",
        "typeExpectedClass": "Ожидалось выражение типа, но получено \"{type}\"",
        "typeGuardArgCount": "После \"TypeGuard\" или \"TypeIs\" ожидается один аргумент типа",
        "typeGuardParamCount": "Определяемые пользователем функции и методы защиты типов должны иметь по крайней мере один входной параметр",
        "typeIsReturnType": "Тип возвращаемого значения TypeIs (\"{returnType}\") не соответствует типу параметра значения (\"{type}\")",
        "typeNotAwaitable": "\"{type}\" не является ожидаемым",
        "typeNotIntantiable": "Не удается создать экземпляр \"{type}\"",
        "typeNotIterable": "\"{type}\" не является итерируемым",
        "typeNotSpecializable": "Не удалось специализировать тип \"{type}\"",
        "typeNotSubscriptable": "Объект типа \"{type}\" не поддерживает операцию получения подстроки",
        "typeNotSupportBinaryOperator": "Оператор \"{operator}\" не поддерживается для типов \"{leftType}\" и \"{rightType}\"",
        "typeNotSupportBinaryOperatorBidirectional": "Оператор \"{operator}\" не поддерживается для типов \"{leftType}\" и \"{rightType}\", если ожидаемый тип является \"{expectedType}\"",
        "typeNotSupportUnaryOperator": "Оператор \"{operator}\" не поддерживается для типа \"{type}\"",
        "typeNotSupportUnaryOperatorBidirectional": "Оператор \"{operator}\" не поддерживается для типа \"{type}\", если ожидается тип \"{expectedType}\"",
        "typeNotUsableWith": "Объект типа \"{type}\" нельзя использовать с ключевым словом \"with\", так как он не реализует метод {method}",
        "typeParameterBoundNotAllowed": "Привязку или ограничение нельзя использовать с параметром типа variadic или ParamSpec",
        "typeParameterConstraintTuple": "Ограничение параметра типа должно быть кортежем двух или более типов",
        "typeParameterExistingTypeParameter": "Параметр типа \"{name}\" уже используется",
        "typeParameterNotDeclared": "Параметр типа \"{name}\" не включен в список параметров типа для контейнера \"{container}\"",
        "typeParametersMissing": "Необходимо указать хотя бы один параметр типа",
        "typePartiallyUnknown": "Тип \"{name}\" частично неизвестен",
        "typeUnknown": "Тип \"{name}\" неизвестен",
        "typeVarAssignedName": "TypeVar необходимо присвоить переменной с именем \"{name}\"",
        "typeVarAssignmentMismatch": "Тип \"{type}\" не может быть присвоен переменной типа \"{name}\"",
        "typeVarBoundAndConstrained": "TypeVar не может быть одновременно привязанным и ограниченным",
        "typeVarBoundGeneric": "Тип привязки TypeVar не может быть универсальным",
        "typeVarConstraintGeneric": "Тип ограничения TypeVar не может быть универсальным",
        "typeVarDefaultBoundMismatch": "Тип по умолчанию TypeVar должен быть подтипом привязанного типа",
        "typeVarDefaultConstraintMismatch": "Тип по умолчанию TypeVar должен быть одним из ограниченных типов",
        "typeVarDefaultIllegal": "Для типов переменных по умолчанию требуется версия Python 3.13 или более новая",
        "typeVarDefaultInvalidTypeVar": "Параметр типа \"{name}\" имеет тип по умолчанию, который ссылается на одну или несколько переменных типа, находящихся вне области",
        "typeVarFirstArg": "В качестве первого аргумента ожидалось имя TypeVar",
        "typeVarNoMember": "У TypeVar \"{type}\" нет атрибута \"{name}\"",
        "typeVarNotSubscriptable": "Невозможно взять подстроку от \"{type}\" TypeVar",
        "typeVarNotUsedByOuterScope": "Переменная типа \"{name}\" не имеет смысла в этом контексте",
        "typeVarPossiblyUnsolvable": "Переменная типа \"{name}\" может остаться нерешенной, если вызывающая сторона не указывает аргумент для параметра \"{param}\"",
        "typeVarSingleConstraint": "TypeVar должен иметь не менее двух ограниченных типов",
        "typeVarTupleConstraints": "TypeVarTuple не может использовать ограничения значений",
        "typeVarTupleContext": "TypeVarTuple не допускается в этом контексте",
        "typeVarTupleDefaultNotUnpacked": "Тип по умолчанию TypeVarTuple должен быть распакованным кортежем или TypeVarTuple.",
        "typeVarTupleMustBeUnpacked": "Для значения TypeVarTuple требуется оператор распаковки",
        "typeVarTupleUnknownParam": "\"{name}\" является неизвестным параметром для TypeVarTuple",
        "typeVarUnknownParam": "\"{name}\" является неизвестным параметром для TypeVar",
        "typeVarUsedByOuterScope": "TypeVar \"{name}\" уже используется внешней областью",
        "typeVarUsedOnlyOnce": "TypeVar \"{name}\" появляется в сигнатуре универсальной функции только один раз",
        "typeVarVariance": "TypeVar не может быть одновременно ковариантным и контравариантным",
        "typeVarWithDefaultFollowsVariadic": "TypeVar \"{typeVarName}\" имеет значение по умолчанию и не может следовать за typeVarTuple \"{variadicName}\"",
        "typeVarWithoutDefault": "\"{name}\" не может появиться после \"{other}\" в списке параметров типа, так как у него нет типа по умолчанию",
        "typeVarsNotInGenericOrProtocol": "Generic[] и Protocol[] должны включать все переменные типа",
        "typedDictAccess": "Не удалось получить доступ к элементу в TypedDict",
        "typedDictAssignedName": "TypedDict необходимо присвоить переменной с именем \"{name}\"",
        "typedDictBadVar": "Классы TypedDict могут содержать только заметки с типом",
        "typedDictBaseClass": "Все базовые классы для классов TypedDict также должны быть классами TypedDict",
        "typedDictBoolParam": "От параметра \"{name}\" ожидается значение True или False",
        "typedDictClosedExtras": "Базовый класс \"{name}\" представляет собой закрытый TypedDict; дополнительные элементы должны иметь тип \"{type}\"",
        "typedDictClosedNoExtras": "Базовый класс \"{name}\" представляет собой закрытый TypedDict; дополнительные элементы не разрешены",
        "typedDictDelete": "Не удалось удалить элемент в TypedDict",
        "typedDictEmptyName": "Имена в TypedDict не могут быть пустыми",
        "typedDictEntryName": "Для имени записи словаря ожидается строковый литерал",
        "typedDictEntryUnique": "Имена в словаре должны быть уникальными",
        "typedDictExtraArgs": "Дополнительные аргументы TypedDict не поддерживаются",
        "typedDictFieldNotRequiredRedefinition": "Элемент TypedDict \"{name}\" нельзя переопределить как необязательный",
        "typedDictFieldReadOnlyRedefinition": "Элемент TypedDict \"{name}\" нельзя переопределить как доступный только для чтения",
        "typedDictFieldRequiredRedefinition": "Элемент TypedDict \"{name}\" нельзя переопределить как обязательный",
        "typedDictFirstArg": "В качестве первого аргумента ожидается имя класса TypedDict",
        "typedDictInitsubclassParameter": "TypedDict не поддерживает параметр __init_subclass__ \"{name}\"",
        "typedDictNotAllowed": "Невозможно использовать \"TypedDict\" в этом контексте",
        "typedDictSecondArgDict": "В качестве второго параметра ожидается словарь или ключевое слово",
        "typedDictSecondArgDictEntry": "Ожидается простая запись словаря",
        "typedDictSet": "Не удалось назначить элемент в TypedDict",
        "unaccessedClass": "Нет доступа к классу \"{name}\"",
        "unaccessedFunction": "Доступ к функции \"{name}\" не производится",
        "unaccessedImport": "Доступ к импорту \"{name}\" не производится",
        "unaccessedSymbol": "Доступ к \"{name}\" не осуществляется",
        "unaccessedVariable": "Доступ к переменной \"{name}\" не производится",
        "unannotatedFunctionSkipped": "Анализ функции \"{name}\" пропущен, так как она не аннотирована.",
        "unaryOperationNotAllowed": "Унарный оператор нельзя использовать в заметке типа",
        "unexpectedAsyncToken": "После \"async\" ожидается \"def\", \"with\" или \"for\"",
        "unexpectedExprToken": "Непредвиденный токен в конце выражения",
        "unexpectedIndent": "Непредвиденный отступ",
        "unexpectedUnindent": "Отступ не ожидается",
        "unhashableDictKey": "Ключ словаря должен быть хэшируемым",
        "unhashableSetEntry": "Запись набора должна быть хэшируемой",
        "uninitializedAbstractVariables": "Переменные, определенные в абстрактном базовом классе, не инициализированы в окончательном классе \"{classType}\"",
        "uninitializedInstanceVariable": "Переменная экземпляра \"{name}\" не инициализирована ни в тексте класса, ни в методе __init__",
        "unionForwardReferenceNotAllowed": "Синтаксис объединения не может использоваться со строковым операндом; заключите всё выражение в кавычки",
        "unionSyntaxIllegal": "Альтернативный синтаксис объединений можно использовать в версии Python не ниже 3.10",
        "unionTypeArgCount": "Для объединения требуется два или более аргумента типа",
        "unionUnpackedTuple": "Объединение не может включать распакованный кортеж",
        "unionUnpackedTypeVarTuple": "Объединение не может включать распакованный TypeVarTuple",
        "unnecessaryCast": "Ненужный вызов \"cast\"; тип уже является \"{type}\"",
        "unnecessaryIsInstanceAlways": "Ненужный вызов isinstance; \"{testType}\" всегда является экземпляром \"{classType}\"",
        "unnecessaryIsSubclassAlways": "Ненужный вызов issubclass. \"{testType}\" всегда является подклассом \"{classType}\"",
        "unnecessaryPyrightIgnore": "Ненужный комментарий \"# pyright: ignore\"",
        "unnecessaryPyrightIgnoreRule": "Ненужное правило \"# pyright: ignore\": \"{name}\"",
        "unnecessaryTypeIgnore": "Ненужный комментарий \"# type: ignore\"",
        "unpackArgCount": "Ожидается один аргумент типа после \"Unpack\"",
        "unpackExpectedTypeVarTuple": "В качестве аргумента типа для распаковки ожидается элемент TypeVarTuple или кортеж",
        "unpackExpectedTypedDict": "Ожидается аргумент типа TypedDict для распаковки",
        "unpackIllegalInComprehension": "Операция распаковки в понимании не разрешена",
        "unpackInAnnotation": "Оператор распаковки нельзя использовать в заметке типа",
        "unpackInDict": "Операция распаковки в словарях не разрешена",
        "unpackInSet": "Оператор распаковки не разрешен в наборе",
        "unpackNotAllowed": "Распаковка допускается в этом контексте",
        "unpackOperatorNotAllowed": "Операция распаковки допускается в этом контексте",
        "unpackTuplesIllegal": "Операцию распаковки в кортежах можно использовать в Python версии не ниже 3.8",
        "unpackedArgInTypeArgument": "В этом контексте нельзя использовать распакованные аргументы",
        "unpackedArgWithVariadicParam": "Невозможно использовать распакованный аргумент для параметра TypeVarTuple",
        "unpackedDictArgumentNotMapping": "Выражение аргумента после ** должно быть сопоставлением с типом ключа \"str\".",
        "unpackedDictSubscriptIllegal": "Оператор распаковки словаря не допускается внутри операции взятия подстроки",
        "unpackedSubscriptIllegal": "Оператор распаковки в операции взятия подстроки можно использовать в Python версии не ниже 3.11",
        "unpackedTypeVarTupleExpected": "Ожидается распакованный TypeVarTuple; используйте Unpack[{name1}] или *{name2}",
        "unpackedTypedDictArgument": "Не удалось сопоставить распакованный аргумент TypedDict с параметрами",
        "unreachableCode": "Код недоступен",
        "unreachableExcept": "Предложение Except недоступно, так как исключение уже обработано",
        "unsupportedDunderAllOperation": "Операция на \"__all__\" не поддерживается, поэтому список экспортируемых символов может быть неправильным",
        "unusedCallResult": "Результат выражения вызова принадлежит к типу \"{type}\" и не используется. Назначьте переменной \"_\", если это сделано намеренно",
        "unusedCoroutine": "Результат вызова асинхронной функции не используется; добавьте ключевое слово \"await\" или присвойте результат переменной",
        "unusedExpression": "Значение выражения не используется",
        "varAnnotationIllegal": "Заметки типа для переменных можно использовать в Python версии не ниже 3.6. Для совместимости с более ранними версиями используйте комментарий к типу.",
        "variableFinalOverride": "Переменная \"{name}\" помечена как Final и переопределяет неокончательную переменную с тем же именем в классе \"{className}\"",
        "variadicTypeArgsTooMany": "Список аргументов типа может содержать не более одного распакованного элемента TypeVarTuple или кортежа",
        "variadicTypeParamTooManyAlias": "Псевдоним типа может иметь не более одного параметра типа TypeVarTuple, но получил несколько ({names})",
        "variadicTypeParamTooManyClass": "Универсальный класс может иметь не более одного параметра типа TypeVarTuple, но получил несколько ({names})",
        "walrusIllegal": "Оператор \":=\" может использоваться в Python версии не ниже 3.8",
        "walrusNotAllowed": "Оператор \":=\" не допускается в этом контексте без окружающих круглых скобок",
        "wildcardInFunction": "Импорт с подстановочными знаками в классе или функции запрещен",
        "wildcardLibraryImport": "Импорт подстановочных знаков из библиотеки запрещен",
        "wildcardPatternTypePartiallyUnknown": "Тип, захваченный шаблоном подстановки, частично неизвестен",
        "wildcardPatternTypeUnknown": "Тип, захваченный шаблоном подстановки, неизвестен",
        "yieldFromIllegal": "\"Yield from\" можно использовать в Python версии не ниже 3.3",
        "yieldFromOutsideAsync": "\"yield from\" не допускается в асинхронной функции",
        "yieldOutsideFunction": "\"yield\" не допускается за пределами функции или лямбда-выражении",
        "yieldWithinListCompr": "\"yield\" не допускается внутри понимания списка",
        "zeroCaseStatementsFound": "Операторе match должен включать по крайней мере один оператор case",
        "zeroLengthTupleNotAllowed": "Кортеж нулевой длины не допускается в этом контексте"
    },
    "DiagnosticAddendum": {
        "annotatedNotAllowed": "Специальную форму \"С заметками\" нельзя использовать с проверками экземпляра и класса",
        "argParam": "Аргумент соответствует параметру \"{paramName}\"",
        "argParamFunction": "Аргумент соответствует параметру \"{paramName}\" функции \"{functionName}\"",
        "argsParamMissing": "У параметра \"*{paramName}\" нет соответствующего параметра",
        "argsPositionOnly": "Несоответствие параметров только положения. Ожидается {expected}, но получено {received}",
        "argumentType": "Аргумент принадлежит к типу \"{type}\"",
        "argumentTypes": "Типы аргументов: ({types})",
        "assignToNone": "Тип несовместим с \"None\"",
        "asyncHelp": "Вы имели в виду \"async with\"?",
        "baseClassIncompatible": "Базовый класс \"{baseClass}\" несовместим с типом \"{type}\"",
        "baseClassIncompatibleSubclass": "Базовый класс \"{baseClass}\" является производным от \"{subclass}\", который несовместим с типом \"{type}\"",
        "baseClassOverriddenType": "Базовый класс \"{baseClass}\" предоставляет тип \"{type}\", который переопределен",
        "baseClassOverridesType": "Базовый класс \"{baseClass}\" переопределяет тип \"{type}\"",
        "bytesTypePromotions": "Установите для параметра DisableBytesTypePromotions значение ЛОЖЬ, чтобы включить повышение типа для \"bytearray\" и \"memoryview\"",
        "conditionalRequiresBool": "Метод __bool__ для типа \"{operandType}\" возвращает тип \"{boolReturnType}\", а не \"bool\"",
        "dataClassFieldLocation": "Объявление поля",
        "dataClassFrozen": "Элемент \"{name}\" зафиксирован",
        "dataProtocolUnsupported": "\"{name}\" является протоколом данных",
        "descriptorAccessBindingFailed": "Не удалось привязать метод \"{name}\" для класса дескриптора \"{className}\"",
        "descriptorAccessCallFailed": "Не удалось вызвать метод \"{name}\" для класса дескриптора \"{className}\"",
        "finalMethod": "Окончательный метод",
        "functionParamDefaultMissing": "В параметре \"{name}\" отсутствует аргумент по умолчанию.",
        "functionParamName": "Несоответствие имени параметра: \"{destName}\" и \"{srcName}\"",
        "functionParamPositionOnly": "Несоответствие исключительно позиционных параметров; параметр \"{name}\" не является исключительно позиционным",
        "functionReturnTypeMismatch": "Тип возвращаемого значения функции \"{sourceType}\" несовместим с типом \"{destType}\"",
        "functionTooFewParams": "Функция принимает слишком мало позиционных параметров; ожидалось {expected}, но получено {received}",
        "functionTooManyParams": "Функция принимает слишком много позиционных параметров; ожидалось {expected}, но получено {received}",
        "genericClassNotAllowed": "Универсальный тип с аргументами типа запрещен для проверок экземпляров или классов",
        "incompatibleDeleter": "Метод удаления свойства является несовместимым",
        "incompatibleGetter": "Несовместимый метод получения свойств",
        "incompatibleSetter": "Метод задания свойства является несовместимым",
        "initMethodLocation": "Метод __init__ определен в классе \"{type}\"",
        "initMethodSignature": "Сигнатура __init__ — \"{type}\"",
        "initSubclassLocation": "Метод __init_subclass__ определен в классе \"{name}\"",
        "invariantSuggestionDict": "Рассмотрите возможность перехода с \"dict\" на \"Mapping\", являющийся ковариантным по типу значения.",
        "invariantSuggestionList": "Рассмотрите возможность перехода с \"list\" на \"Sequence\", являющийся ковариантным.",
        "invariantSuggestionSet": "Рассмотрите возможность переключения с \"set\" на \"Container\", который является ковариантным",
        "keyNotRequired": "\"{name}\" не является обязательным ключом в \"{type}\", поэтому доступ может вызвать исключение во время выполнения",
        "keyReadOnly": "\"{name}\" является ключом только для чтения в \"{type}\"",
        "keyRequiredDeleted": "\"{name}\" является обязательным ключом и не подлежит удалению",
        "keyUndefined": "\"{name}\" не является определенным ключом в \"{type}\"",
        "kwargsParamMissing": "У параметра \"**{paramName}\" нет соответствующего параметра",
        "listAssignmentMismatch": "Тип \"{type}\" несовместим с целевым списком",
        "literalAssignmentMismatch": "\"{sourceType}\" несовместим с типом \"{destType}\"",
        "matchIsNotExhaustiveHint": "Если не предполагается исчерпывающая обработка, добавьте \"case _: pass\"",
        "matchIsNotExhaustiveType": "Тип \"{type}\" не обрабатывается",
        "memberAssignment": "Выражение типа \"{type}\" не может быть назначено атрибуту \"{name}\" класса \"{classType}\"",
        "memberIsAbstract": "Отсутствует реализация \"{type}.{name}\".",
        "memberIsAbstractMore": "и еще {{count}}",
        "memberIsClassVarInProtocol": "\"{name}\" определено как класс ClassVar в протоколе",
        "memberIsFinalInProtocol": "\"{name}\" помечено в протоколе как Final",
        "memberIsInitVar": "\"{name}\" является полем только для инициализации",
        "memberIsInvariant": "Элемент \"{name}\" инвариантен, поскольку помечен как mutable",
        "memberIsNotClassVarInClass": "Необходимо определить \"{name}\" как ClassVar для совместимости с протоколом.",
        "memberIsNotClassVarInProtocol": "\"{name}\" не определено как класс ClassVar в протоколе",
        "memberIsNotFinalInProtocol": "\"{name}\" не помечен как окончательный в протоколе",
        "memberIsWritableInProtocol": "\"{name}\" доступно для записи в протоколе",
        "memberSetClassVar": "Атрибут \"{name}\" не может быть назначен через экземпляр класса, так как это ClassVar",
        "memberTypeMismatch": "\"{name}\" является несовместимым типом",
        "memberUnknown": "Атрибут \"{name}\" неизвестен",
        "metaclassConflict": "Метакласс \"{metaclass1}\" конфликтует с \"{metaclass2}\"",
        "missingDeleter": "Отсутствует метод удаления свойства",
        "missingGetter": "Отсутствует метод получения свойства",
        "missingSetter": "Отсутствует метод установки свойств",
        "namedParamMissingInDest": "В целевом объекте отсутствует параметр ключевого слова \"{name}\"",
        "namedParamMissingInSource": "В источнике нет параметра ключевого слова \"{name}\"",
        "namedParamTypeMismatch": "Параметр ключевого слова \"{name}\" типа \"{sourceType}\" несовместим с типом \"{destType}\"",
        "namedTupleNotAllowed": "NamedTuple не может использоваться для проверок экземпляров или классов",
        "newMethodLocation": "Метод __new__ определен в классе \"{type}\"",
        "newMethodSignature": "Сигнатура метода __new__ требует \"{type}\"",
        "newTypeClassNotAllowed": "Класс, созданный с NewType, нельзя использовать с проверками экземпляров и классов",
        "noOverloadAssignable": "Нет перегруженной функции, соответствующей типу \"{type}\"",
        "noneNotAllowed": "Их невозможно использовать для проверок экземпляров или классов",
        "orPatternMissingName": "Отсутствуют имена: {name}",
        "overloadIndex": "Наилучшее совпадение: {index} перегрузки",
        "overloadNotAssignable": "Одна или несколько перегрузок \"{name}\" не подлежат присвоению",
        "overloadSignature": "Здесь определена сигнатура перегрузки",
        "overriddenMethod": "Переопределенный метод",
        "overriddenSymbol": "Переопределенный символ",
        "overrideInvariantMismatch": "Тип переопределения \"{overrideType}\" не совпадает с базовым типом \"{baseType}\"",
        "overrideIsInvariant": "Переменная изменяема, поэтому ее тип является инвариантным",
        "overrideNoOverloadMatches": "В переопределении нет сигнатуры перегрузки, совместимой с базовым методом",
        "overrideNotClassMethod": "Базовый метод объявлен как classmethod, а его переопределение — нет",
        "overrideNotInstanceMethod": "Базовый метод объявлен как метод экземпляра, а его переопределение — нет",
        "overrideNotStaticMethod": "Базовый метод объявлен как статический, а его переопределение — нет",
        "overrideOverloadNoMatch": "Переопределение не обрабатывает все перегрузки базового метода",
        "overrideOverloadOrder": "Перегрузки в методе переопределения должны располагаться в том же порядке, что и в базовом методе",
        "overrideParamKeywordNoDefault": "Несоответствие параметра ключевого слова \"{name}\": базовый параметр содержит значение аргумента по умолчанию, параметр переопределения — нет",
        "overrideParamKeywordType": "Несоответствие типа параметра ключевого слова \"{name}\": базовый параметр имеет тип \"{baseType}\", параметр переопределения имеет тип \"{overrideType}\"",
        "overrideParamName": "Несоответствие имени параметра {index}: базовый параметр называется \"{baseName}\", параметр переопределения называется \"{overrideName}\"",
        "overrideParamNameExtra": "Параметр \"{name}\" отсутствует в базовом классе",
        "overrideParamNameMissing": "Параметр \"{name}\" отсутствует в переопределении",
        "overrideParamNamePositionOnly": "Несоответствие параметра {index}: базовый параметр \"{baseName}\" является параметром ключевого слова, параметр переопределения предназначен только для позиции",
        "overrideParamNoDefault": "Несоответствие параметра {index}: базовый параметр содержит значение аргумента по умолчанию, параметр переопределения — нет",
        "overrideParamType": "Несоответствие типа параметра {index}: базовый параметр имеет тип \"{baseType}\", параметр переопределения имеет тип \"{overrideType}\"",
        "overridePositionalParamCount": "Несоответствие позиционного подсчета параметров. Базовый метод содержит {baseCount}, но переопределение содержит {overrideCount}",
        "overrideReturnType": "Несоответствие типа возвращаемого значения: базовый метод возвращает тип \"{baseType}\", а переопределение — \"{overrideType}\"",
        "overrideType": "Базовый класс определяет тип как \"{type}\"",
        "paramAssignment": "Параметр {index}: типа \"{sourceType}\" несовместим с типом \"{destType}\"",
        "paramSpecMissingInOverride": "В методе переопределения отсутствуют параметры ParamSpec.",
        "paramType": "Параметр принадлежит к типу \"{paramType}\"",
        "privateImportFromPyTypedSource": "Вместо этого используйте импорт из \"{module}\"",
        "propertyAccessFromProtocolClass": "Свойство, определенное в классе протокола, не может быть доступно как переменная класса.",
        "propertyMethodIncompatible": "Метод свойства \"{name}\" несовместим",
        "propertyMethodMissing": "Метод свойства \"{name}\" отсутствует в переопределении",
        "propertyMissingDeleter": "Для свойства \"{name}\" не определен метод удаления",
        "propertyMissingSetter": "Для свойства \"{name}\" не определен метод задания",
        "protocolIncompatible": "\"{sourceType}\" несовместим с протоколом \"{destType}\"",
        "protocolMemberMissing": "\"{name}\" отсутствует.",
        "protocolRequiresRuntimeCheckable": "Класс протокола должен быть @runtime_checkable, чтобы его можно было использовать при проверках экземпляров и классов",
        "protocolSourceIsNotConcrete": "\"{sourceType}\" не является конкретным типом класса и не может быть присвоен типу \"{destType}\"",
        "protocolUnsafeOverlap": "Атрибуты \"{name}\" используют те же имена, что и протокол",
        "pyrightCommentIgnoreTip": "Для подавления диагностики в одной строке используйте конструкцию \"# pyright: ignore[<правила диагностики>]",
        "readOnlyAttribute": "Атрибут \"{name}\" доступен только для чтения",
        "seeClassDeclaration": "См. объявление класса",
        "seeDeclaration": "См. объявление",
        "seeFunctionDeclaration": "См. объявление функции",
        "seeMethodDeclaration": "См. объявление метода",
        "seeParameterDeclaration": "Просмотреть объявление параметра",
        "seeTypeAliasDeclaration": "Просмотреть объявление псевдонима типа",
        "seeVariableDeclaration": "Просмотреть объявление переменной",
        "tupleAssignmentMismatch": "Тип \"{type}\" несовместим с целевым кортежем",
        "tupleEntryTypeMismatch": "Запись кортежа {entry} имеет неверный тип",
        "tupleSizeIndeterminateSrc": "Несоответствие размеров кортежа: ожидается \"{expected}\", но получено неопределенное значение",
        "tupleSizeIndeterminateSrcDest": "Несоответствие размеров кортежа: ожидается {expected} или больше, но получено неопределенное значение",
        "tupleSizeMismatch": "Несоответствие размеров кортежа: ожидается \"{expected}\", но получено \"{received}\"",
        "tupleSizeMismatchIndeterminateDest": "Несоответствие размеров кортежа: ожидается {expected} или больше, но получено {received}",
        "typeAliasInstanceCheck": "Псевдоним типа, создаваемый оператором \"type\", не может использоваться с проверками экземпляра и класса.",
        "typeAssignmentMismatch": "Тип \"{sourceType}\" несовместим с типом \"{destType}\"",
        "typeBound": "Тип \"{sourceType}\" несовместим с привязанным типом \"{destType}\" для переменной типа \"{name}\"",
        "typeConstrainedTypeVar": "Тип \"{type}\" несовместим с переменной ограниченного типа \"{name}\"",
        "typeIncompatible": "\"{sourceType}\" несовместим с \"{destType}\"",
        "typeNotClass": "\"{type}\" не является классом.",
        "typeNotStringLiteral": "\"{type}\" не является строковым литералом",
        "typeOfSymbol": "Тип \"{name}\" является \"{type}\"",
        "typeParamSpec": "Тип \"{type}\" несовместим с ParamSpec \"{name}\"",
        "typeUnsupported": "Тип \"{type}\" не поддерживается",
        "typeVarDefaultOutOfScope": "Переменная типа \"{name}\" лежит за пределами области",
        "typeVarIsContravariant": "Параметр типа \"{name}\" является контравариантным, но \"{sourceType}\" не является супертипом \"{destType}\"",
        "typeVarIsCovariant": "Параметр типа \"{name}\" является ковариантным, но \"{sourceType}\" не является подтипом \"{destType}\"",
        "typeVarIsInvariant": "Параметр типа \"{name}\" является инвариантным, но \"{sourceType}\" не совпадает с \"{destType}\"",
        "typeVarNotAllowed": "TypeVar не допускается для проверок экземпляров или классов",
        "typeVarTupleRequiresKnownLength": "TypeVarTuple не может граничить с кортежем неизвестной длины",
        "typeVarUnnecessarySuggestion": "Вместо этого используйте {type}",
        "typeVarUnsolvableRemedy": "Укажите перегрузку, которая указывает тип возвращаемого значения, если аргумент не передается",
        "typeVarsMissing": "Отсутствуют переменные типа: {names}",
        "typedDictBaseClass": "Класс \"{type}\" не является TypedDict",
        "typedDictClassNotAllowed": "Класс TypedDict не допускается для проверок экземпляров или классов",
        "typedDictClosedExtraNotAllowed": "Не удается добавить элемент \"{name}\"",
        "typedDictClosedExtraTypeMismatch": "Не удается добавить элемент \"{name}\" типа \"{type}\"",
        "typedDictClosedFieldNotRequired": "Не удается добавить элемент \"{name}\", так как он должен быть помечен как необязательный",
        "typedDictExtraFieldNotAllowed": "Элемент \"{name}\" отсутствует в типе \"{type}\"",
        "typedDictExtraFieldTypeMismatch": "Тип элемента \"{name}\" несовместим с типом \"__extra_items__\" в \"{type}\"",
        "typedDictFieldMissing": "\"{name}\" отсутствует в \"{type}\"",
        "typedDictFieldNotReadOnly": "\"{name}\" не является элементом \"{type}\" только для чтения",
        "typedDictFieldNotRequired": "\"{name}\" не является обязательным в \"{type}\"",
        "typedDictFieldRequired": "\"{name}\" является обязательным в \"{type}\"",
        "typedDictFieldTypeMismatch": "Тип \"{type}\" нельзя присвоить полю \"{name}\"",
        "typedDictFieldUndefined": "Элемент \"{name}\" не определен в типе \"{type}\"",
        "typedDictFinalMismatch": "\"{sourceType}\" несовместим с \"{destType}\" из-за несоответствия окончательности",
        "typedDictKeyAccess": "Использовать [\"{name}\"] для ссылки на элемент в TypedDict",
        "typedDictNotAllowed": "TypedDict не может использоваться для проверок экземпляров или классов",
        "unhashableType": "Тип \"{type}\" не является хэшируемым",
        "uninitializedAbstractVariable": "Переменная экземпляра \"{name}\" определена в абстрактном базовом классе \"{classType}\", но не инициализирована",
        "unreachableExcept": "\"{exceptionType}\" является подклассом \"{parentType}\"",
        "useDictInstead": "Используйте Dict[T1, T2] для указания типа словаря",
        "useListInstead": "Используйте List[T] для указания типа списка или Union[T1, T2] для указания типа объединения",
        "useTupleInstead": "Используйте конструкцию tuple[T1, ..., Tn], чтобы указать тип кортежа, или Union[T1, T2], чтобы указать тип объединения",
        "useTypeInstead": "Используйте вместо этого Type[T]",
        "varianceMismatchForClass": "Вариант аргумента типа \"{typeVarName}\" несовместим с базовым классом \"{className}\"",
        "varianceMismatchForTypeAlias": "Отклонение аргумента типа \"{typeVarName}\" несовместимо с \"{typeAliasParam}\""
    }
}
