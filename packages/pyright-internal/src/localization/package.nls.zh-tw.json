{
    "CodeAction": {
        "createTypeStub": "建立類型 Stub",
        "createTypeStubFor": "建立 \"{moduleName}\" 的類型 Stub",
        "executingCommand": "執行命令",
        "filesToAnalyzeCount": "要分析的 {count} 個檔案",
        "filesToAnalyzeOne": "1 個要分析的檔案",
        "findingReferences": "尋找參考",
        "organizeImports": "整理匯入",
        "renameShadowedFile": "將 \"{oldFile}\" 重新命名為 \"{newFile}\""
    },
    "Completion": {
        "autoImportDetail": "自動匯入",
        "indexValueDetail": "索引值"
    },
    "Diagnostic": {
        "abstractMethodInvocation": "無法呼叫方法 \"{method}\"，因為它是抽象且未執行",
        "annotatedMetadataInconsistent": "標註的中繼資料類型 \"{metadataType}\" 與類型 \"{type}\" 不相容",
        "annotatedParamCountMismatch": "參數註釋計數不符: 應為 {expected}，但收到 {received}",
        "annotatedTypeArgMissing": "預期 \"Annotated\" 有一個類型引數和一或多個註釋",
        "annotationBytesString": "類型運算式無法使用位元組字串常值",
        "annotationFormatString": "類型運算式不能使用格式字串常值 (f-strings)",
        "annotationNotSupported": "此陳述式不支援類型註釋",
        "annotationRawString": "類型運算式無法使用原始字串常值",
        "annotationSpansStrings": "型別運算式無法跨越多個字串常值",
        "annotationStringEscape": "型別運算式不可包含逸出字元",
        "argAssignment": "類型 \"{argType}\" 的引數不能指派至類型 \"{paramType}\" 的參數",
        "argAssignmentFunction": "類型 \"{argType}\" 的引數不能指派至函式 \"{functionName}\" 中類型 \"{paramType}\" 的參數",
        "argAssignmentParam": "類型 \"{argType}\" 的引數不能指派至類型 \"{paramType}\" 的參數 \"{paramName}\"",
        "argAssignmentParamFunction": "類型 \"{argType}\" 的引數不能指派至函式 \"{functionName}\" 中類型 \"{paramType}\" 的參數 \"{paramName}\"",
        "argMissingForParam": "參數 {name} 遺漏引數",
        "argMissingForParams": "參數 {names} 的引數遺失",
        "argMorePositionalExpectedCount": "預期有另 {expected} 個位置引數",
        "argMorePositionalExpectedOne": "預期有另 1 個位置引數",
        "argPositional": "預期為位置引數",
        "argPositionalExpectedCount": "預期有 {expected} 個位置引數",
        "argPositionalExpectedOne": "預期為 1 個位置引數",
        "argTypePartiallyUnknown": "引數型別為部分未知",
        "argTypeUnknown": "引數類型未知",
        "assertAlwaysTrue": "Assert 運算式一律會評估為 true",
        "assertTypeArgs": "\"assert_type\" 需要兩個位置引數",
        "assertTypeTypeMismatch": "\"assert_type\" 不符: 預期為 \"{expected}\"，但收到 \"{received}\"",
        "assignmentExprComprehension": "指派運算式目標 \"{name}\" 不能使用與目標 Comprehension 相同的名稱",
        "assignmentExprContext": "Assignment 運算式必須在模組、函式或 Lambda 內",
        "assignmentExprInSubscript": "下標內的 Assignment 運算式僅在 Python 3.10 和更新版本中支援",
        "assignmentInProtocol": "必須在類別主體內明確宣告 Protocol 類別內的執行個體或類別變數",
        "assignmentTargetExpr": "運算式不能是指派目標",
        "asyncNotInAsyncFunction": "不允許在非 async 之外使用 \"async\"",
        "awaitIllegal": "使用 \"await\" 需要 Python 3.5 或更新版本",
        "awaitNotAllowed": "類型運算式不能使用 \"await\"",
        "awaitNotInAsync": "只在 async 函式內允許 \"await\"",
        "backticksIllegal": "Python 3.x 中不支援以反引號括住的運算式; 請改為使用 repr",
        "baseClassCircular": "類別無法從本身衍生",
        "baseClassFinal": "基底類別 \"{type}\" 標示為 final，且不能設為子類別",
        "baseClassIncompatible": "{type} 的基底類別互不相容",
        "baseClassInvalid": "類別的引數必須是基底類別",
        "baseClassMethodTypeIncompatible": "類別 \"{classType}\" 的基底類別以不相容的方式定義方法 \"{name}\"",
        "baseClassUnknown": "基底類別類型未知，遮蔽衍生類別的類型",
        "baseClassVariableTypeIncompatible": "類別 \"{classType}\" 的基底類別以不相容的方式定義變數 \"{name}\"",
        "binaryOperationNotAllowed": "類型運算式中不允許二元運算子",
        "bindTypeMismatch": "無法繫結方法 \"{methodName}\"，因為 \"{type}\" 無法指派給參數 \"{paramName}\"",
        "breakInExceptionGroup": "\"except*\" 區塊中不允許 \"break\"",
        "breakOutsideLoop": "\"break\" 只能在迴圈內使用",
        "bytesUnsupportedEscape": "bytes 常值中不支援的逸出序列",
        "callableExtraArgs": "預期 \"Callable\" 只有兩個類型引數",
        "callableFirstArg": "預期為參數類型清單或 \"...\"",
        "callableNotInstantiable": "不能具現化類型 \"{type}\"",
        "callableSecondArg": "預期為傳回類型作為 \"Callable\" 的第二個類型引數",
        "casePatternIsIrrefutable": "僅允許最後一個案例陳述式使用無法推翻的模式",
        "classAlreadySpecialized": "類型 \"{type}\" 已特殊化",
        "classDecoratorTypeUnknown": "不具型別的類別裝飾項目會掩蓋類別的型別; 略過裝飾項目",
        "classDefinitionCycle": "\"{name}\" 的類別定義視其本身而定",
        "classGetItemClsParam": "__class_getitem__ 覆寫應接受 \"cls\" 參數",
        "classMethodClsParam": "類別方法應採用 \"cls\" 參數",
        "classNotRuntimeSubscriptable": "類別 \"{name}\" 的下標會產生執行階段例外; 以引號括住類型運算式",
        "classPatternBuiltInArgPositional": "類別模式僅接受位置子模式",
        "classPatternPositionalArgCount": "類別 \"{type}\" 的位置模式太多;預期 {expected} 但收到 {received}",
        "classPatternTypeAlias": "無法在類別模式中使用 \"{type}\"，因為它是特殊的型別別名",
        "classPropertyDeprecated": "類別屬性在 Python 3.11 中已取代，在 Python 3.13 中將不受支援",
        "classTypeParametersIllegal": "類別類型參數語法需要 Python 3.12 或更新版本",
        "classVarFirstArgMissing": "\"ClassVar\" 後面應有一個型別引數",
        "classVarNotAllowed": "此內容中不允許 \"ClassVar\"",
        "classVarOverridesInstanceVar": "類別變數 \"{name}\" 會覆寫類別 \"{className}\" 中相同名稱的執行個體變數",
        "classVarTooManyArgs": "\"ClassVar\" 後面應只能有一個型別引數",
        "classVarWithTypeVar": "\"ClassVar\" 型別不能包含型別變數",
        "clsSelfParamTypeMismatch": "參數 \"{name}\" 的型別必須是其類別 \"{classType}\" 的超級型別",
        "codeTooComplexToAnalyze": "程式碼太複雜而無法分析; 重構為副常式或減少條件式程式碼路徑，以降低複雜性",
        "collectionAliasInstantiation": "無法將型別 \"{type}\" 具現化，請改用 \"{alias}\"",
        "comparisonAlwaysFalse": "條件一律會評估為 False，因為類型 \"{leftType}\" 和 \"{rightType}\" 沒有重疊",
        "comparisonAlwaysTrue": "條件一律會評估為 True，因為類型 \"{leftType}\" 和 \"{rightType}\" 沒有重疊",
        "comprehensionInDict": "Comprehension 不能與其他字典項目搭配使用",
        "comprehensionInSet": "Comprehension 無法與其他 set 輸入項目一起使用",
        "concatenateContext": "此內容中不允許 \"Concatenate\"",
        "concatenateParamSpecMissing": "\"Concatenate\" 的最後一個類型引數必須是 ParamSpec 或 \"...\"",
        "concatenateTypeArgsMissing": "\"Concatenate\" 至少需要兩個型別引數",
        "conditionalOperandInvalid": "型別 \"{type}\" 的條件運算元無效",
        "constantRedefinition": "\"{name}\" 是常數 (因為它是大寫) 且無法重新定義",
        "constructorParametersMismatch": "類別 \"{classType}\" 中__new__與__init__的簽章不相符",
        "containmentAlwaysFalse": "運算式一律會評估為 False，因為型別 \"{leftType}\" 和 \"{rightType}\" 沒有重疊",
        "containmentAlwaysTrue": "運算式一律會評估為 True，因為型別 \"{leftType}\" 和 \"{rightType}\" 沒有重疊",
        "continueInExceptionGroup": "\"except*\" 區塊中不允許 \"continue\"",
        "continueOutsideLoop": "\"continue\" 只能在 loop 內使用",
        "coroutineInConditionalExpression": "條件運算式參考協同程式，一律評估為 True",
        "dataClassBaseClassFrozen": "未凍結的類別無法繼承已凍結的類別",
        "dataClassBaseClassNotFrozen": "凍結的類別不能從未凍結的類別繼承",
        "dataClassConverterFunction": "類型 \"{argType}\" 的引數不是類型 \"{fieldType}\" 欄位 \"{fieldName}\" 的有效轉換程式",
        "dataClassConverterOverloads": "\"{funcName}\" 沒有任何多載是類型 \"{fieldType}\" 欄位 \"{fieldName}\" 的有效轉換程式",
        "dataClassFieldInheritedDefault": "\"{fieldName}\" 覆寫相同名稱的欄位，但缺少預設值",
        "dataClassFieldWithDefault": "沒有預設值的欄位無法出現在具有預設值的欄位後面",
        "dataClassFieldWithPrivateName": "Dataclass 欄位不能使用私人名稱",
        "dataClassFieldWithoutAnnotation": "沒有型別註釋的 Dataclass 欄位會造成執行階段例外狀況",
        "dataClassPostInitParamCount": "Dataclass __post_init__ 不正確的參數計數; InitVar 欄位數目為 {expected}",
        "dataClassPostInitType": "欄位 \"{fieldName}\" 的 Dataclass __post_init__ 方法參數類型不符",
        "dataClassSlotsOverwrite": "__slots__已定義在類別中",
        "dataClassTransformExpectedBoolLiteral": "應為靜態評估為 True 或 False 的運算式",
        "dataClassTransformFieldSpecifier": "應為類別或函式的 tuple，但收到的類別為 \"{type}\"",
        "dataClassTransformPositionalParam": "\"dataclass_transform\" 的所有引數都必須是關鍵字引數",
        "dataClassTransformUnknownArgument": "dataclass_transform 不支援引數 \"{name}\"",
        "dataProtocolInSubclassCheck": "issubclass 呼叫中不允許資料通訊協定 (包含非方法屬性)",
        "declaredReturnTypePartiallyUnknown": "宣告的傳回類型 \"{returnType}\" 部分未知",
        "declaredReturnTypeUnknown": "宣告的傳回類型未知",
        "defaultValueContainsCall": "參數預設值運算式內不允許函式呼叫和可變物件",
        "defaultValueNotAllowed": "具有 \"*\" 或 \"**\" 的參數不能有預設值",
        "delTargetExpr": "無法刪除運算式",
        "deprecatedClass": "類別 \"{name}\" 已淘汰",
        "deprecatedConstructor": "類別 \"{name}\" 的建構函式已取代",
        "deprecatedDescriptorDeleter": "描述項 \"{name}\" 的 \"__delete__\" 方法已被取代",
        "deprecatedDescriptorGetter": "描述項 \"{name}\" 的 \"__get__\" 方法已被取代",
        "deprecatedDescriptorSetter": "描述項 \"{name}\" 的 \"__set__\" 方法已被取代",
        "deprecatedFunction": "函式 \"{name}\" 已取代",
        "deprecatedMethod": "類別 \"{className}\" 中的方法 \"{name}\" 已取代",
        "deprecatedPropertyDeleter": "The deleter for property \"{name}\" is deprecated",
        "deprecatedPropertyGetter": "The getter for property \"{name}\" is deprecated",
        "deprecatedPropertySetter": "The setter for property \"{name}\" is deprecated",
        "deprecatedType": "此類型已隨著 Python {version} 取代; 請改為使用 \"{replacement}\"",
        "dictExpandIllegalInComprehension": "Comprehension 中不允許字典擴充",
        "dictInAnnotation": "類型運算式中不允許字典運算式",
        "dictKeyValuePairs": "字典項目必須包含金鑰/值組",
        "dictUnpackIsNotMapping": "預期為字典解壓縮運算子的對應",
        "dunderAllSymbolNotPresent": "\"{name}\" 已在 __all__ 中指定，但在模組中不存在",
        "duplicateArgsParam": "只允許一個 \"*\" 參數",
        "duplicateBaseClass": "不允許重複的基底類別",
        "duplicateCapturePatternTarget": "擷取目標 \"{name}\" 不能在相同模式中出現一次以上",
        "duplicateCatchAll": "只允許一個 catch-all except 子句",
        "duplicateEnumMember": "已宣告 Enum 成員 \"{name}\"",
        "duplicateGenericAndProtocolBase": "只允許一個 Generic[...] 或 Protocol[...] 基底類別",
        "duplicateImport": "\"{importName}\" 已匯入多次",
        "duplicateKeywordOnly": "只允許一個 \"*\" 分隔符號",
        "duplicateKwargsParam": "只允許一個 \"**\" 參數",
        "duplicateParam": "重複的參數 \"{name}\"",
        "duplicatePositionOnly": "僅允許一個 \"/\" 參數",
        "duplicateStarPattern": "模式序列中僅允許一個 \"*\" 模式",
        "duplicateStarStarPattern": "僅允許輸入一個 \"**\"",
        "duplicateUnpack": "list 中僅允許一個解除封裝作業",
        "ellipsisAfterUnpacked": "\"...\" 不能與解壓縮的 TypeVarTuple 或 tuple 一起使用",
        "ellipsisContext": "此內容中不允許 \"...\"",
        "ellipsisSecondArg": "\"...\" 只允許做為兩個引數的第二個",
        "enumClassOverride": "Enum 類別 \"{name}\" 為 final，且不能設為子類別",
        "enumMemberDelete": "Enum member \"{name}\" cannot be deleted",
        "enumMemberSet": "Enum member \"{name}\" cannot be assigned",
        "enumMemberTypeAnnotation": "Type annotations are not allowed for enum members",
        "exceptGroupMismatch": "Try 陳述式不能同時包含 \"except\" 與 “except*”",
        "exceptGroupRequiresType": "例外狀況群組語法 (\"except*\") 需要例外狀況類型",
        "exceptionGroupIncompatible": "例外群組語法 (\"except*\") 需要 Python 3.11 或更新版本",
        "exceptionGroupTypeIncorrect": "except* 中的例外狀況類型不能衍生自 BaseGroupException",
        "exceptionTypeIncorrect": "\"{type}\" 不是衍生自 BaseException",
        "exceptionTypeNotClass": "\"{type}\" 不是有效的例外類別",
        "exceptionTypeNotInstantiable": "例外類型 \"{type}\" 的建構函式需要一或多個引數",
        "expectedAfterDecorator": "裝飾項目後面應有函式或類別宣告",
        "expectedArrow": "預期為 \"->\"，後面接著傳回類型註釋",
        "expectedAsAfterException": "例外狀況型別後面應有 \"as\"",
        "expectedAssignRightHandExpr": "\"=\" 右側預期為運算式",
        "expectedBinaryRightHandExpr": "運算子右側預期為運算式",
        "expectedBoolLiteral": "應為 True 或 False",
        "expectedCase": "預期為 \"case\" 陳述式",
        "expectedClassName": "預期為類別名稱",
        "expectedCloseBrace": "\"{\" 未關閉",
        "expectedCloseBracket": "\"[\" 未關閉",
        "expectedCloseParen": "\"(\" 未關閉",
        "expectedColon": "預期為 \":\"",
        "expectedComplexNumberLiteral": "模式比對預期為複數常值",
        "expectedDecoratorExpr": "Python 3.9 之前的裝飾項目不支援運算式格式",
        "expectedDecoratorName": "預期為裝飾項目名稱",
        "expectedDecoratorNewline": "預期裝飾項目結尾為換行符號",
        "expectedDelExpr": "\"del\" 後預期為運算式",
        "expectedElse": "預期為 \"else\"",
        "expectedEquals": "預期為 \"=\"",
        "expectedExceptionClass": "不正確的例外狀況類別或物件",
        "expectedExceptionObj": "預期為例外物件、例外類別或 None",
        "expectedExpr": "應為運算式",
        "expectedFunctionAfterAsync": "\"async\" 後面應有函式定義",
        "expectedFunctionName": "\"def\" 後預期為函式名稱",
        "expectedIdentifier": "應為識別碼",
        "expectedImport": "預期為 \"import\"",
        "expectedImportAlias": "\"as\" 之後預期為符號",
        "expectedImportSymbols": "預期 \"import\" 後為一或多個符號名稱",
        "expectedIn": "預期為 \"in\"",
        "expectedInExpr": "\"in\" 後預期為運算式",
        "expectedIndentedBlock": "預期為縮排區塊",
        "expectedMemberName": "\".\" 後面應該接著屬性名稱。",
        "expectedModuleName": "應為模組名稱",
        "expectedNameAfterAs": "\"as\" 後面應有符號名稱",
        "expectedNamedParameter": "關鍵字參數必須接著 \"*\"",
        "expectedNewline": "預期為換行符號",
        "expectedNewlineOrSemicolon": "陳述式必須以換行符號或分號分隔",
        "expectedOpenParen": "應為 \"(\"",
        "expectedParamName": "預期為參數名稱",
        "expectedPatternExpr": "預期為模式運算式",
        "expectedPatternSubjectExpr": "應為模式主體運算式",
        "expectedPatternValue": "預期為格式 \"a.b\" 的模式值運算式",
        "expectedReturnExpr": "\"return\" 後預期為運算式",
        "expectedSliceIndex": "應為索引或切片運算式",
        "expectedTypeNotString": "預期為類型，但收到字串常值",
        "expectedTypeParameterName": "應為型別參數名稱",
        "expectedYieldExpr": "yield 陳述式中應有運算式",
        "finalClassIsAbstract": "類別 \"{type}\" 標示為 final，且必須實作所有抽象符號",
        "finalContext": "此內容中不允許 \"Final\"",
        "finalInLoop": "無法在迴圈內指派 \"Final\" 變數",
        "finalMethodOverride": "方法 \"{name}\" 不能覆寫類別 \"{className}\" 中定義的 final 方法",
        "finalNonMethod": "無法將函式 \"{name}\" 標示為 @final，因為它不是方法",
        "finalReassigned": "\"{name}\" 已宣告為 Final，因此無法重新指派",
        "finalRedeclaration": "\"{name}\" 先前已宣告為 Final",
        "finalRedeclarationBySubclass": "不能重新宣告 \"{name}\"，因為父類別 \"{className}\" 將其宣告為 Final",
        "finalTooManyArgs": "預期 \"Final\" 之後為單一類型引數",
        "finalUnassigned": "\"{name}\" 宣告為 Final，但未指派值",
        "formatStringBrace": "F 字串常值內不允許單一右大括弧; 請使用雙右大括弧",
        "formatStringBytes": "格式字串常值 (f-strings) 不可為二進位",
        "formatStringDebuggingIllegal": "F 字串偵錯指定名稱 \"=\" 需要 Python 3.8 或較新的版本",
        "formatStringEscape": "Python 3.12 之前的 f 字串運算式部分不允許逸出序列 (反斜線)",
        "formatStringExpectedConversion": "預期 f-string 中的 \"!\" 後為轉換指定元",
        "formatStringIllegal": "格式字串常值 (f-strings) 需要 Python 3.6 或較新的版本",
        "formatStringInPattern": "模式中不允許格式字串",
        "formatStringNestedFormatSpecifier": "運算式在格式字串指定元內巢狀太深",
        "formatStringNestedQuote": "f 字串內的巢狀字串無法使用與 Python 3.12 之前的 f 字串相同的引號字元",
        "formatStringUnicode": "格式字串常值 (f-strings) 不能是 Unicode",
        "formatStringUnterminated": "f 字串中有未結束的運算式; 應有 \"}\"",
        "functionDecoratorTypeUnknown": "非類型化函式修飾項目會遮蔽函式的類型; 忽略裝飾項目",
        "functionInConditionalExpression": "條件運算式參考函式，一律評估為 True",
        "functionTypeParametersIllegal": "函式型別參數語法需要 Python 3.12 或較新的版本",
        "futureImportLocationNotAllowed": "來自 __future__ 的匯入必須位於檔案的開頭",
        "generatorAsyncReturnType": "Return type of async generator function must be compatible with \"AsyncGenerator[{yieldType}, Any]\"",
        "generatorNotParenthesized": "如果不是唯一引數，則必須將產生器運算式用括弧括住",
        "generatorSyncReturnType": "產生器函式的傳回類型必須與 \"Generator[{yieldType}, Any, Any]\" 相容",
        "genericBaseClassNotAllowed": "\"Generic\" 基底類別不能與型別參數語法一起使用",
        "genericClassAssigned": "不能指派一般類別類型",
        "genericClassDeleted": "無法刪除一般類別型別",
        "genericInstanceVariableAccess": "透過類別存取泛型執行個體變數不明確",
        "genericNotAllowed": "\"Generic\" 在此內容中無效",
        "genericTypeAliasBoundTypeVar": "類別內的一般類型別名不能使用繫結類型變數 {names}",
        "genericTypeArgMissing": "\"Generic\" 至少需要一個類型引數",
        "genericTypeArgTypeVar": "\"Generic\" 的類型引數必須是類型變數",
        "genericTypeArgUnique": "\"Generic\" 的類型引數必須是唯一的",
        "globalReassignment": "\"{name}\" 在 global 宣告之前指派",
        "globalRedefinition": "\"{name}\" 已宣告為 global",
        "implicitStringConcat": "不允許隱含字串串連",
        "importCycleDetected": "在匯入鏈結中偵測到迴圈",
        "importDepthExceeded": "匯入鏈結深度超過 {depth}",
        "importResolveFailure": "無法解析匯入 \"{importName}\"",
        "importSourceResolveFailure": "無法從來源解析匯入 \"{importName}\"",
        "importSymbolUnknown": "\"{name}\" 是未知的匯入符號",
        "incompatibleMethodOverride": "方法 \"{name}\" 會以不相容的方式覆寫類別 \"{className}\"",
        "inconsistentIndent": "取消縮排量與先前縮排不符",
        "inconsistentTabs": "在縮排中使用 Tab 字元和空格不一致",
        "initMethodSelfParamTypeVar": "\"__init__\" 方法之 \"self\" 參數的類型註釋不得包含類別範圍的類型變數",
        "initMustReturnNone": "\"__init__\" 的傳回類型必須為 None",
        "initSubclassCallFailed": "__init_subclass__ 方法不正確的關鍵字引數",
        "initSubclassClsParam": "__init_subclass__ 覆寫應接受 \"cls\" 參數",
        "initVarNotAllowed": "此內容中不允許 \"InitVar\"",
        "instanceMethodSelfParam": "執行個體方法應該採用 \"self\" 參數",
        "instanceVarOverridesClassVar": "執行個體變數 \"{name}\" 覆寫類別 \"{className}\" 中相同名稱的類別變數",
        "instantiateAbstract": "無法將抽象類別 \"{type}\" 具現化",
        "instantiateProtocol": "無法將 Protocol 類別 \"{type}\" 具現化",
        "internalBindError": "繫結檔案 \"{file}\" 時發生內部錯誤: {message}",
        "internalParseError": "剖析檔案 \"{file}\" 時發生內部錯誤: {message}",
        "internalTypeCheckingError": "類型檢查檔案 \"{file}\" 時發生內部錯誤: {message}",
        "invalidIdentifierChar": "識別碼中的字元無效",
        "invalidStubStatement": "陳述式在類型 stub 檔案內沒有意義",
        "invalidTokenChars": "權杖中的字元 \"{text}\" 無效",
        "isInstanceInvalidType": "\"isinstance\" 的第二個引數必須是類別或類別的tuple",
        "isSubclassInvalidType": "\"issubclass\" 的第二個引數必須是類別的類別或 tuple",
        "keyValueInSet": "set 內不允許金鑰/值組",
        "keywordArgInTypeArgument": "關鍵字引數無法用於型別引數清單",
        "keywordArgShortcutIllegal": "關鍵字引數快速鍵需要 Python 3.14 或更新版本",
        "keywordOnlyAfterArgs": "\"*\" 參數之後不允許僅限關鍵字的引數分隔符號",
        "keywordParameterMissing": "一或多個關鍵字參數必須接在 \"*\" 參數後面",
        "keywordSubscriptIllegal": "不支援下標內的關鍵字引數",
        "lambdaReturnTypePartiallyUnknown": "Lambda 的傳回類型 \"{returnType}\" 部分未知",
        "lambdaReturnTypeUnknown": "Lambda 的傳回類型未知",
        "listAssignmentMismatch": "類型 \"{type}\" 的運算式不能指派至目標清單",
        "listInAnnotation": "型別運算式中不允許 List 運算式",
        "literalEmptyArgs": "\"Literal\" 後面應有一或多個型別引數",
        "literalNamedUnicodeEscape": "\"Literal\" 字串常值中不支援具名 Unicode 逸出序列",
        "literalNotAllowed": "沒有類型參數，\"Literal\" 不能在此內容中使用",
        "literalNotCallable": "Literal 類型不能具現化",
        "literalUnsupportedType": "\"Literal\" 的類型引數必須是 None、literal (int、bool、str 或 bytes) 或 enum 值",
        "matchIncompatible": "Match 陳述式需要 Python 3.10 或更新版本",
        "matchIsNotExhaustive": "match 陳述式內的案例並未完整處理所有值",
        "maxParseDepthExceeded": "超過剖析深度上限; 將運算式分成較小的子運算式",
        "memberAccess": "無法存取類別 \"{type}\" 的屬性 \"{name}\"",
        "memberDelete": "無法刪除類別 \"{type}\" 的屬性 \"{name}\"",
        "memberSet": "無法指派至類別 \"{type}\" 的屬性 \"{name}\"",
        "metaclassConflict": "衍生類別的變換類型必須是其所有基底類別的變換類型的子類別",
        "metaclassDuplicate": "只能提供一個變換類型",
        "metaclassIsGeneric": "變換類型不能是一般",
        "methodNotDefined": "\"{name}\" 方法未定義",
        "methodNotDefinedOnType": "類型 \"{type}\" 上未定義 \"{name}\" 方法",
        "methodOrdering": "不能建立一致的方法順序",
        "methodOverridden": "\"{name}\" 以不相容型別 \"{type}\" 覆寫類別 \"{className}\" 中具有相同名稱的方法",
        "methodReturnsNonObject": "\"{name}\" 方法未傳回物件",
        "missingSuperCall": "方法 \"{methodName}\" 未呼叫父類別中相同名稱的方法",
        "mixingBytesAndStr": "無法串連 Bytes 和 str 值",
        "moduleAsType": "模組不能當作型別來使用",
        "moduleNotCallable": "模組無法呼叫",
        "moduleUnknownMember": "\"{memberName}\" 不是模組 \"{moduleName}\" 的已知屬性",
        "namedExceptAfterCatchAll": "catch-all except 子句後面不能出現具名 except 子句",
        "namedParamAfterParamSpecArgs": "關鍵字參數 \"{name}\" 不能在簽章中出現在 ParamSpec args 參數之後",
        "namedTupleEmptyName": "具名 tuple 內的名稱不可為空白",
        "namedTupleEntryRedeclared": "無法覆寫 \"{name}\"，因為父代類別 \"{className}\" 是具名的 tuple",
        "namedTupleFirstArg": "預期為具名 tuple 類別名稱作為第一個引數",
        "namedTupleMultipleInheritance": "不支援使用 NamedTuple 的多重繼承",
        "namedTupleNameKeyword": "欄位名稱不能是關鍵字",
        "namedTupleNameType": "指定輸入項目名稱和類型預期有兩個輸入項目 tuple",
        "namedTupleNameUnique": "具名 tuple 內的名稱必須是唯一的",
        "namedTupleNoTypes": "\"namedtuple\" 未提供 Tuple 項目的類型; 請改為使用 \"NamedTuple\"",
        "namedTupleSecondArg": "預期為具名 tuple 項目 list 作為第二個引數",
        "newClsParam": "__new__ 覆寫應接受 \"cls\" 參數",
        "newTypeAnyOrUnknown": "NewType 的第二個引數必須是已知的類別，不能是 Any 或 Unknown",
        "newTypeBadName": "NewType 的第一個引數必須是字串常值",
        "newTypeLiteral": "NewType 不能與 Literal 類型搭配使用",
        "newTypeNameMismatch": "NewType 必須指派給名稱相同的變數",
        "newTypeNotAClass": "預期類別為 NewType 的第二個引數",
        "newTypeParamCount": "NewType 需要兩個位置引數",
        "newTypeProtocolClass": "NewType 無法與結構類型 (Protocol 或 TypedDict 類別) 搭配使用",
        "noOverload": "\"{name}\" 沒有任何多載符合提供的引數",
        "noReturnContainsReturn": "宣告 return 類型為 \"NoReturn\" 的函式不能包含 return 陳述式",
        "noReturnContainsYield": "宣告傳回類型為 \"NoReturn\" 的函式不能包含 yield 陳述式",
        "noReturnReturnsNone": "宣告類型為 \"NoReturn\" 的函式不能傳回 \"None\"",
        "nonDefaultAfterDefault": "非預設引數遵循預設引數",
        "nonLocalInModule": "模組層級不允許 nonlocal 宣告",
        "nonLocalNoBinding": "找不到 nonlocal \"{name}\" 的繫結",
        "nonLocalReassignment": "\"{name}\" 在 nonlocal 宣告之前指派",
        "nonLocalRedefinition": "\"{name}\" 已宣告為 nonlocal",
        "noneNotCallable": "無法呼叫型別 \"None\" 的物件",
        "noneNotIterable": "類型 \"None\" 的物件不能作為可疊代的值",
        "noneNotSubscriptable": "型別 \"None\" 的物件不能下標",
        "noneNotUsableWith": "Object of type \"None\" cannot be used with \"with\"",
        "noneNotUsableWithAsync": "Object of type \"None\" cannot be used with \"async with\"",
        "noneOperator": "\"None\" 不支援運算子 \"{operator}\"",
        "noneUnknownMember": "\"{name}\" 不是 \"None\" 的已知屬性",
        "notRequiredArgCount": "預期 \"NotRequired\" 之後為單一類型引數",
        "notRequiredNotInTypedDict": "此內容中不允許 \"NotRequired\"",
        "objectNotCallable": "類型 \"{type}\" 的物件無法呼叫",
        "obscuredClassDeclaration": "類別宣告 \"{name}\" 已被相同名稱的宣告遮蔽",
        "obscuredFunctionDeclaration": "函式宣告 \"{name}\" 被相同名稱的宣告遮蔽",
        "obscuredMethodDeclaration": "方法宣告 \"{name}\" 被相同名稱的宣告遮蔽",
        "obscuredParameterDeclaration": "參數宣告 \"{name}\" 被相同名稱的宣告遮蔽",
        "obscuredTypeAliasDeclaration": "類型別名宣告 \"{name}\" 被相同名稱的宣告遮蔽",
        "obscuredVariableDeclaration": "宣告 \"{name}\" 被相同名稱的宣告遮蔽",
        "operatorLessOrGreaterDeprecated": "Python 3 中不支援運算子 \"<>\"; 請改為使用 \"!=\"",
        "optionalExtraArgs": "\"Optional\" 後面應有一個型別引數",
        "orPatternIrrefutable": "無法推翻的模式僅允許作為 \"or\" 模式中的最後一個子模式",
        "orPatternMissingName": "\"or\" 模式內的所有子模式都必須以相同的名稱為目標",
        "overlappingKeywordArgs": "輸入的字典與關鍵字參數重疊:: {names}",
        "overlappingOverload": "\"{name}\" 的多載 {obscured} 將永遠不會使用，因為它的參數與多載 {obscuredBy} 重疊",
        "overloadAbstractImplMismatch": "多載必須符合實作的抽象狀態",
        "overloadAbstractMismatch": "多載必須全為抽象或不抽象",
        "overloadClassMethodInconsistent": "\"{name}\" 的多載不一致地使用 @classmethod",
        "overloadFinalInconsistencyImpl": "\"{name}\" 的多載已標示為 @final 但未實作",
        "overloadFinalInconsistencyNoImpl": "\"{name}\" 的多載 {index} 標示為 @final 但多載 1 未標示",
        "overloadImplementationMismatch": "多載的實作與多載 {index} 的簽章不一致",
        "overloadReturnTypeMismatch": "\"{name}\" 的多載 {prevIndex} 與多載 {newIndex} 重疊，並傳回不相容的類型",
        "overloadStaticMethodInconsistent": "\"{name}\" 的多載不一致地使用 @staticmethod",
        "overloadWithoutImplementation": "\"{name}\" 標示為 overload，但未提供實作",
        "overriddenMethodNotFound": "方法 \"{name}\" 已標示為 override，但不存在相同名稱的基底方法",
        "overrideDecoratorMissing": "方法 \"{name}\" 未標示為 override，但正在覆寫類別 \"{className}\" 中的方法",
        "paramAfterKwargsParam": "參數無法接在 \"**\" 參數後面",
        "paramAlreadyAssigned": "已指派參數 \"{name}\"",
        "paramAnnotationMissing": "參數 \"{name}\" 遺漏了型別註釋",
        "paramAssignmentMismatch": "無法將型別 \"{sourceType}\" 的運算式指派給型別 \"{paramType}\" 的參數",
        "paramNameMissing": "沒有名為 \"{name}\" 的參數",
        "paramSpecArgsKwargsDuplicate": "ParamSpec \"{type}\" 的引數已提供",
        "paramSpecArgsKwargsUsage": "ParamSpec 的 \"args\" 和 \"kwargs\" 屬性都必須出現在函式簽章內",
        "paramSpecArgsMissing": "ParamSpec \"{type}\" 的引數遺失",
        "paramSpecArgsUsage": "只有搭配 *args 參數使用時，ParamSpec 的 \"args\" 屬性才有效",
        "paramSpecAssignedName": "ParamSpec 必須指派至名為 \"{name}\" 的變數",
        "paramSpecContext": "此內容中不允許 ParamSpec",
        "paramSpecDefaultNotTuple": "ParamSpec 的預設值必須是省略符號、tuple 運算式或 ParamSpec",
        "paramSpecFirstArg": "應以 ParamSpec 的名稱作為第一個引數",
        "paramSpecKwargsUsage": "只有搭配 **kwargs 參數使用時，ParamSpec 的 \"kwargs\" 屬性才有效",
        "paramSpecNotUsedByOuterScope": "ParamSpec \"{name}\" 在此內容中沒有意義",
        "paramSpecUnknownArg": "ParamSpec 不支援一個以上的引數",
        "paramSpecUnknownMember": "\"{name}\" 不是 ParamSpec 的已知屬性",
        "paramSpecUnknownParam": "\"{name}\" 對 ParamSpec 是未知的參數",
        "paramTypeCovariant": "不能在參數類型中使用共變數類型變數",
        "paramTypePartiallyUnknown": "參數 \"{paramName}\" 的類型部分未知",
        "paramTypeUnknown": "參數 \"{paramName}\" 的類型未知",
        "parenthesizedContextManagerIllegal": "Parentheses within \"with\" statement requires Python 3.9 or newer",
        "patternNeverMatches": "模式永遠不會符合主體類型 \"{type}\"",
        "positionArgAfterNamedArg": "位置引數不能出現在關鍵字引數之後",
        "positionArgAfterUnpackedDictArg": "Positional argument cannot appear after keyword argument unpacking",
        "positionOnlyAfterArgs": "\"*\" 參數之後不允許 Position-only 參數分隔符號",
        "positionOnlyAfterKeywordOnly": "\"/\" 參數必須出現在 \"*\" 參數之前",
        "positionOnlyAfterNon": "非 Position-only 參數之後不允許 Position-only 參數",
        "positionOnlyFirstParam": "不允許 Position-only 參數分隔符號作為第一個參數",
        "positionOnlyIncompatible": "Position-only 參數分隔符號需要 Python 3.8 或更新版本",
        "privateImportFromPyTypedModule": "\"{name}\" 未從模組 \"{module}\" 匯出",
        "privateUsedOutsideOfClass": "\"{name}\" 為私人，並用於宣告其所在的類別之外",
        "privateUsedOutsideOfModule": "\"{name}\" 為私人，並用於宣告其所在的模組之外",
        "propertyOverridden": "\"{name}\" 不正確地覆寫了類別 \"{className}\" 中相同名稱的 property",
        "propertyStaticMethod": "Static methods not allowed for property getter, setter or deleter",
        "protectedUsedOutsideOfClass": "\"{name}\" 受到保護，並用於其宣告所在的類別之外",
        "protocolBaseClass": "Protocol 類別 \"{classType}\" 不能衍生自非 Protocol 類別 \"{baseType}\"",
        "protocolBaseClassWithTypeArgs": "使用型別參數語法時，Protocol 類別不允許使用型別引數",
        "protocolIllegal": "使用 \"Protocol\" 需要 Python 3.7 或更新版本",
        "protocolNotAllowed": "\"Protocol\" 不能用在此內容中",
        "protocolTypeArgMustBeTypeParam": "“Protocol” 的型別引數必須是型別參數",
        "protocolUnsafeOverlap": "類別以不安全方式重疊 \"{name}\"，且可能會在運行時間產生相符專案",
        "protocolVarianceContravariant": "一般 Protocol \"{class}\" 中使用的類別變數 \"{variable}\" 必須為逆變數",
        "protocolVarianceCovariant": "一般 Protocol \"{class}\" 中使用的類型變數 \"{variable}\" 必須為共變數",
        "protocolVarianceInvariant": "一般 Protocol \"{class}\" 中使用的類別變數 \"{variable}\" 必須為不變數",
        "pyrightCommentInvalidDiagnosticBoolValue": "Pyright 註解指示詞後面必須接著 \"=\"，且值為 true 或 false",
        "pyrightCommentInvalidDiagnosticSeverityValue": "Pyright 註解指示詞後面必須接著 \"=\"，且值為 true、false、error、warning、information 或 none",
        "pyrightCommentMissingDirective": "Pyright 註解後面必須接著指示詞 (basic 或 strict) 或診斷規則",
        "pyrightCommentNotOnOwnLine": "用來控制檔案層級設定的 Pyright 註解必須出現在自己的行上",
        "pyrightCommentUnknownDiagnosticRule": "\"{rule}\" 是 pyright 註解未知的診斷規則",
        "pyrightCommentUnknownDiagnosticSeverityValue": "\"{value}\" 是 pyright 註解無效的值; 預期為 true、false、error、warning、information 或 none",
        "pyrightCommentUnknownDirective": "\"{directive}\" 是 pyright 註解未知的指示詞; 預期為 \"strict\" 或 \"basic\"",
        "readOnlyArgCount": "\"ReadOnly\" 後面應有單一型別引數",
        "readOnlyNotInTypedDict": "此內容中不允許 \"ReadOnly\"",
        "recursiveDefinition": "無法判斷 \"{name}\" 型別，因為它參照了自己",
        "relativeImportNotAllowed": "相對匯入不能與 \"import .a\" 格式搭配使用; 請改為使用 \"from . import a\"",
        "requiredArgCount": "\"Required\" 後面應有單一型別引數",
        "requiredNotInTypedDict": "此內容中不允許 \"Required\"",
        "returnInAsyncGenerator": "Return statement with value is not allowed in async generator",
        "returnInExceptionGroup": "\"except*\" 區塊中不允許 \"return\"",
        "returnMissing": "宣告類型為 \"{returnType}\" 的函式必須在所有程式碼路徑上傳回值",
        "returnOutsideFunction": "\"return\" 只能在函式內使用",
        "returnTypeContravariant": "逆變數型別變數不能用在傳回型別中",
        "returnTypeMismatch": "型別 \"{exprType}\" 無法指派給傳回型別 \"{returnType}\"",
        "returnTypePartiallyUnknown": "傳回類型 \"{returnType}\" 部分未知",
        "returnTypeUnknown": "傳回類型未知",
        "revealLocalsArgs": "\"reveal_locals\" 呼叫不應有任何引數",
        "revealLocalsNone": "此範圍中沒有任何 locals",
        "revealTypeArgs": "\"reveal_type\" 呼叫預期為單一位置引數",
        "revealTypeExpectedTextArg": "函式 \"reveal_type\" 的 \"expected_text\" 引數必須是 str 常值",
        "revealTypeExpectedTextMismatch": "類型文字不符; 預期為 \"{expected}\"，但收到 \"{received}\"",
        "revealTypeExpectedTypeMismatch": "型別不符; 應為 \"{expected}\"，但收到 \"{received}\"",
        "selfTypeContext": "\"Self\" 在此內容中無效",
        "selfTypeMetaclass": "“Self” 不能用於 Metaclass 内 (“type” 的子類別)",
        "selfTypeWithTypedSelfOrCls": "\"Self\" 不能用在具有 `self` 或 `cls` 參數的函式中，其類型註釋不是 \"Self\"",
        "setterGetterTypeMismatch": "Property setter 數值類型不能指派至 getter 傳回類型",
        "singleOverload": "\"{name}\" 標示為多載，但遺失其他多載",
        "slotsAttributeError": "未在__slots__中指定 \"{name}\"",
        "slotsClassVarConflict": "\"{name}\" 與在 __slots__ 中宣告的執行個體變數衝突",
        "starPatternInAsPattern": "星形模式不能與 \"as\" 目標搭配使用",
        "starPatternInOrPattern": "星形模式不能在其他模式內使用 OR",
        "starStarWildcardNotAllowed": "** 不能與萬用字元 \"_\" 搭配使用",
        "staticClsSelfParam": "靜態方法不應採用 \"self\" 或 \"cls\" 參數",
        "stdlibModuleOverridden": "\"{path}\" 正在覆寫 stdlib 模組 \"{name}\"",
        "stringNonAsciiBytes": "位元組字串常值中不允許非 ASCII 字元",
        "stringNotSubscriptable": "字串運算式不能在類型運算式中下標; 以引號括住整個運算式",
        "stringUnsupportedEscape": "字串常值中不支援的逸出序列",
        "stringUnterminated": "字串常值未結束",
        "stubFileMissing": "找不到 \"{importName}\" 的 stub 檔案",
        "stubUsesGetAttr": "類型 stub 檔案不完整; \"__getattr__\" 會遮蔽模組的類型錯誤",
        "sublistParamsIncompatible": "Python 3.x 不支援 sublist 參數",
        "superCallArgCount": "\"super\" 呼叫不應有兩個以上的引數",
        "superCallFirstArg": "預期的類別類型為 \"super\" 呼叫的第一個引數，但收到 \"{type}\"",
        "superCallSecondArg": "\"super\" 呼叫的第二個引數必須是衍生自 \"{type}\" 的物件或類別",
        "superCallZeroArgForm": "\"super\" 呼叫的零引數形式只在方法內有效",
        "superCallZeroArgFormStaticMethod": "\"super\" 呼叫的零引數形式在靜態方法內無效",
        "symbolIsPossiblyUnbound": "\"{name}\" 可能未繫結",
        "symbolIsUnbound": "\"{name}\" 未繫結",
        "symbolIsUndefined": "\"{name}\" 未定義",
        "symbolOverridden": "\"{name}\" 會覆寫類別 \"{className}\" 中相同名稱的符號",
        "ternaryNotAllowed": "類型運算式中不允許三元運算式",
        "totalOrderingMissingMethod": "類別必須定義 \"__lt__\"、\"__le__\"、\"__gt__\" 或 \"__ge__\" 其中一個，才能使用 total_ordering",
        "trailingCommaInFromImport": "後置逗號不允許未使用括弧",
        "tryWithoutExcept": "Try 陳述式必須至少有一個 except 或 finally 子句",
        "tupleAssignmentMismatch": "無法將型別 \"{type}\" 的運算式指派至目標 tuple",
        "tupleInAnnotation": "型別運算式中不允許 Tuple 運算式",
        "tupleIndexOutOfRange": "索引 {index} 超過類型 {type} 的範圍",
        "typeAliasIllegalExpressionForm": "類型別名定義無效的運算式格式",
        "typeAliasIsRecursiveDirect": "型別別名 \"{name}\" 無法在其定義中使用它自己",
        "typeAliasNotInModuleOrClass": "TypeAlias 只能在模組或類別範圍內定義",
        "typeAliasRedeclared": "\"{name}\" 宣告為 TypeAlias，且只能指派一次",
        "typeAliasStatementBadScope": "A type statement can be used only within a module or class scope",
        "typeAliasStatementIllegal": "類型別名陳述式需要 Python 3.12 或更新版本",
        "typeAliasTypeBaseClass": "\"type\" 陳述式中定義的類型別名不能做為基底類別使用",
        "typeAliasTypeMustBeAssigned": "TypeAliasType 必須指派給與型別別名相同的變數",
        "typeAliasTypeNameArg": "TypeAliasType 的第一個引數必須是代表型別別名名稱的字串常值",
        "typeAliasTypeNameMismatch": "類型別名的名稱必須與指派它的變數名稱相符",
        "typeAliasTypeParamInvalid": "型別參數清單必須是只包含 TypeVar、TypeVarTuple 或 ParamSpec 的 tuple",
        "typeAnnotationCall": "型別運算式中不允許呼叫運算式",
        "typeAnnotationVariable": "型別運算式中不允許變數",
        "typeAnnotationWithCallable": "\"type\" 的類型引數必須是類別; 不支援可呼叫項目",
        "typeArgListExpected": "預期為 ParamSpec、省略符號或類型 list",
        "typeArgListNotAllowed": "此型別引數不允許 list 運算式",
        "typeArgsExpectingNone": "預期類別 \"{name}\" 沒有類型引數",
        "typeArgsMismatchOne": "預期為一個類型引數，但收到 {received}",
        "typeArgsMissingForAlias": "預期為一般類型別名 \"{name}\" 的類型引數",
        "typeArgsMissingForClass": "應為一般類別 \"{name}\" 的型別引數",
        "typeArgsTooFew": "為 \"{name}\" 提供太少類型引數; 預期為 {expected} 但收到 {received}",
        "typeArgsTooMany": "已為 \"{name}\" 提供太多型別引數; 應為 {expected} 但收到 {received}",
        "typeAssignmentMismatch": "型別 \"{sourceType}\" 無法指派給宣告的型別 \"{destType}\"",
        "typeAssignmentMismatchWildcard": "匯入符號 \"{name}\" 具有型別 \"{sourceType}\"，該型別無法指派給宣告的型別 \"{destType}\"",
        "typeCallNotAllowed": "不應在類型運算式中使用 type() 呼叫",
        "typeCheckOnly": "\"{name}\" 已標示為 @type_check_only，只能在型別註釋中使用",
        "typeCommentDeprecated": "使用 type 註解已取代; 請改為使用 type 註釋",
        "typeExpectedClass": "預期的類別，但已收到 \"{type}\"",
        "typeFormArgs": "\"TypeForm\" 接受單一位置引數",
        "typeGuardArgCount": "預期 \"TypeGuard\" 或 \"TypeIs\" 之後為單一類型引數",
        "typeGuardParamCount": "使用者定義的類型防護函式和方法至少必須有一個輸入參數",
        "typeIsReturnType": "TypeIs 的傳回類型 (\"{returnType}\") 與值參數類型 (\"{type}\") 不一致",
        "typeNotAwaitable": "\"{type}\" 不可 awaitable",
        "typeNotIntantiable": "\"{type}\" 不能具現化",
        "typeNotIterable": "\"{type}\" 無法疊代",
        "typeNotSpecializable": "無法將型別 \"{type}\" 特殊化",
        "typeNotSubscriptable": "類型 \"{type}\" 的物件不能下標",
        "typeNotSupportBinaryOperator": "型別 \"{leftType}\" 和 \"{rightType}\" 不支援運算子 \"{operator}\"",
        "typeNotSupportBinaryOperatorBidirectional": "當預期的型別為 \"{expectedType}\" 時，型別 \"{leftType}\" 和 \"{rightType}\" 不支援運算子 \"{operator}\"",
        "typeNotSupportUnaryOperator": "型別 \"{type}\" 不支援運算子 \"{operator}\"",
        "typeNotSupportUnaryOperatorBidirectional": "預期的類型為 \"{expectedType}\" 時，類型 \"{type}\" 不支援運算子 \"{operator}\"",
        "typeNotUsableWith": "Object of type \"{type}\" cannot be used with \"with\" because it does not correctly implement {method}",
        "typeNotUsableWithAsync": "Object of type \"{type}\" cannot be used with \"async with\" because it does not correctly implement {method}",
        "typeParameterBoundNotAllowed": "界限或條件約束不能與 variadic 型別參數或 ParamSpec 一起使用",
        "typeParameterConstraintTuple": "類型參數限制式必須是兩個或兩個以上類型的 Tuple",
        "typeParameterExistingTypeParameter": "類型參數 \"{name}\" 已在使用中",
        "typeParameterNotDeclared": "類型參數 \"{name}\" 未包含在 \"{container}\" 的類型參數清單中",
        "typeParametersMissing": "至少必須指定一個類型參數",
        "typePartiallyUnknown": "\"{name}\" 的類型部分未知",
        "typeUnknown": "\"{name}\" 的類型未知",
        "typeVarAssignedName": "TypeVar 必須指派至名為 \"{name}\" 的變數",
        "typeVarAssignmentMismatch": "無法將型別 \"{type}\" 指派給型別變數 \"{name}\"",
        "typeVarBoundAndConstrained": "TypeVar 不能同時繫結和限制",
        "typeVarBoundGeneric": "TypeVar 繫結類型不能是一般",
        "typeVarConstraintGeneric": "TypeVar 限制式類型不能是一般",
        "typeVarDefaultBoundMismatch": "TypeVar 預設型別必須是繫結型別的子型別",
        "typeVarDefaultConstraintMismatch": "TypeVar 預設型別必須是其中一個限制型別",
        "typeVarDefaultIllegal": "型別變數預設型別需要 Python 3.13 或較新的版本",
        "typeVarDefaultInvalidTypeVar": "類型參數 \"{name}\" 的預設類型參考不在範圍的一或多個類型變數",
        "typeVarFirstArg": "預期為 TypeVar 的名稱作為第一個引數",
        "typeVarInvalidForMemberVariable": "屬性類型不能使用範圍為 local 方法的類型變數 \"{name}\"",
        "typeVarNoMember": "TypeVar \"{type}\" 沒有屬性 \"{name}\"",
        "typeVarNotSubscriptable": "TypeVar \"{type}\" 不能下標",
        "typeVarNotUsedByOuterScope": "類型變數 \"{name}\" 在此內容中沒有意義",
        "typeVarPossiblyUnsolvable": "如果呼叫者未提供參數 \"{param}\" 的引數，則型別變數 \"{name}\" 可能無法解析",
        "typeVarSingleConstraint": "TypeVar 至少必須有兩個限制類型",
        "typeVarTupleConstraints": "TypeVarTuple 不能有值條件約束",
        "typeVarTupleContext": "此內容中不允許 TypeVarTuple",
        "typeVarTupleDefaultNotUnpacked": "TypeVarTuple 預設型別必須是未封裝的 tuple 或 TypeVarTuple",
        "typeVarTupleMustBeUnpacked": "TypeVarTuple 值需要解除封裝運算子",
        "typeVarTupleUnknownParam": "\"{name}\" 是 TypeVarTuple 的未知參數",
        "typeVarUnknownParam": "\"{name}\" 對 TypeVar 是未知的參數",
        "typeVarUsedByOuterScope": "外部領域已在使用 TypeVar \"{name}\"",
        "typeVarUsedOnlyOnce": "TypeVar \"{name}\" 只會在一般函式簽章中出現一次",
        "typeVarVariance": "TypeVar 不能同時為共變數和逆變數",
        "typeVarWithDefaultFollowsVariadic": "TypeVar \"{typeVarName}\" 具有預設值，無法遵循 TypeVarTuple \"{variadicName}\"",
        "typeVarWithoutDefault": "\"{name}\" 無法出現在型別參數清單中的 \"{other}\" 後面，因為它沒有預設型別",
        "typeVarsNotInGenericOrProtocol": "Generic[] 或 Protocol[] 必須包含所有類型變數",
        "typedDictAccess": "無法存取 TypedDict 中的項目",
        "typedDictAssignedName": "TypedDict 必須指派至名為 \"{name}\" 的變數",
        "typedDictBadVar": "TypedDict 類別只能包含型別註釋",
        "typedDictBaseClass": "TypedDict 類別的所有基底類別也必須是 TypedDict 類別",
        "typedDictBoolParam": "預期 \"{name}\" 參數的值為 True 或 False",
        "typedDictClosedExtras": "基底類別 \"{name}\" 是 closed 的 TypedDict; 額外項目必須為型別 \"{type}\"",
        "typedDictClosedNoExtras": "基底類別 \"{name}\" 是 closed 的 TypedDict; 不允許額外項目",
        "typedDictDelete": "無法刪除 TypedDict 中的項目",
        "typedDictEmptyName": "TypedDict 內的名稱不可為空白",
        "typedDictEntryName": "字典項目名稱預期為字串常值",
        "typedDictEntryUnique": "字典內的名稱必須是唯一的",
        "typedDictExtraArgs": "不支援額外的 TypedDict 引數",
        "typedDictExtraItemsClosed": "如果 TypedDict 支援額外項目，就不能是 closed",
        "typedDictFieldNotRequiredRedefinition": "TypedDict 項目 \"{name}\" 不能重新定義為 NotRequired",
        "typedDictFieldReadOnlyRedefinition": "TypedDict 項目 \"{name}\" 不能重新定義為 ReadOnly",
        "typedDictFieldRequiredRedefinition": "TypedDict 項目 \"{name}\" 不能重新定義為 Required",
        "typedDictFirstArg": "預期 TypedDict 類別名稱作為第一個引數",
        "typedDictInClassPattern": "類別模式中不允許 TypedDict 類別",
        "typedDictInitsubclassParameter": "TypedDict 不支援__init_subclass__參數 \"{name}\"",
        "typedDictNotAllowed": "\"TypedDict\" 不能用在此內容中",
        "typedDictSecondArgDict": "預期為 dict 或關鍵字參數作為第二個參數",
        "typedDictSecondArgDictEntry": "應為簡單字典輸入項目",
        "typedDictSet": "無法在 TypedDict 中指派項目",
        "unaccessedClass": "未存取類別 \"{name}\"",
        "unaccessedFunction": "未存取函式 \"{name}\"",
        "unaccessedImport": "未存取匯入 \"{name}\"",
        "unaccessedSymbol": "未存取 \"{name}\"",
        "unaccessedVariable": "未存取變數 \"{name}\"",
        "unannotatedFunctionSkipped": "因為未標註函式 \"{name}\"，所以略過其分析",
        "unaryOperationNotAllowed": "類型運算式中不允許一元運算子",
        "unexpectedAsyncToken": "預期為 \"def\"、\"with\" 或 \"for\" 來追蹤 \"async\"",
        "unexpectedExprToken": "運算式結尾未預期的權杖",
        "unexpectedIndent": "未預期的縮排",
        "unexpectedUnindent": "取消縮排未預期",
        "unhashableDictKey": "字典索引鍵必須是可雜湊的",
        "unhashableSetEntry": "Set 項目必須是可雜湊",
        "uninitializedAbstractVariables": "抽象基底類別中定義的變數未在 final 類別 \"{classType}\" 中初始化",
        "uninitializedInstanceVariable": "執行個體變數 \"{name}\" 未在類別本文或 __init__ 方法上初始化",
        "unionForwardReferenceNotAllowed": "Union 語法不能與字串運算元搭配使用; 使用引號括住整個運算式",
        "unionSyntaxIllegal": "聯集的替代語法需要 Python 3.10 或更新版本",
        "unionTypeArgCount": "Union 需要兩個或多個類型引數",
        "unionUnpackedTuple": "Union 不能包含未封裝的 tuple",
        "unionUnpackedTypeVarTuple": "Union 不能包含未封裝的 TypeVarTuple",
        "unnecessaryCast": "不必要的 \"cast\" 呼叫; 型別已是 \"{type}\"",
        "unnecessaryIsInstanceAlways": "不必要的 isinstance 呼叫; \"{testType}\" 一律是 \"{classType}\" 的執行個體",
        "unnecessaryIsInstanceNever": "不必要的 isinstance 呼叫; \"{testType}\" 永遠不是 \"{classType}\" 的執行個體",
        "unnecessaryIsSubclassAlways": "不必要的 issubclass 呼叫; \"{testType}\"永遠是 \"{classType}\" 的子類別",
        "unnecessaryIsSubclassNever": "不必要的 issubclass 呼叫; \"{testType}\"永遠不是 \"{classType}\" 的子類別",
        "unnecessaryPyrightIgnore": "不必要的 \"# pyright: ignore\" 註解",
        "unnecessaryPyrightIgnoreRule": "不必要的 \"# pyright: ignore\" 規則: \"{name}\"",
        "unnecessaryTypeIgnore": "不必要的 \"# type: ignore\" 註解",
        "unpackArgCount": "\"Unpack\" 後面應為單一型別引數",
        "unpackExpectedTypeVarTuple": "預期 TypeVarTuple 或 tuple 作為 Unpack 的類型引數",
        "unpackExpectedTypedDict": "應為 Unpack 的 TypedDict 型別引數",
        "unpackIllegalInComprehension": "Comprehension 中不允許解壓縮作業",
        "unpackInAnnotation": "類型運算式中不允許解壓縮運算子",
        "unpackInDict": "字典中不允許解壓縮作業",
        "unpackInSet": "Unpack operator not allowed within a set",
        "unpackNotAllowed": "此內容中不允許 Unpack",
        "unpackOperatorNotAllowed": "此內容中不允許解壓縮作業",
        "unpackTuplesIllegal": "Python 3.8 之前的 Tuple 中不允許解壓縮作業",
        "unpackedArgInTypeArgument": "無法在此內容中使用未封裝的引數",
        "unpackedArgWithVariadicParam": "未封裝的引數無法用於 TypeVarTuple 參數",
        "unpackedDictArgumentNotMapping": "** 後的引數運算式必須是具有 \"str\" 金鑰類型的對應",
        "unpackedDictSubscriptIllegal": "字典解壓縮運算子在下標中不被允許",
        "unpackedSubscriptIllegal": "下標中的解壓縮運算子需要 Python 3.11 或更新版本",
        "unpackedTypeVarTupleExpected": "預期為解壓縮的 TypeVarTuple; 使用 Unpack[{name1}] 或 *{name2}",
        "unpackedTypedDictArgument": "無法比對解壓縮的 TypedDict 引數與參數",
        "unreachableCode": "無法連線到程式碼",
        "unreachableCodeType": "類型分析指出程式碼無法連線",
        "unreachableExcept": "無法連接 Except 子句，因為例外已處理",
        "unsupportedDunderAllOperation": "不支援 \"__all__\" 上的作業，因此匯出的符號清單可能不正確",
        "unusedCallResult": "呼叫運算式的結果是 \"{type}\" 型別，而且未使用; 如果這是刻意的，則指派給變數 \"_\"",
        "unusedCoroutine": "未使用 async 函式呼叫的結果; 使用 \"await\" 或指派結果至變數",
        "unusedExpression": "未使用運算式值",
        "varAnnotationIllegal": "變數的 type 註釋需要 Python 3.6 或更新版本; 使用類型註解以獲得與先前版本的相容性",
        "variableFinalOverride": "變數 \"{name}\" 標示為 Final，且會覆寫類別 \"{className}\" 中相同名稱的非 Final 變數",
        "variadicTypeArgsTooMany": "類型引數清單最多只能有一個解壓縮的 TypeVarTuple 或 tuple",
        "variadicTypeParamTooManyAlias": "類型別名最多只能有一個 TypeVarTuple 類型參數，但收到多個 ({names})",
        "variadicTypeParamTooManyClass": "一般類別最多只能有一個 TypeVarTuple 類型參數，但收到多個 ({names})",
        "walrusIllegal": "運算子 \":=\" 需要 Python 3.8 或更新版本",
        "walrusNotAllowed": "此內容中不允許未使用括弧括住的運算子 \":=\"",
        "wildcardInFunction": "類別或函式內不允許萬用字元 import",
        "wildcardLibraryImport": "不允許從程式庫 import 萬用字元",
        "wildcardPatternTypePartiallyUnknown": "萬用字元模式擷取的類型部分未知",
        "wildcardPatternTypeUnknown": "萬用字元模式擷取的型別不明",
        "yieldFromIllegal": "使用 \"yield from\" 需要 Python 3.3 或更新版本",
        "yieldFromOutsideAsync": "\"yield from\" not allowed in an async function",
        "yieldOutsideFunction": "在函式或 lambda 外部不允許 \"yield\"",
        "yieldWithinComprehension": "Comprehension 內不允許 \"yield\"",
        "zeroCaseStatementsFound": "Match 陳述式必須至少包含一個 case 陳述式",
        "zeroLengthTupleNotAllowed": "此內容中不允許零長度 tuple"
    },
    "DiagnosticAddendum": {
        "annotatedNotAllowed": "[Annotated] 特殊表單不可與執行個體和類別檢查一起使用",
        "argParam": "引數對應至參數 \"{paramName}\"",
        "argParamFunction": "引數對應至函式 \"{functionName}\" 中的參數 \"{paramName}\"",
        "argsParamMissing": "參數 \"*{paramName}\" 沒有對應的參數",
        "argsPositionOnly": "僅限位置的參數不符; 應為 {expected}，但收到 {received}",
        "argumentType": "引數類型為 \"{type}\"",
        "argumentTypes": "引數型別: ({types})",
        "assignToNone": "型別無法指派給「None」",
        "asyncHelp": "您是指 \"async with\" 嗎?",
        "baseClassIncompatible": "基底類別 \"{baseClass}\" 與類型 \"{type}\" 不相容",
        "baseClassIncompatibleSubclass": "基底類別 \"{baseClass}\" 衍生自與類型 \"{type}\" 不相容的 \"{subclass}\"",
        "baseClassOverriddenType": "基底類別 \"{baseClass}\" 提供類型 \"{type}\"，其已覆寫",
        "baseClassOverridesType": "基底類別 \"{baseClass}\" 以型別 \"{type}\" 來覆寫",
        "bytesTypePromotions": "將 disableBytesTypePromotions 設定為 false，以啟用「bytearray」和「memoryview」的類型升級行為",
        "conditionalRequiresBool": "類型 \"{operandType}\" 的方法 __bool__ 傳回類型 \"{boolReturnType}\" 而非 \"bool\"",
        "dataClassFieldLocation": "欄位宣告",
        "dataClassFrozen": "\"{name}\" 已凍結",
        "dataProtocolUnsupported": "\"{name}\" 是個資料通訊協定",
        "descriptorAccessBindingFailed": "無法為描述項類別 \"{className}\" 繫結方法 \"{name}\"",
        "descriptorAccessCallFailed": "無法呼叫描述項類別 \"{className}\" 的方法 \"{name}\"",
        "finalMethod": "Final 方法",
        "functionParamDefaultMissing": "參數 \"{name}\" 遺漏了預設引數",
        "functionParamName": "參數名稱不符: \"{destName}\" 與 \"{srcName}\"",
        "functionParamPositionOnly": "僅位置參數不符；參數 \"{name}\" 不是僅限位置",
        "functionReturnTypeMismatch": "函式傳回型別 \"{sourceType}\" 與型別 \"{destType}\" 不相容",
        "functionTooFewParams": "函式接受太少位置參數; 預期 {expected}，但收到 {received}",
        "functionTooManyParams": "函式接受太多位置參數; 預期 {expected}，但收到 {received}",
        "genericClassNotAllowed": "執行個體或類別檢查不允許具有類型引數的泛型類型",
        "incompatibleDeleter": "Property deleter 方法不相容",
        "incompatibleGetter": "Property getter 方法不相容",
        "incompatibleSetter": "Property setter 方法不相容",
        "initMethodLocation": "__init__ 方法於類別 \"{type}\" 中定義",
        "initMethodSignature": "__init__ 的簽章為 \"{type}\"",
        "initSubclassLocation": "__init_subclass__ 方法已於類別 \"{name}\" 中定義",
        "invariantSuggestionDict": "請考慮從「dict」切換到實值型別中共變數的「Mapping」",
        "invariantSuggestionList": "請考慮從共變數的「list」切換到「Sequence」",
        "invariantSuggestionSet": "考慮從 “set”切換到共同變數 “Container”",
        "isinstanceClassNotSupported": "執行個體和類別檢查不支援 \"{type}\"",
        "keyNotRequired": "\"{name}\" 在 \"{type}\" 中不是必要的索引鍵，因此存取可能會導致執行階段例外狀況",
        "keyReadOnly": "\"{name}\" 是 \"{type}\" 中的唯讀金鑰",
        "keyRequiredDeleted": "\"{name}\" 是必要的金鑰，因此不能刪除",
        "keyUndefined": "\"{name}\" 不是 \"{type}\" 中定義的金鑰",
        "kwargsParamMissing": "參數 \"**{paramName}\" 沒有對應的參數",
        "listAssignmentMismatch": "類型 \"{type}\" 與目標清單不相容",
        "literalAssignmentMismatch": "\"{sourceType}\" 無法指派給型別 \"{destType}\"",
        "matchIsNotExhaustiveHint": "如果不需要徹底處理，請新增 \"case _: pass\"",
        "matchIsNotExhaustiveType": "未處理的類型: \"{type}\"",
        "memberAssignment": "無法將型別 \"{type}\" 的運算式指派給類別 \"{classType}\" 的屬性 \"{name}\"",
        "memberIsAbstract": "\"{type}.{name}\" 未實作",
        "memberIsAbstractMore": "和其他 {count} 人...",
        "memberIsClassVarInProtocol": "\"{name}\" 定義為通訊協定中的 ClassVar",
        "memberIsInitVar": "\"{name}\" 是 init-only 的欄位",
        "memberIsInvariant": "\"{name}\" 為不變數，因為它可變動",
        "memberIsNotClassVarInClass": "\"{name}\" 必須定義為 ClassVar，才能與通訊協定相容",
        "memberIsNotClassVarInProtocol": "\"{name}\" 未定義為通訊協定中的 ClassVar",
        "memberIsNotReadOnlyInProtocol": "通訊協定中的 “{name}” 不是唯讀的",
        "memberIsReadOnlyInProtocol": "通訊協定中的 “{name}” 是唯讀的",
        "memberIsWritableInProtocol": "\"{name}\" 在通訊協定中是可寫入的",
        "memberSetClassVar": "無法透過類別執行個體指派屬性 \"{name}\"，因為它是 ClassVar",
        "memberTypeMismatch": "\"{name}\" 是不相容的類型",
        "memberUnknown": "屬性 \"{name}\" 不明",
        "metaclassConflict": "Metaclass「{metaclass1}」與「{metaclass2}」衝突",
        "missingDeleter": "Property deleter 方法遺失",
        "missingGetter": "Property getter 方法遺失",
        "missingSetter": "遺漏了 property setter 方法",
        "namedParamMissingInDest": "額外參數 \"{name}\"",
        "namedParamMissingInSource": "遺失關鍵詞參數 \"{name}\"",
        "namedParamTypeMismatch": "類型 \"{sourceType}\" 的關鍵字參數 \"{name}\" 與類型 \"{destType}\" 不相容",
        "namedTupleNotAllowed": "執行個體或類別檢查無法使用 NamedTuple",
        "newMethodLocation": "__new__ 方法於類別 \"{type}\" 中定義",
        "newMethodSignature": "__new__ 的簽章為 \"{type}\"",
        "newTypeClassNotAllowed": "使用 NewType 建立的類別不能與執行個體和類別檢查一起使用",
        "noOverloadAssignable": "沒有任何多載函式符合類型 \"{type}\"",
        "noneNotAllowed": "無法對執行個體或類別檢查使用 None",
        "orPatternMissingName": "遺失名稱: {name}",
        "overloadIndex": "多載 {index} 是最接近的相符項目",
        "overloadNotAssignable": "\"{name}\" 的一或多個多載無法指派",
        "overloadSignature": "多載簽章在這裡定義",
        "overriddenMethod": "覆寫方法",
        "overriddenSymbol": "覆寫的符號",
        "overrideInvariantMismatch": "覆寫類型 \"{overrideType}\" 與基底類型 \"{baseType}\" 不同",
        "overrideIsInvariant": "變數是可變動的，所以其類型是不變的",
        "overrideNoOverloadMatches": "覆寫中沒有任何多載簽章與基底方法相容",
        "overrideNotClassMethod": "基底方法宣告為 classmethod，但無法覆寫",
        "overrideNotInstanceMethod": "基底方法已宣告為執行個體方法，但無法覆寫",
        "overrideNotStaticMethod": "基底方法宣告為 staticmethod，但無法覆寫",
        "overrideOverloadNoMatch": "覆寫未處理基底方法的所有多載",
        "overrideOverloadOrder": "覆寫方法的多載必須與基底方法的順序相同",
        "overrideParamKeywordNoDefault": "關鍵字參數 \"{name}\" 不相符: 基底參數有預設引數值，覆寫參數則否",
        "overrideParamKeywordType": "關鍵字參數 \"{name}\" 型別不符: 基底參數為型別 \"{baseType}\"，覆寫參數為型別 \"{overrideType}\"",
        "overrideParamName": "參數 {index} 名稱不符: 基底參數名為 \"{baseName}\"，覆寫參數名為 \"{overrideName}\"",
        "overrideParamNameExtra": "基底中遺失參數 \"{name}\"",
        "overrideParamNameMissing": "覆寫中遺漏了參數 \"{name}\"",
        "overrideParamNamePositionOnly": "參數 {index} 不符: 基底參數 \"{baseName}\" 為關鍵字參數，覆寫參數為 \"position-only\"",
        "overrideParamNoDefault": "參數 {index} 不相符: 基底參數有預設引數值，覆寫參數則否",
        "overrideParamType": "參數 \"{index}\" 型別不符: 基底參數為型別 \"{baseType}\"，覆寫參數為型別 \"{overrideType}\"",
        "overridePositionalParamCount": "位置參數計數不相符; 基底方法有 {baseCount} 個，但覆寫有 {overrideCount} 個",
        "overrideReturnType": "傳回類型不符: 基底方法會傳回類型 \"{baseType}\"，覆寫會傳回類型 \"{overrideType}\"",
        "overrideType": "基底類別會將類型定義為 \"{type}\"",
        "paramAssignment": "參數 {index}: 類型 \"{sourceType}\" 與類型 \"{destType}\" 不相容",
        "paramSpecMissingInOverride": "覆寫方法中遺漏了 ParamSpec 參數",
        "paramType": "參數類型為 \"{paramType}\"",
        "privateImportFromPyTypedSource": "改為從 \"{module}\" 匯入",
        "propertyAccessFromProtocolClass": "通訊協定類別中定義的屬性無法存取為類別變數",
        "propertyMethodIncompatible": "Property 方法 \"{name}\" 不相容",
        "propertyMethodMissing": "覆寫中遺漏了 property 方法 \"{name}\"",
        "propertyMissingDeleter": "Property \"{name}\" 沒有定義的 deleter",
        "propertyMissingSetter": "Property \"{name}\" 沒有定義的 setter",
        "protocolIncompatible": "\"{sourceType}\" 與通訊協定 \"{destType}\" 不相容",
        "protocolMemberMissing": "\"{name}\" 不存在",
        "protocolRequiresRuntimeCheckable": "Protocol 類別必須為 @runtime_checkable，才能搭配執行個體和類別檢查使用",
        "protocolSourceIsNotConcrete": "\"{sourceType}\" 不是實體類別型別，因此無法指派給型別 \"{destType}\"",
        "protocolUnsafeOverlap": "\"{name}\" 的屬性與通訊協定的名稱相同",
        "pyrightCommentIgnoreTip": "使用 \"# pyright: ignore[<diagnostic rules>]\" 來隱藏單行的診斷",
        "readOnlyAttribute": "屬性 \"{name}\" 為唯讀",
        "seeClassDeclaration": "請參閱類別宣告",
        "seeDeclaration": "請參閱宣告",
        "seeFunctionDeclaration": "請參閱函式宣告",
        "seeMethodDeclaration": "請參閱方法宣告",
        "seeParameterDeclaration": "請參閱參數宣告",
        "seeTypeAliasDeclaration": "請參閱類型別名宣告",
        "seeVariableDeclaration": "請參閱變數宣告",
        "tupleAssignmentMismatch": "型別 \"{type}\" 與目標 tuple 不相容",
        "tupleEntryTypeMismatch": "Tuple 項目 {entry} 的類型不正確",
        "tupleSizeIndeterminateSrc": "Tuple 大小不符; 預期為 {expected}，但收到不確定的大小",
        "tupleSizeIndeterminateSrcDest": "Tuple 大小不符; 預期為 {expected} 或其他，但收到不確定的大小",
        "tupleSizeMismatch": "Tuple 大小不符; 預期為 {expected}，但收到 {received}",
        "tupleSizeMismatchIndeterminateDest": "Tuple 大小不符; 預期為 {expected} 或其他，但收到 {received}",
        "typeAliasInstanceCheck": "使用 \"type\" 陳述式建立的類型別名不能搭配執行個體和類別檢查使用",
        "typeAssignmentMismatch": "型別 \"{sourceType}\" 無法指派給型別 \"{destType}\"",
        "typeBound": "型別 \"{sourceType}\" 無法指派給型別變數 \"{name}\" 的上限 \"{destType}\"",
        "typeConstrainedTypeVar": "型別 \"{type}\" 無法指派給限制型別變數 \"{name}\"",
        "typeIncompatible": "\"{sourceType}\" 無法指派給 \"{destType}\"",
        "typeNotClass": "\"{type}\" 不是類別",
        "typeNotStringLiteral": "\"{type}\" 不是字串常值",
        "typeOfSymbol": "\"{name}\" 的型別為 \"{type}\"",
        "typeParamSpec": "類型 \"{type}\" 與 ParamSpec \"{name}\" 不相容",
        "typeUnsupported": "類型 \"{type}\" 不受支援",
        "typeVarDefaultOutOfScope": "類型變數 \"{name}\" 不在範圍內",
        "typeVarIsContravariant": "型別參數 \"{name}\" 具有反變性，但 \"{sourceType}\" 不是 \"{destType}\" 的超型別",
        "typeVarIsCovariant": "型別參數 \"{name}\" 具有共變性，但 \"{sourceType}\" 不是 \"{destType}\" 的子型別",
        "typeVarIsInvariant": "型別參數 \"{name}\" 具有不變性，但 \"{sourceType}\" 與 \"{destType}\" 不同",
        "typeVarNotAllowed": "執行個體或類別檢查不允許 TypeVar",
        "typeVarTupleRequiresKnownLength": "TypeVarTuple 無法繫結至長度不明的 tuple",
        "typeVarUnnecessarySuggestion": "改用 {type}",
        "typeVarUnsolvableRemedy": "提供多載，其指定未提供引數時的傳回類型",
        "typeVarsMissing": "遺失類型變數: {names}",
        "typedDictBaseClass": "類別 \"{type}\" 不是 TypedDict",
        "typedDictClassNotAllowed": "執行個體或類別檢查不允許 TypedDict 類別",
        "typedDictClosedExtraNotAllowed": "無法新增項目 \"{name}\"",
        "typedDictClosedExtraTypeMismatch": "無法新增型別為 \"{type}\" 的項目 \"{name}\"",
        "typedDictClosedFieldNotRequired": "無法新增項目 \"{name}\"，因為它必須是 NotRequired",
        "typedDictExtraFieldNotAllowed": "\"{name}\" 不存在於 \"{type}\"",
        "typedDictExtraFieldTypeMismatch": "\"{name}\" 的類型與 \"{type}\" 中 \"extra_items\" 的類型不相容",
        "typedDictFieldMissing": "\"{type}\" 遺失 \"{name}\"",
        "typedDictFieldNotReadOnly": "\"{name}\" 在 \"{type}\" 中不是唯讀",
        "typedDictFieldNotRequired": "\"{type}\" 中不需要 \"{name}\"",
        "typedDictFieldRequired": "\"{type}\" 中需要 \"{name}\"",
        "typedDictFieldTypeMismatch": "型別 \"{type}\" 無法指派給項目 \"{name}\"",
        "typedDictFieldUndefined": "\"{name}\" 是型別 \"{type}\" 中未定義的項目",
        "typedDictFinalMismatch": "\"{sourceType}\" 與 \"{destType}\" 不相容，因為@final 不符",
        "typedDictKeyAccess": "使用 [\"{name}\"] 參考 TypedDict 中的項目",
        "typedDictNotAllowed": "執行個體或類別檢查無法使用 TypedDict",
        "unhashableType": "型別 \"{type}\" 無法雜湊",
        "uninitializedAbstractVariable": "執行個體變數 \"{name}\" 在抽象基底類別 \"{classType}\" 中定義，但未初始化",
        "unreachableExcept": "\"{exceptionType}\" 是 \"{parentType}\" 的子類別",
        "useDictInstead": "使用 dict[T1, T2] 來表示字典類型",
        "useListInstead": "使用 list[T] 來指出 list 類型，或使用 T1 | T2 來指出 union 類型",
        "useTupleInstead": "使用 tuple[T1, ..., Tn] 來指出 tuple 類型，或使用 T1 | T2 來指出 union 類型",
        "useTypeInstead": "改為使用 type[T]",
        "varianceMismatchForClass": "型別引數 \"{typeVarName}\" 的變異數與基底類別 \"{className}\" 不相容",
        "varianceMismatchForTypeAlias": "型別引數 \"{typeVarName}\" 的變異數與 \"{typeAliasParam}\" 不相容"
    },
    "Service": {
        "longOperation": "列舉工作區來源檔案需要很長的時間。請考慮改為開啟子資料夾。[深入了解](https://aka.ms/workspace-too-many-files)"
    }
}
