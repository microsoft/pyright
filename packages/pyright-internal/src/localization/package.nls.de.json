{
    "CodeAction": {
        "addOptionalToAnnotation": "\"Optional\" zur Typanmerkung hinzufügen",
        "createTypeStub": "Typstub erstellen",
        "createTypeStubFor": "Typstub für \"{moduleName}\" erstellen",
        "executingCommand": "Der Befehl wird ausgeführt.",
        "filesToAnalyzeCount": "{count} Dateien zu analysieren",
        "filesToAnalyzeOne": "1 zu analysierende Datei",
        "findingReferences": "Verweise werden gesucht",
        "organizeImports": "Import-Direktiven organisieren",
        "renameShadowedFile": "\"{oldFile}\" in \"{newFile}\" umbenennen"
    },
    "Diagnostic": {
        "abstractMethodInvocation": "Die Methode \"{method}\" kann nicht aufgerufen werden, da sie abstrakt ist.",
        "annotatedParamCountMismatch": "Nicht übereinstimmende Parameteranmerkungsanzahl: {expected} erwartet, aber {received} empfangen",
        "annotatedTypeArgMissing": "Es wurde ein Typargument und mindestens eine Anmerkung für \"Annotated\" erwartet.",
        "annotationFormatString": "Typanmerkungen können keine Formatzeichenfolgenliterale (f-strings) verwenden.",
        "annotationNotSupported": "Typanmerkung wird für diese Anweisung nicht unterstützt.",
        "annotationSpansStrings": "Typanmerkungen dürfen nicht mehrere Zeichenfolgenliterale umfassen.",
        "annotationStringEscape": "Typanmerkungen dürfen keine Escapezeichen enthalten.",
        "argAssignment": "Ein Argument vom Typ \"{argType}\" kann dem Parameter vom Typ \"{paramType}\" nicht zugewiesen werden.",
        "argAssignmentFunction": "Ein Argument vom Typ \"{argType}\" kann dem Parameter vom Typ \"{paramType}\" in der Funktion \"{functionName}\" nicht zugewiesen werden.",
        "argAssignmentParam": "Ein Argument vom Typ \"{argType}\" kann dem Parameter \"{paramName}\" vom Typ \"{paramType}\" nicht zugewiesen werden.",
        "argAssignmentParamFunction": "Ein Argument vom Typ \"{argType}\" kann dem Parameter \"{paramName}\" vom Typ \"{paramType}\" in der Funktion \"{functionName}\" nicht zugewiesen werden.",
        "argMissingForParam": "Für Parameter {name} fehlt ein Argument.",
        "argMissingForParams": "Fehlende Argumente für die Parameter {names}",
        "argMorePositionalExpectedCount": "Es wurden {expected} weitere Positionsargumente erwartet.",
        "argMorePositionalExpectedOne": "Es wurde 1 weiteres Positionsargument erwartet.",
        "argPositional": "Positionsargument erwartet",
        "argPositionalExpectedCount": "Es wurden {expected} Positionsargumente erwartet.",
        "argPositionalExpectedOne": "Es wurde 1 Positionsargument erwartet.",
        "argTypePartiallyUnknown": "Der Argumenttyp ist teilweise unbekannt",
        "argTypeUnknown": "Argumenttyp ist unbekannt",
        "assertAlwaysTrue": "Assertausdruck wird immer als True ausgewertet.",
        "assertTypeArgs": "\"assert_type\" erwartet zwei Positionsargumente.",
        "assertTypeTypeMismatch": "\"assert_type\" Konflikt: \"{expected}\" erwartet, aber \"{received}\" empfangen",
        "assignmentExprComprehension": "Ziel des Zuweisungsausdrucks \"{name}\" kann nicht denselben Namen wie das Verständnis für das Ziel verwenden.",
        "assignmentExprContext": "Der Zuweisungsausdruck muss sich innerhalb des Moduls, der Funktion oder der Lambdafunktion befinden.",
        "assignmentExprInSubscript": "Zuweisungsausdrücke innerhalb eines Tiefgestellten werden nur in Python 3.10 und höher unterstützt.",
        "assignmentInProtocol": "Instanzen- oder Klassenvariablen innerhalb einer Protokollklasse müssen explizit innerhalb des Klassentexts deklariert werden.",
        "assignmentTargetExpr": "Der Ausdruck kann kein Zuweisungsziel sein.",
        "asyncNotInAsyncFunction": "Die Verwendung von \"async\" ist außerhalb einer asynchronen Funktion nicht zulässig.",
        "awaitIllegal": "Die Verwendung von \"await\" erfordert Python 3.5 oder höher.",
        "awaitNotInAsync": "\"await\" ist nur innerhalb einer asynchronen Funktion zulässig.",
        "backticksIllegal": "Ausdrücke, die von Backticks umgeben sind, werden in Python 3.x nicht unterstützt; verwenden Sie stattdessen repr",
        "baseClassCircular": "Die Klasse kann nicht von sich selbst abgeleitet werden.",
        "baseClassFinal": "Die Basisklasse \"{type}\" ist als final gekennzeichnet und kann nicht als Unterklasse verwendet werden.",
        "baseClassInvalid": "Das Argument für die Klasse muss eine Basisklasse sein.",
        "baseClassMethodTypeIncompatible": "Basisklassen für die Klasse \"{classType}\" definieren die Methode \"{name}\" auf inkompatible Weise.",
        "baseClassUnknown": "Der Basisklassentyp ist unbekannt, sodass der Typ der abgeleiteten Klasse verdeckt wird.",
        "baseClassVariableTypeIncompatible": "Basisklassen für die Klasse \"{classType}\" definieren die Variable \"{name}\" auf inkompatible Weise.",
        "bindTypeMismatch": "Die Methode \"{methodName}\" konnte nicht gebunden werden, da \"{type}\" dem Parameter \"{paramName}\" nicht zugewiesen werden kann.",
        "breakOutsideLoop": "\"break\" kann nur innerhalb einer Schleife verwendet werden.",
        "callableExtraArgs": "Es wurden nur zwei Typargumente für \"Callable\" erwartet.",
        "callableFirstArg": "Parametertypliste oder \"...\" erwartet.",
        "callableNotInstantiable": "Der Typ \"{type}\" kann nicht instanziiert werden.",
        "callableSecondArg": "Rückgabetyp als zweites Typargument für \"Callable\" erwartet",
        "casePatternIsIrrefutable": "Ein unwiderlegbares Muster ist nur für die letzte case-Anweisung zulässig.",
        "classAlreadySpecialized": "Der Typ \"{type}\" ist bereits spezialisiert.",
        "classDecoratorTypeUnknown": "Der nicht typisierte Klassendekorator verdeckt den Typ der Klasse; Decorator wird ignoriert.",
        "classDefinitionCycle": "Die Klassendefinition für \"{name}\" hängt von sich selbst ab.",
        "classGetItemClsParam": "__class_getitem__ Außerkraftsetzung sollte einen \"cls\"-Parameter annehmen.",
        "classMethodClsParam": "Klassenmethoden sollten einen \"cls\"-Parameter verwenden.",
        "classNotRuntimeSubscriptable": "Durch das Tiefstellungsskript für die Klasse \"{name}\" wird eine Laufzeitausnahme generiert; schließen Sie die Typanmerkung in Anführungszeichen ein",
        "classPatternBuiltInArgCount": "Das Klassenmuster akzeptiert höchstens 1 positionsbezogenes Untermuster.",
        "classPatternBuiltInArgPositional": "Das Klassenmuster akzeptiert nur positionsbezogenes Untermuster.",
        "classPatternTypeAlias": "\"{type}\" kann nicht in einem Klassenmuster verwendet werden, da es sich um einen spezialisierten Typalias handelt.",
        "classTypeParametersIllegal": "Die Syntax des Klassentypparameters erfordert Python 3.12 oder höher.",
        "classVarFirstArgMissing": "Nach \"ClassVar\" wurde ein Typargument erwartet.",
        "classVarNotAllowed": "\"ClassVar\" ist in diesem Kontext nicht zulässig.",
        "classVarOverridesInstanceVar": "Die Klassenvariable \"{name}\" überschreibt die Instanzvariable desselben Namens in der Klasse \"{className}\"",
        "classVarTooManyArgs": "Nach \"ClassVar\" wird ein Typargument erwartet.",
        "classVarWithTypeVar": "Der Typ \"ClassVar\" darf keine Typvariablen enthalten.",
        "clsSelfParamTypeMismatch": "Der Typ des Parameters \"{name}\" muss ein Obertyp seiner Klasse \"{classType}\" sein",
        "codeTooComplexToAnalyze": "Der Code ist zu komplex für die Analyse; verringern Sie die Komplexität durch Refactoring in Unterroutinen oder durch Reduzieren bedingter Codepfade",
        "collectionAliasInstantiation": "Der Typ \"{type}\" kann nicht instanziiert werden, verwenden Sie stattdessen \"{alias}\".",
        "comparisonAlwaysFalse": "Die Bedingung wird immer als False ausgewertet, da die Typen \"{leftType}\" und \"{rightType}\" keine Überlappung aufweisen.",
        "comparisonAlwaysTrue": "Die Bedingung wird immer als True ausgewertet, da die Typen \"{leftType}\" und \"{rightType}\" keine Überlappung aufweisen.",
        "comprehensionInDict": "Verständnis kann nicht mit anderen Wörterbucheinträgen verwendet werden.",
        "comprehensionInSet": "Verständnis kann nicht mit anderen Satzeinträgen verwendet werden.",
        "concatenateParamSpecMissing": "Das letzte Typargument für \"Concatenate\" muss ein ParamSpec sein.",
        "concatenateTypeArgsMissing": "\"Verketten\" erfordert mindestens zwei Typargumente.",
        "conditionalOperandInvalid": "Ungültiger bedingter Operand vom Typ \"{type}\"",
        "constantRedefinition": "\"{name}\" ist konstant (da es sich um Großbuchstaben handelt) und kann nicht neu definiert werden.",
        "constructorNoArgs": "Es wurden keine Argumente für \"{type}\" Konstruktor erwartet.",
        "constructorParametersMismatch": "Keine Übereinstimmung zwischen der Signatur von __new__ und __init__ in der Klasse \"{classType}\"",
        "containmentAlwaysFalse": "Der Ausdruck wird immer als False ausgewertet, da die Typen \"{leftType}\" und \"{rightType}\" keine Überlappung aufweisen.",
        "containmentAlwaysTrue": "Der Ausdruck wird immer als True ausgewertet, da die Typen \"{leftType}\" und \"{rightType}\" keine Überlappung aufweisen.",
        "continueInFinally": "\"continue\" kann nicht innerhalb einer finally-Klausel verwendet werden.",
        "continueOutsideLoop": "\"continue\" kann nur innerhalb einer Schleife verwendet werden.",
        "dataClassBaseClassFrozen": "Eine nicht fixierte Klasse kann nicht von einer fixierten Klasse erben.",
        "dataClassBaseClassNotFrozen": "Eine fixierte Klasse kann nicht von einer nicht fixierten Klasse erben.",
        "dataClassConverterFunction": "Das Argument vom Typ \"{argType}\" ist kein gültiger Konverter für das Feld \"{fieldName}\" vom Typ \"{fieldType}\"",
        "dataClassConverterOverloads": "Keine Überladungen von \"{funcName}\" sind gültige Konverter für das Feld \"{fieldName}\" vom Typ \"{fieldType}\"",
        "dataClassFieldWithDefault": "Felder ohne Standardwerte dürfen nicht nach Feldern mit Standardwerten angezeigt werden.",
        "dataClassFieldWithPrivateName": "Das Feld \"Dataclass\" kann keinen privaten Namen verwenden.",
        "dataClassFieldWithoutAnnotation": "Datenklassenfeld ohne Typanmerkung verursacht eine Laufzeitausnahme",
        "dataClassPostInitParamCount": "Dataclass __post_init__ falsche Parameteranzahl; Anzahl von InitVar-Feldern ist {expected}",
        "dataClassPostInitType": "Dataclass __post_init__ Methodenparametertypkonflikt für Feld \"{fieldName}\"",
        "dataClassSlotsOverwrite": "__slots__ ist bereits in der Klasse definiert.",
        "dataClassTransformExpectedBoolLiteral": "Es wurde ein Ausdruck erwartet, der statisch als True oder False ausgewertet wird.",
        "dataClassTransformFieldSpecifier": "Es wurde ein Tupel von Klassen oder Funktionen erwartet, es wurde jedoch der Typ \"{type}\" empfangen",
        "dataClassTransformPositionalParam": "Alle Argumente für \"dataclass_transform\" müssen Schlüsselwortargumente sein.",
        "dataClassTransformUnknownArgument": "Argument \"{name}\" wird von dataclass_transform nicht unterstützt.",
        "declaredReturnTypePartiallyUnknown": "Der deklarierte Rückgabetyp \"{returnType}\" ist teilweise unbekannt.",
        "declaredReturnTypeUnknown": "Unbekannter Rückgabetyp deklariert",
        "defaultValueContainsCall": "Funktionsaufrufe und änderbare Objekte sind innerhalb des Parameterstandardwertausdrucks nicht zulässig.",
        "defaultValueNotAllowed": "Ein Parameter mit \"*\" oder \"**\" darf keinen Standardwert aufweisen.",
        "delTargetExpr": "Der Ausdruck kann nicht gelöscht werden",
        "deprecatedClass": "Die Klasse \"{name}\" ist veraltet.",
        "deprecatedConstructor": "Der Konstruktor für die Klasse \"{name}\" ist veraltet.",
        "deprecatedFunction": "Die Funktion \"{name}\" ist veraltet.",
        "deprecatedType": "Dieser Typ ist ab python-{version} veraltet; verwenden Sie stattdessen \"{replacement}\"",
        "dictExpandIllegalInComprehension": "Wörterbucherweiterung ist im Verständnis nicht zulässig.",
        "dictInAnnotation": "Ein Wörterbuchausdruck ist in der Typanmerkung nicht zulässig.",
        "dictKeyValuePairs": "Wörterbucheinträge müssen Schlüssel-Wert-Paare enthalten.",
        "dictUnpackIsNotMapping": "Es wird eine Zuordnung für den Operator zum Entpacken des Wörterbuchs erwartet.",
        "dunderAllSymbolNotPresent": "\"{name}\" ist in __all__ angegeben, aber nicht im Modul vorhanden.",
        "duplicateArgsParam": "Es ist nur ein \"*\"-Parameter zulässig.",
        "duplicateBaseClass": "Doppelte Basisklasse nicht zulässig",
        "duplicateCapturePatternTarget": "\"{name}\" des Erfassungsziels darf nicht mehrmals innerhalb desselben Musters vorkommen.",
        "duplicateCatchAll": "Es ist nur eine catch-all except-Klausel zulässig.",
        "duplicateEnumMember": "Der Enumerationsmember \"{name}\" wurde bereits deklariert.",
        "duplicateGenericAndProtocolBase": "Es ist nur eine Generic[...]- oder ein Protocol[...]-Basisklasse zulässig.",
        "duplicateImport": "\"{importName}\" wurde mehrmals importiert.",
        "duplicateKeywordOnly": "Es ist nur ein \"*\"-Trennzeichen zulässig.",
        "duplicateKwargsParam": "Es ist nur ein \"**\"-Parameter zulässig.",
        "duplicateParam": "Doppelter Parameter \"{name}\"",
        "duplicatePositionOnly": "Es ist nur ein \"/\"-Parameter zulässig.",
        "duplicateStarPattern": "In einer Mustersequenz ist nur ein \"*\"-Muster zulässig.",
        "duplicateStarStarPattern": "Es ist nur ein \"**\"-Eintrag zulässig.",
        "duplicateUnpack": "In der Liste ist nur ein Vorgang zum Entpacken zulässig.",
        "ellipsisContext": "\"...\" ist in diesem Kontext nicht zulässig.",
        "ellipsisSecondArg": "\"...\" nur als zweites von zwei Argumenten zulässig",
        "enumClassOverride": "Die Enumerationsklasse \"{name}\" ist final und kann nicht in eine Unterklasse aufgenommen werden.",
        "exceptionGroupIncompatible": "Die Ausnahmegruppensyntax (\"except*\") erfordert Python 3.11 oder höher.",
        "exceptionTypeIncorrect": "\"{type}\" ist nicht von BaseException abgeleitet.",
        "exceptionTypeNotClass": "\"{type}\" ist keine gültige Ausnahmeklasse.",
        "exceptionTypeNotInstantiable": "Der Konstruktor für den Ausnahmetyp \"{type}\" erfordert mindestens ein Argument.",
        "expectedAfterDecorator": "Es wurde eine Funktions- oder Klassendeklaration nach dem Decorator erwartet.",
        "expectedArrow": "\"->\" gefolgt von Rückgabetypanmerkung erwartet",
        "expectedAsAfterException": "\"as\" nach Ausnahmetyp erwartet",
        "expectedAssignRightHandExpr": "Ausdruck rechts von \"=\" erwartet",
        "expectedBinaryRightHandExpr": "Ausdruck rechts vom Operator",
        "expectedBoolLiteral": "\"True\" oder \"False\" erwartet",
        "expectedCase": "\"case\"-Anweisung erwartet",
        "expectedClassName": "Klassenname erwartet",
        "expectedCloseBrace": "\"{\" wurde nicht geschlossen.",
        "expectedCloseBracket": "\"[\" wurde nicht geschlossen.",
        "expectedCloseParen": "\"(\" wurde nicht geschlossen.",
        "expectedColon": "\":\" erwartet",
        "expectedComplexNumberLiteral": "Für den Musterabgleich wurde ein komplexes Zahlenliteral erwartet.",
        "expectedDecoratorExpr": "Das Ausdrucksformular wird für den Decorator vor Python 3.9 nicht unterstützt.",
        "expectedDecoratorName": "Decoratorname erwartet",
        "expectedDecoratorNewline": "Am Ende des Decorators wurde eine neue Zeile erwartet.",
        "expectedDelExpr": "Ausdruck nach \"del\" erwartet",
        "expectedElse": "Unerwartetes \"else\"",
        "expectedEquals": "\"=\" erwartet",
        "expectedExceptionClass": "Ungültige Ausnahmeklasse oder ungültiges Objekt.",
        "expectedExceptionObj": "Ausnahmeobjekt, Ausnahmeklasse oder None erwartet",
        "expectedExpr": "Ausdruck erwartet.",
        "expectedFunctionAfterAsync": "Funktionsdefinition nach \"async\" erwartet",
        "expectedFunctionName": "Funktionsname nach \"def\" erwartet",
        "expectedIdentifier": "Bezeichner erwartet",
        "expectedImport": "\"import\" erwartet",
        "expectedImportAlias": "Symbol nach \"as\" erwartet",
        "expectedImportSymbols": "Nach dem Import wurde mindestens ein Symbolname erwartet.",
        "expectedIn": "\"in\" wurde erwartet.",
        "expectedInExpr": "Ausdruck nach \"in\" erwartet",
        "expectedIndentedBlock": "Eingerückter Block erwartet",
        "expectedMemberName": "Membername nach \".\" erwartet",
        "expectedModuleName": "Modulname erwartet",
        "expectedNameAfterAs": "Symbolname nach \"as\" erwartet",
        "expectedNamedParameter": "Der Schlüsselwortparameter muss auf \"*\" folgen.",
        "expectedNewline": "Zeilenumbruch erwartet",
        "expectedNewlineOrSemicolon": "Anweisungen müssen durch Zeilenumbrüche oder Semikolons getrennt werden.",
        "expectedOpenParen": "\"(\" erwartet",
        "expectedParamName": "Parametername erwartet",
        "expectedPatternExpr": "Musterausdruck erwartet",
        "expectedPatternSubjectExpr": "Musterbetreffausdruck erwartet",
        "expectedPatternValue": "Es wurde ein Musterwertausdruck im Format \"a.b\" erwartet.",
        "expectedReturnExpr": "Ausdruck nach \"return\" erwartet",
        "expectedSliceIndex": "Index- oder Sliceausdruck erwartet",
        "expectedTypeNotString": "Typ erwartet, aber Zeichenfolgenliteral empfangen",
        "expectedTypeParameterName": "Name für Typparameter erwartet",
        "expectedYieldExpr": "Ausdruck in yield-Anweisung erwartet",
        "finalClassIsAbstract": "Die Klasse \"{type}\" ist als final gekennzeichnet und muss alle abstrakten Methoden implementieren.",
        "finalContext": "\"Final\" ist in diesem Kontext nicht zulässig.",
        "finalMethodOverride": "Die Methode \"{name}\" kann die in der Klasse definierte endgültige Methode \"{className}\" nicht überschreiben.",
        "finalReassigned": "\"{name}\" ist als \"Final\" deklariert und kann nicht neu zugewiesen werden.",
        "finalRedeclaration": "\"{name}\" wurde zuvor als \"Final\" deklariert.",
        "finalRedeclarationBySubclass": "\"{name}\" kann nicht neu deklariert werden, da die übergeordnete Klasse \"{className}\" es als Final deklariert.",
        "finalTooManyArgs": "Nach \"Final\" wurde ein einzelnes Typargument erwartet.",
        "finalUnassigned": "\"{name}\" ist als Final deklariert, aber der Wert ist nicht zugewiesen.",
        "formatStringBrace": "Eine einzelne schließende geschweifte Klammer ist innerhalb des f-string-Literals nicht zulässig; verwenden Sie doppelte schließende geschweifte Klammern.",
        "formatStringBytes": "Formatzeichenfolgenliterale (f-strings) dürfen nicht binär sein.",
        "formatStringDebuggingIllegal": "Der F-String-Debugspezifizierer \"=\" erfordert Python 3.8 oder höher.",
        "formatStringEscape": "Escapesequenz (umgekehrter Schrägstrich) ist im Ausdrucksteil der f-Zeichenfolge vor Python 3.12 nicht zulässig.",
        "formatStringExpectedConversion": "Nach \"!\" in f-string wurde ein Konvertierungsspezifizierer erwartet.",
        "formatStringIllegal": "Formatzeichenfolgenliterale (f-strings) erfordern Python 3.6 oder höher.",
        "formatStringInPattern": "Die Formatzeichenfolge ist im Muster nicht zulässig.",
        "formatStringNestedFormatSpecifier": "Ausdrücke sind zu tief im Formatzeichenfolgenspezifizierer geschachtelt.",
        "formatStringNestedQuote": "Zeichenfolgen, die in einer f-Zeichenfolge geschachtelt sind, dürfen nicht dasselbe Anführungszeichen wie die f-Zeichenfolge vor Python 3.12 verwenden.",
        "formatStringUnicode": "Formatzeichenfolgenliterale (f-strings) dürfen nicht Unicode sein.",
        "formatStringUnterminated": "Nicht abgeschlossener Ausdruck in f-string; \"}\" wird erwartet.",
        "functionDecoratorTypeUnknown": "Ein nicht typisierter Funktionsdekorator verdeckt den Funktionstyp; Decorator wird ignoriert.",
        "functionInConditionalExpression": "Bedingter Ausdruck verweist auf eine Funktion, die immer zu \"True\" ausgewertet wird.",
        "functionTypeParametersIllegal": "Die Syntax des Funktionstypparameters erfordert Python 3.12 oder höher.",
        "futureImportLocationNotAllowed": "Importe von __future__ müssen am Anfang der Datei auftreten",
        "generatorAsyncReturnType": "Der Rückgabetyp der asynchronen Generatorfunktion muss mit \"AsyncGenerator[{yieldType}, Any]\" kompatibel sein.",
        "generatorNotParenthesized": "Generatorausdrücke müssen in Klammern gesetzt werden, wenn sie nicht das einzige Argument sind.",
        "generatorSyncReturnType": "Der Rückgabetyp der Generatorfunktion muss mit \"Generator[{yieldType}, Any, Any]\" kompatibel sein.",
        "genericBaseClassNotAllowed": "Die Basisklasse \"Generic\" kann nicht mit der Typparametersyntax verwendet werden.",
        "genericClassAssigned": "Der generische Klassentyp kann nicht zugewiesen werden.",
        "genericClassDeleted": "Der generische Klassentyp kann nicht gelöscht werden.",
        "genericNotAllowed": "\"Generic\" ist in diesem Kontext nicht gültig.",
        "genericTypeAliasBoundTypeVar": "Der generische Typalias innerhalb der Klasse kann keine gebundenen Typvariablen {names} verwenden.",
        "genericTypeArgMissing": "\"Generic\" erfordert mindestens ein Typargument.",
        "genericTypeArgTypeVar": "Das Typargument für \"Generic\" muss eine Typvariable sein.",
        "genericTypeArgUnique": "Typargumente für \"Generic\" müssen eindeutig sein.",
        "globalReassignment": "\"{name}\" wird vor einer globalen Deklaration zugewiesen.",
        "globalRedefinition": "\"{name}\" wurde bereits als global deklariert.",
        "implicitStringConcat": "Implizite Zeichenfolgenverkettung nicht zulässig",
        "importCycleDetected": "Zyklus in Importkette erkannt",
        "importDepthExceeded": "Importkettentiefe überschritten {depth}",
        "importResolveFailure": "Import \"{importName}\" konnte nicht aufgelöst werden.",
        "importSourceResolveFailure": "Import \"{importName}\" konnte aus der Quelle nicht aufgelöst werden.",
        "importSymbolUnknown": "\"{name}\" ist ein unbekanntes Importsymbol.",
        "incompatibleMethodOverride": "Die Methode \"{name}\" überschreibt die Klasse \"{className}\" auf inkompatible Weise.",
        "inconsistentIndent": "Der Betrag für Nichteinzug stimmt nicht mit dem vorherigen Einzug überein.",
        "inconsistentTabs": "Inkonsistente Verwendung von Tabulatoren und Leerzeichen im Einzug.",
        "initMustReturnNone": "Der Rückgabetyp von \"__init__\" muss \"None\" sein.",
        "initSubclassClsParam": "__init_subclass__ Außerkraftsetzung sollte einen \"cls\"-Parameter annehmen.",
        "instanceMethodSelfParam": "Instanzmethoden sollten einen \"self\"-Parameter verwenden.",
        "instanceVarOverridesClassVar": "Die Instanzvariable \"{name}\" überschreibt die Klassenvariable desselben Namens in der Klasse \"{className}\"",
        "instantiateAbstract": "Abstrakte Klasse \"{type}\" kann nicht erstellt werden.",
        "instantiateProtocol": "Die Protokollklasse \"{type}\" kann nicht instanziiert werden.",
        "internalBindError": "Interner Fehler beim Binden der Datei \"{file}\": {message}",
        "internalParseError": "Interner Fehler beim Parsen der Datei \"{file}\": {message}",
        "internalTypeCheckingError": "Interner Fehler bei der Typüberprüfung der Datei \"{file}\": {message}",
        "invalidIdentifierChar": "Ungültiges Zeichen in Bezeichner",
        "invalidStubStatement": "Die Anweisung ist innerhalb einer Typstubdatei bedeutungslos.",
        "invalidTokenChars": "Ungültiges Zeichen \"{text}\" im Token",
        "isInstanceInvalidType": "Das zweite Argument für \"isinstance\" muss eine Klasse oder ein Tupel von Klassen sein.",
        "isSubclassInvalidType": "Das zweite Argument für \"issubclass\" muss eine Klasse oder ein Tupel von Klassen sein.",
        "keyValueInSet": "Schlüssel-Wert-Paare sind innerhalb einer Menge nicht zulässig.",
        "keywordArgInTypeArgument": "Schlüsselwortargumente können nicht in Typargumentlisten verwendet werden.",
        "keywordOnlyAfterArgs": "Schlüsselworttrennzeichen ist nach dem Parameter \"*\" nicht zulässig.",
        "keywordParameterMissing": "Mindestens ein Schlüsselwortparameter muss dem Parameter \"*\" folgen.",
        "keywordSubscriptIllegal": "Schlüsselwortargumente innerhalb von Tiefskripts werden nicht unterstützt.",
        "lambdaReturnTypePartiallyUnknown": "Der Rückgabetyp des Lambdaausdrucks \"{returnType}\" ist teilweise unbekannt.",
        "lambdaReturnTypeUnknown": "Der Rückgabetyp der Lambdafunktion ist unbekannt.",
        "listAssignmentMismatch": "Ein Ausdruck vom Typ \"{type}\" kann der Zielliste nicht zugewiesen werden.",
        "listInAnnotation": "Ein Listenausdruck ist in der Typanmerkung nicht zulässig.",
        "literalEmptyArgs": "Nach \"Literal\" wurde mindestens ein Typargument erwartet.",
        "literalNotCallable": "Der Literaltyp kann nicht instanziiert werden.",
        "literalUnsupportedType": "Typargumente für \"Literal\" müssen None, ein Literalwert (int, bool, str oder bytes) oder ein Enumerationswert sein.",
        "matchIncompatible": "Übereinstimmungsanweisungen erfordern Python 3.10 oder höher",
        "matchIsNotExhaustive": "Fälle innerhalb der match-Anweisung behandeln nicht umfassend alle Werte.",
        "maxParseDepthExceeded": "Maximale Analysetiefe überschritten; brechen Sie den Ausdruck in kleinere Unterausdrücke um",
        "memberAccess": "Auf Member \"{name}\" für Typ \"{type}\" kann nicht zugegriffen werden.",
        "memberDelete": "Member \"{name}\" für Typ \"{type}\" kann nicht gelöscht werden.",
        "memberSet": "Member \"{name}\" für Typ \"{type}\" kann nicht zugewiesen werden.",
        "metaclassConflict": "Die Metaklasse einer abgeleiteten Klasse muss eine Unterklasse der Metaklassen aller ihrer Basisklassen sein.",
        "metaclassDuplicate": "Es kann nur eine Metaklasse angegeben werden.",
        "metaclassIsGeneric": "Metaklasse kann nicht generisch sein.",
        "methodNotDefined": "\"{name}\" Methode nicht definiert",
        "methodNotDefinedOnType": "Die Methode \"{name}\" ist für den Typ \"{type}\" nicht definiert.",
        "methodOrdering": "Es kann keine konsistente Methodenreihenfolge erstellt werden.",
        "methodOverridden": "\"{name}\" überschreibt die Methode mit demselben Namen in der Klasse \"{className}\" mit inkompatiblem Typ \"{type}\"",
        "methodReturnsNonObject": "Die Methode \"{name}\" gibt kein Objekt zurück.",
        "missingProtocolMembers": "Die Klasse ist von mindestens einer Protokollklasse abgeleitet, implementiert jedoch nicht alle erforderlichen Member.",
        "missingSuperCall": "Die Methode \"{methodName}\" ruft nicht die Methode mit demselben Namen in der übergeordneten Klasse auf.",
        "moduleAsType": "Das Modul kann nicht als Typ verwendet werden.",
        "moduleNotCallable": "Das Modul kann nicht aufgerufen werden.",
        "moduleUnknownMember": "\"{memberName}\" ist kein bekanntes Mitglied des Moduls \"{moduleName}\"",
        "namedExceptAfterCatchAll": "Eine benannte except-Klausel darf nicht nach catch-all except-Klausel auftreten.",
        "namedParamAfterParamSpecArgs": "Der Schlüsselwortparameter \"{name}\" kann nicht in der Signatur nach dem Parameter \"ParamSpec args\" verwendet werden.",
        "namedTupleEmptyName": "Namen innerhalb eines benannten Tupels dürfen nicht leer sein.",
        "namedTupleFirstArg": "Es wird ein benannter Tupelklassenname als erstes Argument erwartet.",
        "namedTupleMultipleInheritance": "Mehrfachvererbung mit NamedTuple wird nicht unterstützt.",
        "namedTupleNameKeyword": "Feldnamen dürfen kein Schlüsselwort sein.",
        "namedTupleNameType": "Es wurde ein Tupel mit zwei Einträgen unter Angabe von Eintragsname und -typ erwartet.",
        "namedTupleNameUnique": "Namen innerhalb eines benannten Tupels müssen eindeutig sein.",
        "namedTupleNoTypes": "\"namedtuple\" stellt keine Typen für Tupeleinträge bereit; verwenden Sie stattdessen \"NamedTuple\".",
        "namedTupleSecondArg": "Benannte Tupeleintragsliste als zweites Argument erwartet",
        "newClsParam": "__new__ Außerkraftsetzung sollte einen \"cls\"-Parameter annehmen.",
        "newTypeBadName": "Das erste Argument für NewType muss ein Zeichenfolgenliteral sein.",
        "newTypeLiteral": "\"NewType\" kann nicht mit dem Literaltyp verwendet werden.",
        "newTypeNotAClass": "Klasse als zweites Argument für NewType erwartet",
        "newTypeParamCount": "NewType erfordert zwei Positionsargumente.",
        "newTypeProtocolClass": "NewType kann nicht mit Protokollklasse verwendet werden.",
        "noOverload": "Keine Überladungen für \"{name}\" stimmen mit den angegebenen Argumenten überein.",
        "noReturnContainsReturn": "Eine Funktion mit dem deklarierten Rückgabetyp \"NoReturn\" kann keine return-Anweisung enthalten.",
        "noReturnContainsYield": "Eine Funktion mit dem deklarierten Rückgabetyp \"NoReturn\" kann keine yield-Anweisung enthalten.",
        "noReturnReturnsNone": "Eine Funktion mit dem deklarierten Typ \"NoReturn\" kann nicht \"None\" zurückgeben.",
        "nonDefaultAfterDefault": "Das nicht standardmäßige Argument folgt dem Standardargument.",
        "nonLocalInModule": "Nichtlokale Deklaration auf Modulebene nicht zulässig",
        "nonLocalNoBinding": "Es wurde keine Bindung für nichtlokale \"{name}\" gefunden.",
        "nonLocalReassignment": "\"{name}\" wird vor einer nichtlokalen Deklaration zugewiesen.",
        "nonLocalRedefinition": "\"{name}\" wurde bereits als nichtlokal deklariert.",
        "noneNotCallable": "Ein Objekt vom Typ \"None\" kann nicht aufgerufen werden.",
        "noneNotIterable": "Ein Objekt vom Typ \"None\" kann nicht als iterierbarer Wert verwendet werden.",
        "noneNotSubscriptable": "Das Objekt vom Typ \"None\" kann nicht tiefgestellt werden.",
        "noneNotUsableWith": "Ein Objekt vom Typ \"None\" kann nicht mit \"with\" verwendet werden.",
        "noneOperator": "Der Operator \"{operator}\" wird für den \"{None}\" nicht unterstützt.",
        "noneUnknownMember": "\"{name}\" ist kein bekanntes Element von \"None\".",
        "notRequiredArgCount": "Nach \"NotRequired\" wurde ein einzelnes Typargument erwartet.",
        "notRequiredNotInTypedDict": "\"NotRequired\" ist in diesem Kontext nicht zulässig.",
        "objectNotCallable": "Das Objekt vom Typ \"{type}\" kann nicht aufgerufen werden.",
        "obscuredClassDeclaration": "Die Klassendeklaration \"{name}\" wird durch eine Deklaration desselben Namens verdeckt.",
        "obscuredFunctionDeclaration": "Die Funktionsdeklaration \"{name}\" wird durch eine Deklaration desselben Namens verdeckt.",
        "obscuredMethodDeclaration": "Die Methodendeklaration \"{name}\" wird durch eine Deklaration desselben Namens verdeckt.",
        "obscuredParameterDeclaration": "Die Parameterdeklaration \"{name}\" wird durch eine Deklaration desselben Namens verdeckt.",
        "obscuredTypeAliasDeclaration": "Die Typaliasdeklaration \"{name}\" wird durch eine Deklaration desselben Namens verdeckt.",
        "obscuredVariableDeclaration": "Die Deklaration \"{name}\" wird durch eine Deklaration desselben Namens verdeckt.",
        "operatorLessOrGreaterDeprecated": "Der Operator \"<>\" wird in Python 3 nicht unterstützt; verwenden Sie stattdessen \"!=\".",
        "optionalExtraArgs": "Nach \"Optional\" wurde ein Typargument erwartet.",
        "orPatternIrrefutable": "Ein irrefutables Muster ist nur als letztes Unterpattern in einem \"or\"-Muster zulässig.",
        "orPatternMissingName": "Alle Teilmuster innerhalb eines \"or\"-Musters müssen auf dieselben Namen zielen.",
        "overlappingOverload": "Überladung {obscured} für \"{name}\" wird nie verwendet, da sich die Parameter überlappen, {obscuredBy}",
        "overloadAbstractMismatch": "Überladene Methoden müssen alle abstrakt sein oder nicht.",
        "overloadImplementationMismatch": "Die überladene Implementierung ist nicht konsistent mit der Signatur der Überladung {index}",
        "overloadReturnTypeMismatch": "Überladung {prevIndex} für \"{name}\" überlappt {newIndex} und gibt einen inkompatiblen Typ zurück.",
        "overloadWithImplementation": "\"{name}\" ist als Überladung markiert, enthält jedoch eine Implementierung.",
        "overloadWithoutImplementation": "\"{name}\" ist als Überladen markiert, es wurde jedoch keine Implementierung bereitgestellt.",
        "overriddenMethodNotFound": "Die Methode \"{name}\" ist als Überschreibung markiert, aber es ist keine Basismethode mit demselben Namen vorhanden.",
        "overrideDecoratorMissing": "Die Methode \"{name}\" ist nicht als Überschreibung markiert, überschreibt jedoch eine Methode in der Klasse \"{className}\"",
        "paramAfterKwargsParam": "Der Parameter kann nicht auf den Parameter \"**\" folgen.",
        "paramAlreadyAssigned": "Der Parameter \"{name}\" ist bereits zugewiesen.",
        "paramAnnotationMissing": "Typanmerkung fehlt für Parameter \"{name}\"",
        "paramAssignmentMismatch": "Ein Ausdruck vom Typ \"{sourceType}\" kann keinem Parameter vom Typ \"{paramType}\" zugewiesen werden.",
        "paramNameMissing": "Kein Parameter mit dem Namen \"{name}\"",
        "paramSpecArgsKwargsUsage": "Die Member \"args\" und \"kwargs\" von ParamSpec müssen beide innerhalb einer Funktionssignatur auftreten.",
        "paramSpecArgsMissing": "Argumente für ParamSpec \"{type}\" fehlen.",
        "paramSpecArgsUsage": "Das \"args\"-Element von ParamSpec ist nur gültig, wenn es mit dem Parameter \"*args\" verwendet wird.",
        "paramSpecAssignedName": "ParamSpec muss einer Variablen mit dem Namen \"{name}\" zugewiesen werden.",
        "paramSpecContext": "ParamSpec ist in diesem Kontext nicht zulässig.",
        "paramSpecDefaultNotTuple": "Es wurde ein Auslassungszeichen, ein Tupelausdruck oder ParamSpec für den Standardwert von ParamSpec erwartet.",
        "paramSpecFirstArg": "Der Name von ParamSpec wurde als erstes Argument erwartet.",
        "paramSpecKwargsUsage": "Das \"kwargs\"-Element von ParamSpec ist nur gültig, wenn es mit dem Parameter **kwargs verwendet wird.",
        "paramSpecNotBound": "Die Parameterspezifikation \"{type}\" hat keinen gebundenen Wert.",
        "paramSpecNotUsedByOuterScope": "ParamSpec \"{name}\" hat in diesem Kontext keine Bedeutung.",
        "paramSpecScopedToReturnType": "ParamSpec \"{name}\" ist auf einen Aufruf innerhalb des Rückgabetyps beschränkt und kann im Funktionstext nicht referenziert werden.",
        "paramSpecUnknownArg": "ParamSpec unterstützt nur ein Argument.",
        "paramSpecUnknownMember": "\"{name}\" ist kein bekanntes Element von ParamSpec.",
        "paramSpecUnknownParam": "\"{name}\" ist ein unbekannter Parameter für ParamSpec.",
        "paramTypeCovariant": "Eine Variable vom Typ \"Covariant\" kann nicht im Parametertyp verwendet werden.",
        "paramTypePartiallyUnknown": "Der Typ des Parameters \"{paramName}\" ist teilweise unbekannt.",
        "paramTypeUnknown": "Der Typ des Parameters \"{paramName}\" ist unbekannt.",
        "parenthesizedContextManagerIllegal": "Klammern innerhalb der with-Anweisung erfordern Python 3.9 oder höher.",
        "patternNeverMatches": "Das Muster wird für den Antragstellertyp \"{type}\" nie abgeglichen",
        "positionArgAfterNamedArg": "Ein Positionsargument darf nicht nach Schlüsselwortargumenten stehen.",
        "positionOnlyAfterArgs": "Das Argumenttrennzeichen \"Nur Position\" ist nach dem Parameter \"*\" nicht zulässig.",
        "positionOnlyAfterKeywordOnly": "Der Parameter \"/\" muss vor dem Parameter \"*\" stehen.",
        "positionOnlyFirstParam": "Das Argumenttrennzeichen \"Nur Position\" ist als erster Parameter nicht zulässig.",
        "positionOnlyIncompatible": "Für das Argumenttrennzeichen \"Nur Position\" ist Python 3.8 oder höher erforderlich.",
        "privateImportFromPyTypedModule": "\"{name}\" wird nicht aus dem Modul \"{module}\" exportiert.",
        "privateUsedOutsideOfClass": "\"{name}\" ist privat und wird außerhalb der Klasse verwendet, in dem es deklariert ist.",
        "privateUsedOutsideOfModule": "\"{name}\" ist privat und wird außerhalb des Moduls verwendet, in dem es deklariert ist.",
        "propertyOverridden": "\"{name}\" überschreibt die Eigenschaft desselben Namens in der Klasse \"{className}\" nicht ordnungsgemäß",
        "propertyStaticMethod": "Statische Methoden sind für Eigenschaften-Getter, -Setter oder -Deleter nicht zulässig.",
        "protectedUsedOutsideOfClass": "\"{name}\" ist geschützt und wird außerhalb der Klasse verwendet, in der es deklariert ist.",
        "protocolBaseClass": "Die Protokollklasse \"{classType}\" kann nicht von einer Nichtprotokollklasse \"{baseType}\" abgeleitet werden",
        "protocolBaseClassWithTypeArgs": "Typargumente sind mit der Protokollklasse nicht zulässig, wenn die Typparametersyntax verwendet wird.",
        "protocolIllegal": "Die Verwendung von \"Protocol\" erfordert Python 3.7 oder höher.",
        "protocolNotAllowedInTypeArgument": "\"Protocol\" kann nicht als Typargument verwendet werden.",
        "protocolUsedInCall": "Die Protokollklasse kann nicht im Aufruf \"{name}\" verwendet werden.",
        "protocolVarianceContravariant": "Die Typvariable \"{variable}\", die im generischen Protokoll \"{class}\" verwendet wird, muss \"contravariant\" sein.",
        "protocolVarianceCovariant": "Die Typvariable \"{variable}\", die im generischen Protokoll \"{class}\" verwendet wird, muss \"covariant\" sein.",
        "protocolVarianceInvariant": "Die Typvariable \"{variable}\", die im generischen Protokoll \"{class}\" verwendet wird, muss \"invariant\" sein.",
        "pyrightCommentInvalidDiagnosticBoolValue": "Auf die Pyright-Kommentardirektive muss \"=\" und der Wert \"true\" oder \"false\" folgen.",
        "pyrightCommentInvalidDiagnosticSeverityValue": "Auf die Pyright-Kommentardirektive muss \"=\" und der Wert \"true\", \"false\", \"error\", \"warning\", \"information\" oder \"none\" folgen.",
        "pyrightCommentMissingDirective": "Auf einen Pyright-Kommentar muss eine Direktive (basic oder strict) oder eine Diagnoseregel folgen.",
        "pyrightCommentNotOnOwnLine": "Pyright-Kommentare, die zum Steuern von Einstellungen auf Dateiebene verwendet werden, müssen in ihrer eigenen Zeile angezeigt werden.",
        "pyrightCommentUnknownDiagnosticRule": "\"{rule}\" ist eine unbekannte Diagnoseregel für pyright-Kommentar.",
        "pyrightCommentUnknownDiagnosticSeverityValue": "\"{value}\" ist ein ungültiger Wert für den pyright-Kommentar; \"true\", \"false\", \"error\", \"warning\", \"information\" oder \"none\" erwartet.",
        "pyrightCommentUnknownDirective": "\"{directive}\" ist eine unbekannte Direktive für pyright-Kommentar; \"strict\" oder \"basic\" erwartet",
        "readOnlyArgCount": "Nach \"ReadOnly\" wurde ein einzelnes Typargument erwartet.",
        "readOnlyNotInTypedDict": "\"ReadOnly\" ist in diesem Kontext nicht zulässig.",
        "recursiveDefinition": "Der Typ von \"{name}\" konnte nicht bestimmt werden, da er sich auf selbst bezieht.",
        "relativeImportNotAllowed": "Relative Importe können nicht mit dem Formular \"import .a\" verwendet werden; verwenden Sie stattdessen \"from . import a\"",
        "requiredArgCount": "Nach \"Required\" wurde ein einzelnes Typargument erwartet.",
        "requiredNotInTypedDict": "\"Required\" ist in diesem Kontext nicht zulässig.",
        "returnInAsyncGenerator": "Eine Return-Anweisung mit einem Wert ist im asynchronen Generator nicht zulässig.",
        "returnMissing": "Die Funktion mit dem deklarierten Typ \"{returnType}\" muss einen Wert für alle Codepfade zurückgeben.",
        "returnOutsideFunction": "\"return\" kann nur innerhalb einer Funktion verwendet werden.",
        "returnTypeContravariant": "Die Variable vom Typ \"contravariant\" kann nicht im Rückgabetyp verwendet werden.",
        "returnTypeMismatch": "Ein Ausdruck vom Typ \"{exprType}\" kann dem Rückgabetyp \"{returnType}\" nicht zugewiesen werden.",
        "returnTypePartiallyUnknown": "Der Rückgabetyp \"{returnType}\" ist teilweise unbekannt.",
        "returnTypeUnknown": "Unbekannter Rückgabetyp",
        "revealLocalsArgs": "Es wurden keine Argumente für den Aufruf \"reveal_locals\" erwartet.",
        "revealLocalsNone": "Keine lokalen Elemente in diesem Bereich",
        "revealTypeArgs": "Für den Aufruf \"reveal_type\" wurde ein einzelnes Positionsargument erwartet.",
        "revealTypeExpectedTextArg": "Das Argument \"expected_text\" für die Funktion \"reveal_type\" muss ein str-Literalwert sein.",
        "revealTypeExpectedTextMismatch": "Typentextkonflikt; \"{expected}\" erwartet, aber \"{received}\" empfangen",
        "revealTypeExpectedTypeMismatch": "Typenkonflikt; \"{expected}\" erwartet, aber \"{received}\" empfangen",
        "selfTypeContext": "\"Self\" ist in diesem Kontext ungültig.",
        "selfTypeWithTypedSelfOrCls": "\"Self\" kann nicht in einer Funktion mit einem Parameter \"self\" oder \"cls\" verwendet werden, der eine andere Typanmerkung als \"Self\" aufweist.",
        "setterGetterTypeMismatch": "Der Werttyp des Eigenschaftensetters kann dem Rückgabetyp des Getters nicht zugewiesen werden.",
        "singleOverload": "\"{name}\" ist als Überladung markiert, aber es fehlen weitere Überladungen.",
        "slotsAttributeError": "\"{name}\" ist in __slots__ nicht angegeben.",
        "slotsClassVarConflict": "\"{name}\" steht in Konflikt mit Instanzvariablen, die in __slots__ deklariert sind.",
        "starPatternInAsPattern": "Das Sternmuster kann nicht mit dem Ziel \"as\" verwendet werden.",
        "starPatternInOrPattern": "Das Sternmuster kann in anderen Mustern nicht ORed sein.",
        "starStarWildcardNotAllowed": "** kann nicht zusammen mit Platzhalter \"_\" verwendet werden",
        "staticClsSelfParam": "Statische Methoden dürfen keinen \"self\"- oder \"cls\"-Parameter annehmen.",
        "stdlibModuleOverridden": "\"{path}\" überschreibt das stdlib-Modul \"{name}\"",
        "stringNonAsciiBytes": "Ein Nicht-ASCII-Zeichen ist im Zeichenfolgenliteral in Bytes nicht zulässig.",
        "stringNotSubscriptable": "Der Zeichenfolgenausdruck kann nicht in der Typanmerkung tiefgestellt werden; schließen Sie die gesamte Anmerkung in Anführungszeichen ein",
        "stringUnsupportedEscape": "Nicht unterstützte Escapesequenz im Zeichenfolgenliteral.",
        "stringUnterminated": "Das Zeichenfolgenliteral ist nicht beendet.",
        "stubFileMissing": "Die Stubdatei wurde für \"{importName}\" nicht gefunden.",
        "stubUsesGetAttr": "Die Typ-Stub-Datei ist unvollständig; \"__getattr__\" verdeckt Typfehler für Modul",
        "sublistParamsIncompatible": "Unterlistenparameter werden in Python 3.x nicht unterstützt.",
        "superCallArgCount": "Es werden nicht mehr als zwei Argumente für den Superaufruf erwartet.",
        "superCallFirstArg": "Klassentyp als erstes Argument für super-Aufruf erwartet, aber \"{type}\" empfangen",
        "superCallSecondArg": "Das zweite Argument für den \"super\"-Aufruf muss ein Objekt oder eine Klasse sein, das bzw. die von \"{type}\" abgeleitet wird.",
        "superCallZeroArgForm": "Die Nullargumentform des super-Aufrufs ist nur innerhalb einer Klasse gültig.",
        "symbolIsPossiblyUnbound": "\"{name}\" ist möglicherweise ungebunden.",
        "symbolIsUnbound": "\"{name}\" ist ungebunden.",
        "symbolIsUndefined": "\"{name}\" ist nicht definiert.",
        "symbolOverridden": "\"{name}\" überschreibt das Symbol desselben Namens in der Klasse \"{className}\"",
        "totalOrderingMissingMethod": "Die Klasse muss \"__lt__\", \"__le__\", \"__gt__\" oder \"__ge__\" definieren, um total_ordering zu verwenden.",
        "trailingCommaInFromImport": "Nachgestelltes Komma ist ohne umgebende Klammern nicht zulässig.",
        "tryWithoutExcept": "Die try-Anweisung muss mindestens eine except- oder finally-Klausel aufweisen.",
        "tupleAssignmentMismatch": "Ein Ausdruck vom Typ \"{type}\" kann dem Zieltupel nicht zugewiesen werden.",
        "tupleInAnnotation": "Ein Tupelausdruck ist in der Typanmerkung nicht zulässig.",
        "tupleIndexOutOfRange": "Der Index {index} liegt für den Typ {type} außerhalb des gültigen Bereichs.",
        "typeAliasIllegalExpressionForm": "Ungültiges Ausdrucksformular für Typaliasdefinition",
        "typeAliasIsRecursiveDirect": "Der Typalias \"{name}\" kann sich nicht selbst in seiner Definition verwenden.",
        "typeAliasNotInModuleOrClass": "TypeAlias kann nur innerhalb eines Moduls oder Klassenbereichs definiert werden.",
        "typeAliasRedeclared": "\"{name}\" ist als TypeAlias deklariert und kann nur einmal zugewiesen werden.",
        "typeAliasStatementIllegal": "Die Typaliasanweisung erfordert Python 3.12 oder höher.",
        "typeAliasTypeMustBeAssigned": "TypeAliasType muss einer Variablen mit dem gleichen Namen wie der Typalias zugewiesen werden.",
        "typeAliasTypeNameArg": "Das erste Argument für TypeAliasType muss ein Zeichenfolgenliteral sein, das den Namen des Typalias darstellt.",
        "typeAliasTypeNameMismatch": "Der Name des Typalias muss mit dem Namen der Variablen übereinstimmen, der er zugewiesen ist.",
        "typeAliasTypeParamInvalid": "Die Typparameterliste muss ein Tupel sein, das nur TypeVar, TypeVarTuple oder ParamSpec enthält.",
        "typeAnnotationCall": "Der Aufrufausdruck ist im Typausdruck nicht zulässig",
        "typeAnnotationVariable": "Variable im Typausdruck nicht zulässig",
        "typeAnnotationWithCallable": "Type argument for \"type\" must be a class; callables are not supported",
        "typeArgListExpected": "ParamSpec, Ellipse oder Liste der Typen erwartet",
        "typeArgListNotAllowed": "Der Listenausdruck ist für dieses Typargument nicht zulässig.",
        "typeArgsExpectingNone": "Für die Klasse \"{name}\" werden keine Typargumente erwartet.",
        "typeArgsMismatchOne": "Es wurde ein Typargument erwartet, es wurde jedoch {received} empfangen.",
        "typeArgsMissingForAlias": "Für den generischen Typalias \"{name}\" werden Typargumente erwartet.",
        "typeArgsMissingForClass": "Für die generische Klasse \"{name}\" werden Typargumente erwartet.",
        "typeArgsTooFew": "Für \"{name}\" wurden zu wenige Typargumente angegeben; {expected} erwartet, aber {received} empfangen",
        "typeArgsTooMany": "Für \"{name}\" wurden zu viele Typargumente angegeben; {expected} erwartet, aber {received} empfangen",
        "typeAssignmentMismatch": "Ein Ausdruck vom Typ \"{sourceType}\" kann nicht dem deklarierten Typ \"{destType}\" zugewiesen werden.",
        "typeCallNotAllowed": "Der type()-Aufruf darf nicht in der Typanmerkung verwendet werden.",
        "typeCommentDeprecated": "Die Verwendung von Typkommentaren ist veraltet; verwenden Sie stattdessen Typanmerkung",
        "typeExpectedClass": "Typausdruck erwartet, aber \"{type}\" empfangen",
        "typeGuardArgCount": "Nach \"TypeGuard\" wurde ein einzelnes Typargument erwartet.",
        "typeGuardParamCount": "Benutzerdefinierte Typenschutzfunktionen und -methoden müssen mindestens einen Eingabeparameter aufweisen.",
        "typeNotAwaitable": "\"{type}\" ist nicht awaitable.",
        "typeNotCallable": "\"{expression}\" weist den Typ \"{type}\" auf und kann nicht aufgerufen werden.",
        "typeNotIntantiable": "\"{type}\" kann nicht instanziiert werden.",
        "typeNotIterable": "\"{type}\" ist nicht iterierbar.",
        "typeNotSpecializable": "Der Typ \"{type}\" konnte nicht spezialisiert werden",
        "typeNotSubscriptable": "Das Objekt vom Typ \"{type}\" kann nicht tiefgestellt werden.",
        "typeNotSupportBinaryOperator": "Der Operator \"{operator}\" wird für Typen \"{leftType}\" und \"{rightType}\" nicht unterstützt.",
        "typeNotSupportBinaryOperatorBidirectional": "Der Operator \"{operator}\" wird für die Typen \"{leftType}\" und \"{rightType}\" nicht unterstützt, wenn der erwartete Typ \"{expectedType}\" ist.",
        "typeNotSupportUnaryOperator": "Der Operator \"{operator}\" wird für den Typ \"{type}\" nicht unterstützt.",
        "typeNotSupportUnaryOperatorBidirectional": "Der Operator \"{operator}\" wird für den Typ \"{type}\" nicht unterstützt, wenn der erwartete Typ \"{expectedType}\" ist.",
        "typeNotUsableWith": "Ein Objekt vom Typ \"{type}\" kann nicht mit \"with\" verwendet werden, da es nicht {method} implementiert.",
        "typeParameterBoundNotAllowed": "\"Bound\" oder \"constraint\" kann nicht mit einem variadic-Typparameter oder ParamSpec verwendet werden.",
        "typeParameterConstraintTuple": "Die Typparametereinschränkung muss ein Tupel mit mindestens zwei Typen sein.",
        "typeParameterExistingTypeParameter": "Der Typparameter \"{name}\" wird bereits verwendet.",
        "typeParameterNotDeclared": "Der Typparameter \"{name}\" ist nicht in der Typparameterliste für \"{container}\" enthalten.",
        "typeParametersMissing": "Es muss mindestens ein Typparameter angegeben werden.",
        "typePartiallyUnknown": "Der Typ von \"{name}\" ist teilweise unbekannt.",
        "typeUnknown": "Der Typ von \"{name}\" ist unbekannt.",
        "typeVarAssignedName": "TypeVar muss einer Variablen mit dem Namen \"{name}\" zugewiesen werden.",
        "typeVarAssignmentMismatch": "Der Typ \"{type}\" kann der Typvariablen \"{name}\" nicht zugewiesen werden.",
        "typeVarBoundAndConstrained": "TypeVar kann nicht gleichzeitig gebunden und eingeschränkt sein.",
        "typeVarBoundGeneric": "Der gebundene Typ \"TypeVar\" darf nicht generisch sein.",
        "typeVarConstraintGeneric": "Der Typ der TypeVar-Einschränkung darf nicht generisch sein.",
        "typeVarDefaultBoundMismatch": "Der Standardtyp \"TypeVar\" muss ein Untertyp des gebundenen Typs sein.",
        "typeVarDefaultConstraintMismatch": "Der Standardtyp \"TypeVar\" muss einer der eingeschränkten Typen sein.",
        "typeVarDefaultIllegal": "Für Standardtypen von Typvariablen ist Python 3.13 oder höher erforderlich.",
        "typeVarDefaultInvalidTypeVar": "Der Typparameter \"{name}\" weist einen Standardtyp auf, der auf eine oder mehrere Typvariablen verweist, die außerhalb des Gültigkeitsbereichs liegen.",
        "typeVarFirstArg": "Der Name von TypeVar wurde als erstes Argument erwartet.",
        "typeVarNoMember": "TypeVar \"{type}\" hat kein Member \"{name}\"",
        "typeVarNotSubscriptable": "TypeVar \"{type}\" kann nicht tiefgestellt werden.",
        "typeVarNotUsedByOuterScope": "Die Typvariable \"{name}\" hat in diesem Kontext keine Bedeutung.",
        "typeVarPossiblyUnsolvable": "Die Typvariable \"{name}\" wird möglicherweise nicht aufgelöst, wenn der Aufrufer kein Argument für Parameter \"{param}\" bereitstellt",
        "typeVarScopedToReturnType": "Die Typvariable \"{name}\" ist auf einen Aufruf innerhalb des Rückgabetyps beschränkt und kann im Funktionstext nicht referenziert werden.",
        "typeVarSingleConstraint": "TypeVar muss mindestens zwei eingeschränkte Typen aufweisen.",
        "typeVarTupleContext": "TypeVarTuple ist in diesem Kontext nicht zulässig.",
        "typeVarTupleDefaultNotUnpacked": "Der Standardtyp \"TypeVarTuple\" muss ein entpacktes Tupel oder ein TypeVarTuple sein.",
        "typeVarTupleMustBeUnpacked": "Der Entpackungsoperator ist für den TypeVarTuple-Wert erforderlich.",
        "typeVarTupleUnknownParam": "\"{name}\" ist ein unbekannter Parameter für TypeVar-Tuple.",
        "typeVarUnknownParam": "\"{name}\" ist ein unbekannter Parameter für TypeVar.",
        "typeVarUsedByOuterScope": "TypeVar \"{name}\" wird bereits von einem äußeren Bereich verwendet.",
        "typeVarUsedOnlyOnce": "TypeVar \"{name}\" wird in der generischen Funktionssignatur nur einmal angezeigt.",
        "typeVarVariance": "TypeVar darf nicht gleichzeitig \"covariant\" und \"contravariant\" sein.",
        "typeVarWithoutDefault": "\"{name}\" kann nicht nach \"{other}\" in der Typparameterliste angezeigt werden, da es keinen Standardtyp aufweist.",
        "typeVarsNotInGenericOrProtocol": "Generic[] oder Protocol[] müssen alle Typvariablen enthalten.",
        "typedDictAccess": "Auf das Element in TypedDict konnte nicht zugegriffen werden.",
        "typedDictBadVar": "TypedDict-Klassen dürfen nur Typanmerkungen enthalten.",
        "typedDictBaseClass": "Alle Basisklassen für TypedDict-Klassen müssen auch TypedDict-Klassen sein.",
        "typedDictBoolParam": "Es wird erwartet, dass \"{name}\" Parameter den Wert \"True\" oder \"False\" aufweist.",
        "typedDictDelete": "Das Element in TypedDict konnte nicht gelöscht werden.",
        "typedDictEmptyName": "Namen innerhalb eines TypedDict dürfen nicht leer sein.",
        "typedDictEntryName": "Für den Wörterbucheintragsnamen wurde ein Zeichenfolgenliteral erwartet.",
        "typedDictEntryUnique": "Namen innerhalb eines Wörterbuchs müssen eindeutig sein.",
        "typedDictExtraArgs": "Zusätzliche TypedDict-Argumente werden nicht unterstützt.",
        "typedDictFieldReadOnlyRedefinition": "Das TypedDict-Feld \"{name}\" kann nicht als schreibgeschützt neu definiert werden.",
        "typedDictFieldTypeRedefinition": "Der Typ des TypedDict-Felds \"{name}\" kann nicht neu definiert werden.",
        "typedDictFirstArg": "Der Klassenname \"TypedDict\" wird als erstes Argument erwartet.",
        "typedDictSecondArgDict": "Es wird ein dict- oder Schlüsselwortparameter als zweiter Parameter erwartet.",
        "typedDictSecondArgDictEntry": "Einfacher Wörterbucheintrag erwartet",
        "typedDictSet": "Element konnte in TypedDict nicht zugewiesen werden.",
        "unaccessedClass": "Auf die Klasse \"{name}\" kann nicht zugegriffen werden.",
        "unaccessedFunction": "Auf die Funktion \"{name}\" kann nicht zugegriffen werden.",
        "unaccessedImport": "Auf den Import \"{name}\" kann nicht zugegriffen werden.",
        "unaccessedSymbol": "Auf \"{name}\" kann nicht zugegriffen werden.",
        "unaccessedVariable": "Auf die Variable \"{name}\" kann nicht zugegriffen werden.",
        "unannotatedFunctionSkipped": "Die Analyse der Funktion \"{name}\" wird übersprungen, da sie nicht kommentiert wurde.",
        "unexpectedAsyncToken": "Es wurde erwartet, dass \"def\", \"with\" oder \"for\" auf \"async\" folgt.",
        "unexpectedExprToken": "Unerwartetes Token am Ende des Ausdrucks.",
        "unexpectedIndent": "Unerwarteter Einzug",
        "unexpectedUnindent": "\"Unindent\" nicht erwartet.",
        "unhashableDictKey": "Der Wörterbuchschlüssel muss hashbar sein.",
        "unhashableSetEntry": "Der Eintrag \"Set\" muss hashbar sein.",
        "uninitializedAbstractVariables": "In der abstrakten Basisklasse definierte Variablen sind in der endgültigen Klasse \"{classType}\" nicht initialisiert",
        "uninitializedInstanceVariable": "Die Instanzvariable \"{name}\" ist im Klassentext oder in der __init__ Methode nicht initialisiert.",
        "unionForwardReferenceNotAllowed": "Die Unionsyntax kann nicht mit einem Zeichenfolgenoperanden verwendet werden; verwenden Sie Anführungszeichen um den gesamten Ausdruck",
        "unionSyntaxIllegal": "Alternative Syntax für Unions erfordert Python 3.10 oder höher.",
        "unionTypeArgCount": "Union erfordert mindestens zwei Typargumente.",
        "unmatchedEndregionComment": "#endregion fehlt die entsprechende #region",
        "unmatchedRegionComment": "#region fehlt die entsprechende #endregion",
        "unnecessaryCast": "Nicht erforderlicher \"cast\"-Aufruf; der Typ ist bereits \"{type}\".",
        "unnecessaryIsInstanceAlways": "Nicht erforderlicher isinstance-Aufruf; \"{testType}\" ist immer eine Instanz von \"{classType}\"",
        "unnecessaryIsSubclassAlways": "Nicht erforderlicher issubclass-Aufruf; \"{testType}\" ist immer eine Unterklasse von \"{classType}\"",
        "unnecessaryPyrightIgnore": "Unnötiger \"# pyright: ignore\"-Kommentar",
        "unnecessaryPyrightIgnoreRule": "Unnötiger \"# pyright: ignore\"-Kommentar",
        "unnecessaryTypeIgnore": "Nicht erforderlicher \"# type: ignore\"-Kommentar",
        "unpackArgCount": "Nach \"Required\" wurde ein einzelnes Typargument erwartet.",
        "unpackExpectedTypeVarTuple": "'TypeVarTuple' oder 'Tuple' wurde als Typargument für 'Unpack' erwartet.",
        "unpackExpectedTypedDict": "TypedDict-Typargument für Unpack erwartet",
        "unpackIllegalInComprehension": "Der Entpackvorgang ist in Verständnis nicht zulässig.",
        "unpackInAnnotation": "Der Operator zum Entpacken ist in der Typanmerkung nicht zulässig.",
        "unpackInDict": "Der Entpackvorgang ist in Wörterbüchern nicht zulässig.",
        "unpackInSet": "Der Operator zum Entpacken ist innerhalb einer Menge nicht zulässig.",
        "unpackNotAllowed": "Entpacken ist in diesem Kontext nicht zulässig.",
        "unpackOperatorNotAllowed": "Der Entpackvorgang ist in diesem Kontext nicht zulässig.",
        "unpackTuplesIllegal": "Der Entpackvorgang ist in Tupeln vor Python 3.8 nicht zulässig.",
        "unpackedArgInTypeArgument": "Ungepackte Argumente können nicht in Typargumentlisten verwendet werden.",
        "unpackedArgWithVariadicParam": "Das nicht gepackte Argument kann nicht für den Parameter \"TypeVarTuple\" verwendet werden.",
        "unpackedDictArgumentNotMapping": "Der Argumentausdruck nach ** muss eine Zuordnung mit dem Schlüsseltyp \"str\" sein.",
        "unpackedDictSubscriptIllegal": "Der Operator zum Entpacken des Wörterbuchs in tiefgestellten Zeichen ist nicht zulässig.",
        "unpackedSubscriptIllegal": "Das Entpacken des Operators im Tiefstellungsskript erfordert Python 3.11 oder höher.",
        "unpackedTypeVarTupleExpected": "Nicht gepackter TypeVarTuple erwartet; verwenden Sie Unpack[{name1}] oder *{name2}",
        "unpackedTypedDictArgument": "Das entpackte TypedDict-Argument kann nicht mit Parametern abgelichen werden.",
        "unreachableCode": "Der Code ist nicht erreichbar.",
        "unreachableExcept": "Die except-Klausel ist nicht erreichbar, weil die Ausnahme bereits behandelt wird.",
        "unsupportedDunderAllOperation": "Der Vorgang für \"__all__\" wird nicht unterstützt, daher ist die exportierte Symbolliste möglicherweise falsch.",
        "unusedCallResult": "Das Ergebnis des Aufrufausdrucks ist vom Typ \"{type}\" und wird nicht verwendet; der Variablen \"_\" zuweisen, wenn dies beabsichtigt ist",
        "unusedCoroutine": "Das Ergebnis eines asynchronen Funktionsaufrufs wird nicht verwendet; verwenden Sie \"await\", oder weisen Sie der Variablen ein Ergebnis zu.",
        "unusedExpression": "Der Ausdruckswert wird nicht verwendet.",
        "varAnnotationIllegal": "Typanmerkungen für Variablen erfordern Python 3.6 oder höher; verwenden Sie den Typkommentar für Kompatibilität mit früheren Versionen",
        "variableFinalOverride": "Die Variable \"{name}\" ist als \"Final\" gekennzeichnet und überschreibt die Nicht-Final-Variable desselben Namens in der Klasse \"{className}\"",
        "variadicTypeArgsTooMany": "Die Typargumentliste darf höchstens ein entpacktes TypeVarTuple oder Tuple aufweisen.",
        "variadicTypeParamTooManyAlias": "Der Typalias darf höchstens einen TypeVarTuple-Typparameter aufweisen, es wurden jedoch mehrere ({names}) empfangen.",
        "variadicTypeParamTooManyClass": "Die generische Klasse darf höchstens einen TypeVarTuple-Typparameter aufweisen, es wurden jedoch mehrere ({names}) empfangen.",
        "walrusIllegal": "Der Operator \":=\" erfordert Python 3.8 oder höher.",
        "walrusNotAllowed": "Der Operator \":=\" ist in diesem Kontext ohne umgebende Klammern nicht zulässig.",
        "wildcardInFunction": "Der Platzhalterimport ist innerhalb einer Klasse oder Funktion nicht zulässig.",
        "wildcardLibraryImport": "Der Platzhalterimport aus einer Bibliothek ist nicht zulässig.",
        "wildcardPatternTypePartiallyUnknown": "Der durch das Platzhaltermuster erfasste Typ ist teilweise unbekannt.",
        "wildcardPatternTypeUnknown": "Der durch das Platzhaltermuster erfasste Typ ist unbekannt.",
        "yieldFromIllegal": "Die Verwendung von \"yield from\" erfordert Python 3.3 oder höher.",
        "yieldFromOutsideAsync": "\"yield from\" ist in einer asynchronen Funktion nicht zulässig.",
        "yieldOutsideFunction": "\"yield\" ist außerhalb einer Funktion oder eines Lambdas nicht zulässig.",
        "yieldWithinListCompr": "\"yield\" ist innerhalb eines Listenverständnisses nicht zulässig.",
        "zeroCaseStatementsFound": "Die match-Anweisung muss mindestens eine case-Anweisung enthalten",
        "zeroLengthTupleNotAllowed": "Ein Tupel mit der Länge Null ist in diesem Kontext nicht zulässig."
    },
    "DiagnosticAddendum": {
        "argParam": "Argument entspricht Parameter \"{paramName}\"",
        "argParamFunction": "Argument entspricht Parameter \"{paramName}\" in Funktion \"{functionName}\"",
        "argsParamMissing": "Der Parameter \"*{paramName}\" weist keinen entsprechenden Parameter auf.",
        "argsPositionOnly": "Nicht übereinstimmende Parameteranmerkungsanzahl: {expected} erwartet, aber {received} empfangen",
        "argumentType": "Argumenttyp ist \"{type}\"",
        "argumentTypes": "Argumenttypen: ({types})",
        "assignToNone": "Der Typ kann nicht dem Typ \"None\" zugewiesen werden.",
        "asyncHelp": "Meinten Sie \"asynchron mit\"?",
        "baseClassOverriddenType": "Die Basisklasse \"{baseClass}\" stellt einen Typ \"{type}\" bereit, der überschrieben wird.",
        "baseClassOverridesType": "Basisklasse \"{baseClass}\" überschreibt mit Typ \"{type}\"",
        "conditionalRequiresBool": "Die Methode __bool__ für den Typ \"{operandType}\" gibt den Typ \"{boolReturnType}\" anstelle von \"bool\" zurück",
        "dataClassFieldLocation": "Felddeklaration",
        "dataClassFrozen": "\"{name}\" ist fixiert",
        "finalMethod": "Endgültige Methode",
        "functionParamDefaultMissing": "Standardargument für Parameter \"{name}\" fehlt.",
        "functionParamName": "Parameternamen stimmen nicht überein: \"{destName}\" und \"{srcName}\"",
        "functionReturnTypeMismatch": "Der Funktionsrückgabetyp \"{sourceType}\" ist nicht mit dem Typ \"{destType}\" kompatibel.",
        "functionTooFewParams": "Die Funktion akzeptiert zu wenige Positionsparameter; {expected} erwartet, aber {received} empfangen",
        "functionTooManyParams": "Die Funktion akzeptiert zu viele Positionsparameter; {expected} erwartet, aber {received} empfangen",
        "incompatibleDeleter": "Die Deletermethode der Eigenschaft ist nicht kompatibel.",
        "incompatibleGetter": "Die Gettermethode der Eigenschaft ist nicht kompatibel.",
        "incompatibleSetter": "Die Settermethode der Eigenschaft ist nicht kompatibel.",
        "initMethodLocation": "Die __init__ Methode ist in der Klasse \"{type}\" definiert.",
        "initMethodSignature": "Die Signatur von __init__ ist \"{type}\".",
        "keyNotRequired": "\"{name}\" ist kein erforderlicher Schlüssel in \"{type}\". Der Zugriff kann daher zu einer Laufzeitausnahme führen.",
        "keyReadOnly": "\"{name}\" ist ein schreibgeschützter Schlüssel in \"{type}\"",
        "keyRequiredDeleted": "\"{name}\" ist ein erforderlicher Schlüssel und kann nicht gelöscht werden.",
        "keyUndefined": "\"{name}\" ist kein definierter Schlüssel in \"{type}\"",
        "kwargsParamMissing": "Der Parameter \"**{paramName}\" weist keinen entsprechenden Parameter auf.",
        "listAssignmentMismatch": "Der Typ \"{type}\" ist nicht mit der Zielliste kompatibel.",
        "literalAssignmentMismatch": "\"{sourceType}\" kann dem Typ \"{destType}\" nicht zugewiesen werden.",
        "matchIsNotExhaustiveHint": "Wenn keine ausführliche Behandlung beabsichtigt ist, fügen Sie \"case _: pass\" hinzu.",
        "matchIsNotExhaustiveType": "Unbehandelter Typ: \"{type}\"",
        "memberAssignment": "Ein Ausdruck vom Typ \"{type}\" kann dem Member \"{name}\" der Klasse \"{classType}\" nicht zugewiesen werden.",
        "memberIsAbstract": "\"{type}.{name}\" ist abstrakt.",
        "memberIsAbstractMore": "und {count} weitere...",
        "memberIsFinalInProtocol": "\"{name}\" ist im Protokoll als \"Final\" gekennzeichnet.",
        "memberIsInitVar": "Das Element \"{name}\" ist ein init-only-Feld.",
        "memberIsInvariant": "\"{name}\" ist invariant, da es änderbar ist.",
        "memberIsNotFinalInProtocol": "\"{name}\" ist im Protokoll nicht als \"Final\" gekennzeichnet.",
        "memberSetClassVar": "Der Member \"{name}\" kann nicht über eine Klasseninstanz zugewiesen werden, da es sich um eine ClassVar handelt.",
        "memberTypeMismatch": "\"{name}\" ist ein inkompatibler Typ.",
        "memberUnknown": "Das Member \"{name}\" ist unbekannt.",
        "missingDeleter": "Die Eigenschaft-Deleter-Methode fehlt.",
        "missingGetter": "Die Eigenschaft-Getter-Methode fehlt.",
        "missingProtocolMember": "Member \"{name}\" ist in Protokollklasse \"{classType}\" deklariert.",
        "missingSetter": "Die Eigenschaft-Setter-Methode fehlt.",
        "namedParamMissingInDest": "Der Schlüsselwortparameter \"{name}\" fehlt im Ziel.",
        "namedParamMissingInSource": "Der Schlüsselwortparameter \"{name}\" fehlt in der Quelle.",
        "namedParamTypeMismatch": "Der Stichwortparameter \"{name}\" vom Typ \"{sourceType}\" kann dem Typ \"{destType}\" nicht zugewiesen werden.",
        "newMethodLocation": "Die __new__ Methode ist in der Klasse \"{type}\" definiert.",
        "newMethodSignature": "Signatur von __new__ ist \"{type}\"",
        "noOverloadAssignable": "Keine überladene Funktion stimmt mit dem Typ \"{type}\" überein.",
        "orPatternMissingName": "Fehlende Namen: {name}",
        "overloadNotAssignable": "Mindestens eine Überladung von \"{name}\" kann nicht zugewiesen werden.",
        "overloadSignature": "Die Überladungssignatur ist hier definiert.",
        "overloadWithImplementation": "Der Text einer Funktionsüberladung muss \"...\" sein.",
        "overriddenMethod": "Überschriebene Methode",
        "overriddenSymbol": "Außer Kraft gesetztes Symbol",
        "overrideNoOverloadMatches": "Keine Überladungssignatur in Überschreibung ist mit der Basismethode kompatibel.",
        "overrideNotClassMethod": "Die Basismethode ist als Klassenmethode deklariert, die Überschreibung jedoch nicht",
        "overrideNotInstanceMethod": "Die Basismethode ist als Instanz deklariert, die Überschreibung jedoch nicht",
        "overrideNotStaticMethod": "Die Basismethode ist als staticmethod deklariert, die Überschreibung jedoch nicht",
        "overrideOverloadNoMatch": "Das Überladen von {index} ist nicht mit der Basismethode kompatibel.",
        "overrideOverloadOrder": "Überladungen für die Überschreibungsmethode müssen in der gleichen Reihenfolge wie die Basismethode vorliegen.",
        "overrideParamKeywordNoDefault": "Konflikt mit Schlüsselwortparameter \"{name}\": Der Basisparameter hat einen Standardargumentwert, der Außerkraftsetzungsparameter ist nicht identisch.",
        "overrideParamKeywordType": "Schlüsselwortparameter \"{name}\" Typenkonflikt: Basisparameter ist Typ \"{baseType}\", Überschreibungsparameter ist Typ \"{overrideType}\"",
        "overrideParamName": "Namenskonflikt mit Parameter {index}: Der Basisparameter hat den Namen \"{baseName}\", der Außerkraftsetzungsparameter ist \"{overrideName}\"",
        "overrideParamNameExtra": "Der Parameter \"{name}\" fehlt in der Basis.",
        "overrideParamNameMissing": "Der Parameter \"{name}\" fehlt in der Außerkraftsetzung.",
        "overrideParamNamePositionOnly": "Namenskonflikt mit Parameter {index}: Der Basisparameter hat den Namen \"{baseName}\", der Außerkraftsetzungsparameter ist \"position-only\"",
        "overrideParamNoDefault": "Konflikt mit Parameter {index}: Der Basisparameter hat einen Standardargumentwert, der Außerkraftsetzungsparameter ist nicht identisch.",
        "overrideParamType": "Parameter {index} Typenkonflikt: Basisparameter ist Typ \"{baseType}\", Überschreibungsparameter ist Typ \"{overrideType}\"",
        "overridePositionalParamCount": "Anzahl der Positionsparameter stimmt nicht überein; die Basismethode hat {baseCount}, aber die Überschreibung hat {overrideCount}",
        "overrideReturnType": "Rückgabetypkonflikt: Basismethode gibt Typ \"{baseType}\" zurück, Überschreibung gibt Typ \"{overrideType}\" zurück",
        "overrideType": "Die Basisklasse definiert den Typ als \"{type}\"",
        "paramAssignment": "Parameter {index}: Der Typ \"{sourceType}\" kann dem Typ \"{destType}\" nicht zugewiesen werden.",
        "paramSpecMissingInOverride": "Parameter \"ParamSpec\" fehlen in der Überschreibungsmethode.",
        "paramType": "Parametertyp ist \"{paramType}\"",
        "privateImportFromPyTypedSource": "Stattdessen aus \"{module}\" importieren",
        "propertyAccessFromProtocolClass": "Auf eine in einer Protokollklasse definierte Eigenschaft kann nicht als Klassenvariable zugegriffen werden.",
        "propertyMethodIncompatible": "Die Eigenschaftsmethode \"{name}\" ist inkompatibel.",
        "propertyMethodMissing": "Die Eigenschaftsmethode \"{name}\" fehlt in der Überschreibung.",
        "propertyMissingDeleter": "Die Eigenschaft \"{name}\" hat keinen definierten Deleter.",
        "propertyMissingSetter": "Die Eigenschaft \"{name}\" hat keinen definierten Setter.",
        "protocolIncompatible": "\"{sourceType}\" ist nicht mit dem Protokoll \"{destType}\" kompatibel.",
        "protocolMemberClassVar": "\"{name}\" ist keine Klassenvariable.",
        "protocolMemberMissing": "\"{name}\" ist nicht vorhanden.",
        "protocolSourceIsNotConcrete": "\"{sourceType}\" ist kein konkreter Klassentyp und kann dem Typ \"{destType}\" nicht zugewiesen werden.",
        "pyrightCommentIgnoreTip": "Verwenden Sie \"# pyright: ignore[<diagnostic rules>]\", um die Diagnose für eine einzelne Zeile zu unterdrücken.",
        "readOnlyAttribute": "Das Attribut \"{name}\" ist schreibgeschützt.",
        "seeClassDeclaration": "Siehe Klassendeklaration",
        "seeDeclaration": "Siehe Deklaration",
        "seeFunctionDeclaration": "Siehe Funktionsdeklaration",
        "seeMethodDeclaration": "Siehe Methodendeklaration",
        "seeParameterDeclaration": "Siehe Parameterdeklaration",
        "seeTypeAliasDeclaration": "Siehe Typaliasdeklaration",
        "seeVariableDeclaration": "Siehe Variablendeklaration",
        "tupleAssignmentMismatch": "Der Typ \"{type}\" ist nicht mit dem Zieltupel kompatibel.",
        "tupleEntryTypeMismatch": "Der Tupeleintrag {entry} ist ein falscher Typ.",
        "tupleSizeMismatch": "Elementgrößenkonflikt: {expected} erwartet, aber {received} empfangen",
        "typeAssignmentMismatch": "Der Typ \"{sourceType}\" kann dem Typ \"{destType}\" nicht zugewiesen werden.",
        "typeBound": "Der Typ \"{sourceType}\" ist nicht mit dem gebundenen Typ \"{destType}\" für die Typvariablen \"{name}\" kompatibel.",
        "typeConstrainedTypeVar": "Der Typ \"{type}\" ist mit der eingeschränkten Typvariablen nicht kompatibel \"{name}\"",
        "typeIncompatible": "\"{sourceType}\" ist nicht mit \"{destType}\" kompatibel.",
        "typeNotCallable": "Der Typ \"{type}\" kann nicht aufgerufen werden.",
        "typeNotClass": "\"{type}\" ist keine Klasse.",
        "typeNotStringLiteral": "\"{type}\" ist kein Zeichenfolgenliteral.",
        "typeOfSymbol": "Der Typ von \"{name}\" ist \"{type}\".",
        "typeParamSpec": "Typ \"{type}\" ist nicht mit ParamSpec \"{name}\" kompatibel.",
        "typeUnsupported": "Typ \"{type}\" wird nicht unterstützt.",
        "typeVarDefaultOutOfScope": "Die Typvariable \"{name}\" befindet sich nicht im Bereich.",
        "typeVarIsContravariant": "Der Typparameter \"{name}\" ist kontravariant, aber \"{sourceType}\" ist kein Supertyp von \"{destType}\"",
        "typeVarIsCovariant": "Der Typparameter \"{name}\" ist kovariant, aber \"{sourceType}\" ist kein Untertyp von \"{destType}\"",
        "typeVarIsInvariant": "Der Typparameter \"{name}\" ist invariant, \"{sourceType}\" ist jedoch nicht identisch mit \"{destType}\"",
        "typeVarNotAllowed": "TypeVar oder generischer Typ mit Typargumenten sind nicht zulässig.",
        "typeVarTupleRequiresKnownLength": "TypeVarTuple kann nicht an ein Tupel unbekannter Länge gebunden werden.",
        "typeVarUnsolvableRemedy": "Geben Sie eine Überladung an, die den Rückgabetyp angibt, wenn das Argument nicht angegeben ist.",
        "typeVarsMissing": "Fehlende Typvariablen: {names}",
        "typedDictFieldMissing": "\"{name}\" fehlt in \"{type}\"",
        "typedDictFieldNotReadOnly": "\"{name}\" ist in \"{type}\" nicht schreibgeschützt.",
        "typedDictFieldNotRequired": "\"{name}\" ist in \"{type}\" nicht erforderlich.",
        "typedDictFieldRequired": "\"{name}\" ist in \"{type}\" erforderlich.",
        "typedDictFieldTypeMismatch": "Der Typ \"{type}\" kann dem Feld \"{name}\" nicht zugewiesen werden.",
        "typedDictFieldTypeRedefinition": "Der Typ in der übergeordneten Klasse ist \"{parentType}\", und der Typ in der untergeordneten Klasse ist \"{childType}\"",
        "typedDictFieldUndefined": "\"{name}\" ist ein nicht definiertes Feld im Typ \"{type}\"",
        "typedDictFinalMismatch": "\"{sourceType}\" ist aufgrund eines @final-Konflikts nicht mit \"{destType}\" kompatibel.",
        "unhashableType": "Der Typ \"{type}\" kann nicht mit einem Hash erstellt werden.",
        "uninitializedAbstractVariable": "Die Instanzvariable \"{name}\" ist in einer abstrakten Basisklasse \"{classType}\" definiert, aber nicht initialisiert.",
        "unreachableExcept": "\"{exceptionType}\" ist eine Unterklasse von \"{parentType}\"",
        "useDictInstead": "Verwenden Sie Dict[T1, T2], um einen Wörterbuchtyp anzugeben.",
        "useListInstead": "Verwenden Sie List[T], um einen Listentyp anzugeben, oder Union[T1, T2], um einen Vereinigungstyp anzugeben.",
        "useTupleInstead": "Verwenden Sie Tuple[T1, ..., Tn], um einen Tupeltyp anzugeben, oder Union[T1, T2], um einen Vereinigungstyp anzugeben.",
        "useTypeInstead": "Stattdessen Typ[T] verwenden",
        "varianceMismatchForClass": "Die Varianz des Typarguments \"{typeVarName}\" ist nicht mit der Basisklasse \"{className}\" kompatibel",
        "varianceMismatchForTypeAlias": "Die Varianz des Typarguments \"{typeVarName}\" ist nicht mit \"{typeAliasParam}\" kompatibel"
    }
}
