{
    "CodeAction": {
        "createTypeStub": "Crea stub di tipo",
        "createTypeStubFor": "Crea stub di tipo per \"{moduleName}\"",
        "executingCommand": "Esecuzione del comando",
        "filesToAnalyzeCount": "{count} file da analizzare",
        "filesToAnalyzeOne": "1 file da analizzare",
        "findingReferences": "Ricerca dei riferimenti in corso",
        "organizeImports": "Organizza importazioni",
        "renameShadowedFile": "Rinomina \"{oldFile}\" in \"{newFile}\""
    },
    "Completion": {
        "autoImportDetail": "Importazione automatica",
        "indexValueDetail": "Valore dell’indice"
    },
    "Diagnostic": {
        "abstractMethodInvocation": "Impossibile chiamare il metodo \"{method}\" perché è astratto e non implementato",
        "annotatedParamCountMismatch": "Numero di annotazioni dei parametro non corrispondente: previsto {expected} ma ricevuto {received}",
        "annotatedTypeArgMissing": "Previsto un argomento di tipo e una o più annotazioni per \"Annotato\"",
        "annotationFormatString": "Le annotazioni di tipo non possono usare valori letterali stringa di formato (stringhe f)",
        "annotationNotSupported": "Annotazione di tipo non supportata per questa istruzione",
        "annotationSpansStrings": "Le annotazioni di tipo non possono estendersi su più valori letterali stringa",
        "annotationStringEscape": "Le annotazioni di tipo non possono contenere caratteri di escape",
        "argAssignment": "Non è possibile assegnare l'argomento di tipo \"{argType}\" al parametro di tipo \"{paramType}\"",
        "argAssignmentFunction": "Non è possibile assegnare l'argomento di tipo \"{argType}\" al parametro di tipo \"{paramType}\" nella funzione \"{functionName}\"",
        "argAssignmentParam": "Non è possibile assegnare l'argomento di tipo \"{argType}\" al parametro \"{paramName}\" di tipo \"{paramType}\"",
        "argAssignmentParamFunction": "Non è possibile assegnare l'argomento di tipo \"{argType}\" al parametro \"{paramName}\" di tipo \"{paramType}\" nella funzione \"{functionName}\"",
        "argMissingForParam": "Manca l'argomento per il parametro {name}",
        "argMissingForParams": "Argomenti mancanti per i parametri {names}",
        "argMorePositionalExpectedCount": "Sono previsti {expected} altri argomenti posizionali",
        "argMorePositionalExpectedOne": "Previsto 1 altro argomento posizionale",
        "argPositional": "Argomento posizionale previsto",
        "argPositionalExpectedCount": "Sono previsti {expected} argomenti posizionali",
        "argPositionalExpectedOne": "Previsto 1 argomento posizionale",
        "argTypePartiallyUnknown": "Tipo di argomento parzialmente sconosciuto",
        "argTypeUnknown": "Il tipo di argomento è sconosciuto",
        "assertAlwaysTrue": "L'espressione assert restituisce sempre true",
        "assertTypeArgs": "\"assert_type\" prevede due argomenti posizionali",
        "assertTypeTypeMismatch": "\"assert_type\" non corrispondente: previsto \"{expected}\" ma ricevuto \"{received}\"",
        "assignmentExprComprehension": "La destinazione dell'espressione di assegnazione \"{name}\" non può usare lo stesso nome della comprensione per la destinazione",
        "assignmentExprContext": "L'espressione di assegnazione deve essere all'interno di modulo, funzione o lambda",
        "assignmentExprInSubscript": "Le espressioni di assegnazione all'interno di un pedice sono supportate solo in Python 3.10 e versioni successive",
        "assignmentInProtocol": "Le variabili di istanza o di classe all'interno di una classe Protocollo devono essere dichiarate esplicitamente nel corpo della classe",
        "assignmentTargetExpr": "L'espressione non può essere una destinazione di assegnazione",
        "asyncNotInAsyncFunction": "L'uso di \"async\" non è consentito al di fuori della funzione asincrona",
        "awaitIllegal": "L'uso di \"await\" richiede Python 3.5 o versione successiva",
        "awaitNotAllowed": "Le annotazioni di tipo non possono usare \"await\"",
        "awaitNotInAsync": "\"await\" consentito solo all'interno della funzione asincrona",
        "backticksIllegal": "Le espressioni racchiuse tra backticks non sono supportate in Python 3.x; usare la reimpostazione",
        "baseClassCircular": "La classe non può derivare da se stessa",
        "baseClassFinal": "La classe di base \"{type}\" è contrassegnata come finale e non può essere sottoclassata",
        "baseClassIncompatible": "Le classi di base di {type} sono incompatibili tra di loro",
        "baseClassInvalid": "L'argomento della classe deve essere una classe base",
        "baseClassMethodTypeIncompatible": "Le classi di base per la classe \"{classType}\" definiscono il metodo \"{name}\" in modo incompatibile",
        "baseClassUnknown": "Il tipo della classe di base è sconosciuto. È in corso il tentativo di determinare il tipo della classe derivata",
        "baseClassVariableTypeIncompatible": "Le classi di base per la classe \"{classType}\" definiscono la variabile \"{name}\" in modo incompatibile",
        "binaryOperationNotAllowed": "Operatore binario non consentito nell'annotazione di tipo",
        "bindTypeMismatch": "Non è stato possibile associare il metodo \"{methodName}\" perché non è possibile assegnare\"{type}\" al parametro \"{paramName}\"",
        "breakOutsideLoop": "\"break\" può essere usato solo all'interno di un ciclo",
        "callableExtraArgs": "Sono previsti solo due argomenti di tipo per \"Callable\"",
        "callableFirstArg": "Previsto elenco dei tipi di parametro o \"...\"",
        "callableNotInstantiable": "Non è possibile creare un'istanza del tipo \"{type}\"",
        "callableSecondArg": "È previsto un tipo restituito come secondo argomento di tipo per \"Callable\"",
        "casePatternIsIrrefutable": "Il criterio inconfutabile è consentito solo per l'ultima istruzione case",
        "classAlreadySpecialized": "Il tipo \"{type}\" è già specializzato",
        "classDecoratorTypeUnknown": "L'elemento Decorator di classe non tipizzato nasconde il tipo di classe. l'elemento Decorator verrà ignorato",
        "classDefinitionCycle": "La definizione della classe per \"{name}\" dipende da se stessa",
        "classGetItemClsParam": "__class_getitem__ override deve accettare un parametro \"cls\"",
        "classMethodClsParam": "I metodi di classe devono accettare un parametro \"cls\"",
        "classNotRuntimeSubscriptable": "Il pedice per la classe \"{name}\" genererà un'eccezione di runtime; racchiudere l'annotazione di tipo tra virgolette",
        "classPatternBuiltInArgPositional": "Il modello di classe accetta solo un sotto pattern posizionale",
        "classPatternPositionalArgCount": "Troppi modelli posizionale per la classe \"{type}\"; previsto {expected} ma ottenuto {received}",
        "classPatternTypeAlias": "\"{type}\" non può essere usato in uno schema di classe, perché è un alias di tipo specializzato",
        "classPropertyDeprecated": "Le proprietà della classe sono deprecate in Python 3.11 e non saranno supportate in Python 3.13",
        "classTypeParametersIllegal": "La sintassi del parametro del tipo di classe richiede Python 3.12 o versione successiva",
        "classVarFirstArgMissing": "È previsto un argomento tipo dopo \"ClassVar\"",
        "classVarNotAllowed": "\"ClassVar\" non consentito in questo contesto",
        "classVarOverridesInstanceVar": "La variabile di classe \"{name}\" esegue l'override della variabile di istanza con lo stesso nome nella classe \"{className}\"",
        "classVarTooManyArgs": "Previsto un solo argomento tipo dopo \"ClassVar\"",
        "classVarWithTypeVar": "Il tipo \"ClassVar\" non può includere variabili di tipo",
        "clsSelfParamTypeMismatch": "Il tipo di parametro \"{name}\" deve essere un supertipo della relativa classe \"{classType}\"",
        "codeTooComplexToAnalyze": "Il codice è troppo complesso per l'analisi. ridurre la complessità eseguendo il refactoring in subroutine o riducendo i percorsi del codice condizionale",
        "collectionAliasInstantiation": "Non è possibile creare un'istanza del tipo \"{type}\". In alternativa, usare \"{alias}\"",
        "comparisonAlwaysFalse": "La condizione restituisce sempre False perché i tipi \"{leftType}\" e \"{rightType}\" non si sovrappongono",
        "comparisonAlwaysTrue": "La condizione restituisce sempre True perché i tipi \"{leftType}\" e \"{rightType}\" non si sovrappongono",
        "comprehensionInDict": "Non è possibile usare la comprensione con altre voci del dizionario",
        "comprehensionInSet": "Non è possibile usare la comprensione con altre voci del set",
        "concatenateContext": "“Concatena” non è consentito in questo contesto",
        "concatenateParamSpecMissing": "L'ultimo argomento di tipo per \"Concatenate\" deve essere un ParamSpec o \"...\"",
        "concatenateTypeArgsMissing": "\"Concatena\" richiede almeno due argomenti tipo",
        "conditionalOperandInvalid": "Operando condizionale non valido di tipo \"{type}\"",
        "constantRedefinition": "\"{name}\" è costante (perché è in maiuscolo) e non può essere ridefinita",
        "constructorNoArgs": "Nessun argomento previsto per il costruttore \"{type}\"",
        "constructorParametersMismatch": "Mancata corrispondenza tra firma di __new__ e __init__ nella classe \"{classType}\"",
        "containmentAlwaysFalse": "L'espressione restituisce sempre False perché i tipi \"{leftType}\" e \"{rightType}\" non si sovrappongono",
        "containmentAlwaysTrue": "L'espressione restituisce sempre True perché i tipi \"{leftType}\" e \"{rightType}\" non si sovrappongono",
        "continueInFinally": "Non è possibile usare \"continue\" all'interno di una clausola finally",
        "continueOutsideLoop": "\"continue\" può essere usato solo all'interno di un ciclo",
        "coroutineInConditionalExpression": "L'espressione condizionale fa riferimento a una coroutine che restituisce sempre True",
        "dataClassBaseClassFrozen": "Una classe non bloccata non può ereditare da una classe bloccata",
        "dataClassBaseClassNotFrozen": "Una classe bloccata non può ereditare da una classe non bloccata",
        "dataClassConverterFunction": "L'argomento di tipo \"{argType}\" non è un convertitore valido per il campo \"{fieldName}\" di tipo \"{fieldType}\"",
        "dataClassConverterOverloads": "Nessun overload di \"{funcName}\" è un convertitore valido per il campo \"{fieldName}\" di tipo \"{fieldType}\"",
        "dataClassFieldWithDefault": "I campi senza valori predefiniti non possono essere visualizzati dopo i campi con valori predefiniti",
        "dataClassFieldWithPrivateName": "Il campo dataclass non può usare un nome privato",
        "dataClassFieldWithoutAnnotation": "Il campo dataclass senza annotazione del tipo causerà un'eccezione di runtime",
        "dataClassPostInitParamCount": "Dataclass __post_init__ conteggio dei parametri non corretto; il numero di campi InitVar è {expected}",
        "dataClassPostInitType": "Dataclass __post_init__ tipo di parametro del metodo non corrispondente per il campo \"{fieldName}\"",
        "dataClassSlotsOverwrite": "__slots__ è già definito nella classe",
        "dataClassTransformExpectedBoolLiteral": "Espressione prevista che restituisce in modo statico True o False",
        "dataClassTransformFieldSpecifier": "È prevista una tupla di classi o funzioni ma è stato ricevuto il tipo \"{type}\"",
        "dataClassTransformPositionalParam": "Tutti gli argomenti di \"dataclass_transform\" devono essere argomenti di parole chiave",
        "dataClassTransformUnknownArgument": "Argomento \"{name}\" non supportato da dataclass_transform",
        "dataProtocolInSubclassCheck": "I protocolli dati (che includono attributi non di metodo) non sono consentiti nelle chiamate issubclass",
        "declaredReturnTypePartiallyUnknown": "Il tipo restituito dichiarato \"{returnType}\" è parzialmente sconosciuto",
        "declaredReturnTypeUnknown": "Il tipo restituito dichiarato è sconosciuto",
        "defaultValueContainsCall": "Chiamate di funzione e oggetti modificabili non consentiti all'interno dell'espressione del valore predefinito del parametro",
        "defaultValueNotAllowed": "Il parametro con \"*\" o \"**\" non può avere un valore predefinito",
        "delTargetExpr": "Non è possibile eliminare l'espressione",
        "deprecatedClass": "La classe \"{name}\" è deprecata",
        "deprecatedConstructor": "Il costruttore per la classe \"{name}\" è deprecato",
        "deprecatedDescriptorDeleter": "Il metodo \"__delete__\" per il descrittore \"{name}\" è deprecato",
        "deprecatedDescriptorGetter": "Il metodo \"__get__\" per il descrittore \"{name}\" è deprecato",
        "deprecatedDescriptorSetter": "Il metodo \"__set__\" per il descrittore \"{name}\" è deprecato",
        "deprecatedFunction": "La funzione \"{name}\" è deprecata",
        "deprecatedMethod": "Il metodo \"{name}\" nella classe \"{className}\" è deprecato",
        "deprecatedPropertyDeleter": "Il deleter per la proprietà \"{name}\" è deprecato",
        "deprecatedPropertyGetter": "Il getter per la proprietà \"{name}\" è deprecato",
        "deprecatedPropertySetter": "Il setter per la proprietà \"{name}\" è deprecato",
        "deprecatedType": "Questo tipo è deprecato a partire da Python {version}; usa \"{replacement}\"",
        "dictExpandIllegalInComprehension": "Espansione del dizionario non consentita nella comprensione",
        "dictInAnnotation": "Espressione dizionario non consentita nell'annotazione di tipo",
        "dictKeyValuePairs": "Le voci del dizionario devono contenere coppie chiave-valore",
        "dictUnpackIsNotMapping": "Mapping previsto per l'operatore di decompressione del dizionario",
        "dunderAllSymbolNotPresent": "\"{name}\" è specificato in __all__ ma non è presente nel modulo",
        "duplicateArgsParam": "È consentito un solo parametro \"*\"",
        "duplicateBaseClass": "Classe di base duplicata non consentita",
        "duplicateCapturePatternTarget": "La destinazione di acquisizione \"{name}\" non può comparire più di una volta all'interno dello stesso schema",
        "duplicateCatchAll": "È consentita una sola clausola catch-all tranne",
        "duplicateEnumMember": "Il membro di enumerazione \"{name}\" è già dichiarato",
        "duplicateGenericAndProtocolBase": "È consentita una sola classe di base Generic(...) o Protocol[...]",
        "duplicateImport": "\"{importName}\" è stato importato più di una volta",
        "duplicateKeywordOnly": "È consentito un solo separatore \"*\"",
        "duplicateKwargsParam": "È consentito un solo parametro \"**\"",
        "duplicateParam": "“{name}\" parametro duplicato",
        "duplicatePositionOnly": "È consentito un solo parametro \"/\"",
        "duplicateStarPattern": "In una sequenza di criteri è consentito un solo criterio \"*\"",
        "duplicateStarStarPattern": "È consentita una sola voce \"**\"",
        "duplicateUnpack": "Nell'elenco è consentita una sola operazione di decompressione",
        "ellipsisAfterUnpacked": "\"...\" non può essere usato con una tupla o una tupla o TypeVarTuple non compressa",
        "ellipsisContext": "\"...\" non è consentito in questo contesto",
        "ellipsisSecondArg": "\"...\" è consentito solo come secondo di due argomenti",
        "enumClassOverride": "La classe di enumerazione \"{name}\" è finale e non può essere sottoclassata",
        "exceptionGroupIncompatible": "La sintassi del gruppo di eccezioni (\"except*\") richiede Python 3.11 o versione successiva",
        "exceptionTypeIncorrect": "\"{type}\" non deriva da BaseException",
        "exceptionTypeNotClass": "\"{type}\" non è una classe di eccezione valida",
        "exceptionTypeNotInstantiable": "Il costruttore per il tipo di eccezione \"{type}\" richiede uno o più argomenti",
        "expectedAfterDecorator": "Dichiarazione di funzione o classe prevista dopo l’elemento Decorator",
        "expectedArrow": "Previsto \"->\" seguito da un'annotazione di tipo restituito",
        "expectedAsAfterException": "Previsto \"as\" dopo il tipo di eccezione",
        "expectedAssignRightHandExpr": "Espressione prevista a destra di \"=\"",
        "expectedBinaryRightHandExpr": "Espressione prevista a destra dell'operatore",
        "expectedBoolLiteral": "È previsto True o False",
        "expectedCase": "Prevista istruzione \"case\"",
        "expectedClassName": "Nome classe previsto",
        "expectedCloseBrace": "\"{\" non è stato chiuso",
        "expectedCloseBracket": "\"[\" non è stato chiuso",
        "expectedCloseParen": "\"(\" non è stato chiuso",
        "expectedColon": "Previsto \":\"",
        "expectedComplexNumberLiteral": "È previsto un valore letterale di numero complesso per i criteri di ricerca",
        "expectedDecoratorExpr": "Il modulo dell'espressione non è supportato per l'elemento Decorator precedente a Python 3.9",
        "expectedDecoratorName": "È previsto un nome di elemento Decorator",
        "expectedDecoratorNewline": "Prevista nuova riga alla fine dell'elemento Decorator",
        "expectedDelExpr": "Espressione prevista dopo \"del\"",
        "expectedElse": "Previsto \"else\"",
        "expectedEquals": "Previsto \"=\"",
        "expectedExceptionClass": "Classe od oggetto di eccezione non valido",
        "expectedExceptionObj": "Previsto oggetto eccezione, classe eccezione o Nessuno",
        "expectedExpr": "Espressione prevista",
        "expectedFunctionAfterAsync": "Prevista definizione di funzione dopo \"async\"",
        "expectedFunctionName": "È previsto un nome di funzione dopo \"def\"",
        "expectedIdentifier": "Identificatore previsto",
        "expectedImport": "Previsto \"import\"",
        "expectedImportAlias": "Simbolo previsto dopo \"as\"",
        "expectedImportSymbols": "Sono previsti uno o più nomi di simboli dopo l'importazione",
        "expectedIn": "previsto 'in'",
        "expectedInExpr": "Espressione prevista dopo \"in\"",
        "expectedIndentedBlock": "Previsto un blocco rientrato",
        "expectedMemberName": "È previsto un nome di membro dopo \".\"",
        "expectedModuleName": "Nome del modulo previsto",
        "expectedNameAfterAs": "È previsto il nome del simbolo dopo \"as\"",
        "expectedNamedParameter": "Il parametro della parola chiave deve seguire \"*\"",
        "expectedNewline": "Prevista nuova riga",
        "expectedNewlineOrSemicolon": "Le istruzioni devono essere separate da nuove righe o punti e virgola",
        "expectedOpenParen": "Previsto \"(\"",
        "expectedParamName": "Nome del parametro previsto",
        "expectedPatternExpr": "Espressione del criterio prevista",
        "expectedPatternSubjectExpr": "Prevista espressione del soggetto del criterio",
        "expectedPatternValue": "Espressione del valore del criterio prevista nel formato \"a.b\"",
        "expectedReturnExpr": "Espressione prevista dopo \"return\"",
        "expectedSliceIndex": "Prevista espressione di indice o sezione",
        "expectedTypeNotString": "È previsto un tipo ma è stato ricevuto un valore letterale stringa",
        "expectedTypeParameterName": "Nome del parametro del tipo previsto",
        "expectedYieldExpr": "Espressione prevista nell'istruzione yield",
        "finalClassIsAbstract": "La classe \"{type}\" è contrassegnata come finale e deve implementare tutti i simboli astratti",
        "finalContext": "\"Finale\" non è consentito in questo contesto",
        "finalMethodOverride": "Il metodo \"{name}\" non può eseguire l'override del metodo finale definito nella classe \"{className}\"",
        "finalNonMethod": "Impossibile contrassegnare la funzione “{name}” @final perché non è un metodo",
        "finalReassigned": "\"{name}\" è dichiarato come Finale e non può essere riassegnato",
        "finalRedeclaration": "\"{name}\" è stato dichiarato in precedenza come Finale",
        "finalRedeclarationBySubclass": "Non è possibile ridichiarare \"{name}\" perché la classe padre \"{className}\" la dichiara come Finale",
        "finalTooManyArgs": "Previsto un singolo argomento tipo dopo \"Final\"",
        "finalUnassigned": "\"{name}\" è dichiarato Final, ma il valore non è assegnato",
        "formatStringBrace": "Parentesi graffa di chiusura singola non consentita all'interno del valore letterale f-string; usa parentesi graffa chiusa doppia",
        "formatStringBytes": "I valori letterali stringa di formato (f-string) non possono essere binari",
        "formatStringDebuggingIllegal": "L’identificatore di debug delle stringhe F \"=\" richiede Python 3.8 o versione successiva",
        "formatStringEscape": "Sequenza di escape (barra rovesciata) non consentita nella porzione di espressione di f-string prima di Python 3.12",
        "formatStringExpectedConversion": "È previsto un identificatore di conversione dopo \"!\" in f-string",
        "formatStringIllegal": "I valori letterali stringa di formato (f-string) richiedono Python 3.6 o versione successiva",
        "formatStringInPattern": "Stringa di formato non consentita nel criterio",
        "formatStringNestedFormatSpecifier": "Espressioni annidate troppo in profondità nell'identificatore di stringa di formato",
        "formatStringNestedQuote": "Le stringhe annidate all'interno di una stringa f non possono usare lo stesso carattere virgolette della stringa f prima di Python 3.12",
        "formatStringUnicode": "I valori letterali stringa di formato (f-string) non possono essere unicode",
        "formatStringUnterminated": "Espressione senza terminazione in f-string; previsto \"}\".",
        "functionDecoratorTypeUnknown": "L'elemento Decorator della funzione non tipizzato nasconde il tipo di funzione; l'elemento Decorator verrà ignorato",
        "functionInConditionalExpression": "L'espressione condizionale fa riferimento a una funzione che restituisce sempre True",
        "functionTypeParametersIllegal": "La sintassi del parametro del tipo di funzione richiede Python 3.12 o versione successiva",
        "futureImportLocationNotAllowed": "Le importazioni da __future__ devono trovarsi all'inizio del file",
        "generatorAsyncReturnType": "Il tipo restituito della funzione del generatore asincrono deve essere compatibile con \"AsyncGenerator[{yieldType}, Any]\"",
        "generatorNotParenthesized": "Le espressioni del generatore devono essere racchiuse tra parentesi se non è l'unico argomento",
        "generatorSyncReturnType": "Il tipo restituito della funzione del generatore deve essere compatibile con \"Generator[{yieldType}, Any, Any]\"",
        "genericBaseClassNotAllowed": "Non è possibile usare la classe di base \"Generic\" con la sintassi del parametro di tipo",
        "genericClassAssigned": "Non è possibile assegnare il tipo di classe generico",
        "genericClassDeleted": "Non è possibile eliminare il tipo di classe generico",
        "genericInstanceVariableAccess": "L'accesso alla variabile di istanza generica tramite la classe è ambiguo",
        "genericNotAllowed": "\"Generic\" non valido in questo contesto",
        "genericTypeAliasBoundTypeVar": "L'alias di tipo generico all'interno della classe non può usare variabili di tipo associate {names}",
        "genericTypeArgMissing": "\"Generico\" richiede almeno un argomento di tipo",
        "genericTypeArgTypeVar": "L'argomento di tipo per \"Generic\" deve essere una variabile di tipo",
        "genericTypeArgUnique": "Gli argomenti di tipo per \"Generic\" devono essere univoci",
        "globalReassignment": "\"{name}\" è assegnato prima della dichiarazione globale",
        "globalRedefinition": "\"{name}\" è già stato dichiarato globale",
        "implicitStringConcat": "Concatenazione implicita di stringhe non consentita",
        "importCycleDetected": "Ciclo rilevato nella catena di importazione",
        "importDepthExceeded": "La profondità della catena di importazione ha superato {depth}",
        "importResolveFailure": "Non è stato possibile risolvere l'importazione \"{importName}\"",
        "importSourceResolveFailure": "Non è stato possibile risolvere l'importazione \"{importName}\" dall’origine",
        "importSymbolUnknown": "\"{name}\" è un simbolo di importazione sconosciuto",
        "incompatibleMethodOverride": "Il metodo \"{name}\" esegue l'override della classe \"{className}\" in modo incompatibile",
        "inconsistentIndent": "Il valore dell'annullamento del rientro non corrisponde al rientro precedente",
        "inconsistentTabs": "Uso incoerente di tabulazioni e spazi nel rientro",
        "initMustReturnNone": "Il tipo restituito di \"__init__\" deve essere None",
        "initSubclassCallFailed": "Argomenti di parola chiave non corretti per il metodo __init_subclass__",
        "initSubclassClsParam": "__init_subclass__ override deve accettare un parametro \"cls\"",
        "initVarNotAllowed": "\"InitVar\" non consentito in questo contesto",
        "instanceMethodSelfParam": "I metodi di istanza devono accettare un parametro \"self\"",
        "instanceVarOverridesClassVar": "La variabile di istanza \"{name}\" esegue l'override della variabile di classe con lo stesso nome nella classe \"{className}\"",
        "instantiateAbstract": "Non è possibile creare un'istanza di classe astratta \"{type}\"",
        "instantiateProtocol": "Non è possibile creare un'istanza della classe di protocollo \"{type}\"",
        "internalBindError": "Errore interno durante l'associazione del file \"{file}\": {message}",
        "internalParseError": "Si è verificato un errore interno durante l'analisi del file \"{file}\": {message}",
        "internalTypeCheckingError": "Errore interno durante il controllo del tipo del file \"{file}\": {message}",
        "invalidIdentifierChar": "Carattere non valido nell'identificatore",
        "invalidStubStatement": "L'istruzione non ha significato all'interno di un file stub di tipo",
        "invalidTokenChars": "Carattere non valido \"{text}\" nel token",
        "isInstanceInvalidType": "Il secondo argomento di \"isinstance\" deve essere una classe o una tupla di classi",
        "isSubclassInvalidType": "Il secondo argomento di \"issubclass\" deve essere una classe o una tupla di classi",
        "keyValueInSet": "Le coppie chiave-valore non sono consentite all'interno di un set",
        "keywordArgInTypeArgument": "Gli argomenti delle parole chiave non possono essere usati negli elenchi di argomenti tipo",
        "keywordOnlyAfterArgs": "Separatore di argomenti solo parola chiave non consentito dopo il parametro \"*\"",
        "keywordParameterMissing": "Uno o più parametri di parole chiave devono seguire il parametro \"*\"",
        "keywordSubscriptIllegal": "Gli argomenti delle parole chiave all'interno di pedici non sono supportati",
        "lambdaReturnTypePartiallyUnknown": "Il tipo restituito dell'espressione lambda \"{returnType}\" è parzialmente sconosciuto",
        "lambdaReturnTypeUnknown": "Il tipo restituito di lambda è sconosciuto",
        "listAssignmentMismatch": "Non è possibile assegnare l'espressione con tipo \"{type}\" all'elenco di destinazione",
        "listInAnnotation": "Espressione elenco non consentita nell'annotazione di tipo",
        "literalEmptyArgs": "Previsto uno o più argomenti tipo dopo \"Valore letterale\"",
        "literalNotAllowed": "Non è possibile usare \"Literal\" in questo contesto senza un argomento tipo",
        "literalNotCallable": "Non è possibile creare un'istanza del tipo letterale",
        "literalUnsupportedType": "Gli argomenti di tipo per \"Literal\" devono essere None, un valore letterale (int, bool, str o bytes) o un valore di enumerazione",
        "matchIncompatible": "Le istruzioni match richiedono Python 3.10 o versione successiva",
        "matchIsNotExhaustive": "I case all'interno dell'istruzione match non gestiscono in modo completo tutti i valori",
        "maxParseDepthExceeded": "È stata superata la profondità massima di analisi; suddividere l'espressione in sottoespressioni più piccole",
        "memberAccess": "Non è possibile accedere al membro \"{name}\" per il tipo \"{type}\"",
        "memberDelete": "Non è possibile eliminare il membro \"{name}\" per il tipo \"{type}\"",
        "memberSet": "Non è possibile assegnare il membro \"{name}\" per il tipo \"{type}\"",
        "metaclassConflict": "La metaclasse di una classe derivata deve essere una sottoclasse delle metaclassi di tutte le relative classi di base",
        "metaclassDuplicate": "È possibile specificare una sola metaclasse",
        "metaclassIsGeneric": "La metaclasse non può essere generica",
        "methodNotDefined": "Metodo \"{name}\" non definito",
        "methodNotDefinedOnType": "\"{name}\" metodo non definito nel tipo \"{type}\"",
        "methodOrdering": "Non è possibile creare un ordinamento coerente del metodo",
        "methodOverridden": "\"{name}\" esegue l'override del metodo con lo stesso nome nella classe \"{className}\" con un tipo non compatibile \"{type}\".",
        "methodReturnsNonObject": "Il metodo \"{name}\" non restituisce un oggetto",
        "missingSuperCall": "Il metodo \"{methodName}\" non chiama il metodo con lo stesso nome nella classe padre",
        "moduleAsType": "Il modulo non può essere usato come tipo",
        "moduleNotCallable": "Modulo non chiamabile",
        "moduleUnknownMember": "\"{memberName}\" non è un membro noto del modulo \"{moduleName}\"",
        "namedExceptAfterCatchAll": "Una clausola except denominata non può trovarsi dopo la clausola catch-all except",
        "namedParamAfterParamSpecArgs": "Il parametro della parola chiave \"{name}\" non può essere visualizzato nella firma dopo il parametro ParamSpec args",
        "namedTupleEmptyName": "I nomi all'interno di una tupla denominata non possono essere vuoti",
        "namedTupleEntryRedeclared": "Non è possibile eseguire l'override di \"{name}\" perché la classe padre \"{className}\" è una tupla denominata",
        "namedTupleFirstArg": "Previsto nome della classe di tupla denominata come primo argomento",
        "namedTupleMultipleInheritance": "L'ereditarietà multipla con NamedTuple non è supportata",
        "namedTupleNameKeyword": "I nomi dei campi non possono essere una parola chiave",
        "namedTupleNameType": "Prevista tupla a due voci che specifica il nome e il tipo della voce",
        "namedTupleNameUnique": "I nomi all'interno di una tupla denominata devono essere univoci",
        "namedTupleNoTypes": "\"namedtuple\" non fornisce tipi per le voci di tupla; usare invece \"NamedTuple\"",
        "namedTupleSecondArg": "È previsto un elenco di voci di tupla denominate come secondo argomento",
        "newClsParam": "__new__ override deve accettare un parametro \"cls\"",
        "newTypeAnyOrUnknown": "Il secondo argomento di NewType deve essere una classe nota, non Any o Unknown",
        "newTypeBadName": "Il primo argomento di NewType deve essere un valore letterale stringa",
        "newTypeLiteral": "Non è possibile usare NewType con il tipo Literal",
        "newTypeNameMismatch": "NewType deve essere assegnato a una variabile con lo stesso nome",
        "newTypeNotAClass": "Classe prevista come secondo argomento di NewType",
        "newTypeParamCount": "NewType richiede due argomenti posizionali",
        "newTypeProtocolClass": "Non è possibile usare NewType con il tipo strutturale (un protocollo o una classe TypedDict)",
        "noOverload": "Nessun overload per \"{name}\" corrisponde agli argomenti specificati",
        "noReturnContainsReturn": "La funzione con tipo restituito dichiarato \"NoReturn\" non può includere un'istruzione return",
        "noReturnContainsYield": "La funzione con il tipo restituito dichiarato \"NoReturn\" non può includere un'istruzione yield",
        "noReturnReturnsNone": "La funzione con tipo restituito dichiarato \"NoReturn\" non può restituire \"None\"",
        "nonDefaultAfterDefault": "L'argomento non predefinito segue l'argomento predefinito",
        "nonLocalInModule": "Dichiarazione non locale non consentita a livello di modulo",
        "nonLocalNoBinding": "Non è stata trovata alcuna associazione per \"{name}\" non locale",
        "nonLocalReassignment": "\"{name}\" è assegnato prima della dichiarazione non locale",
        "nonLocalRedefinition": "\"{name}\" è già stato dichiarato non locale",
        "noneNotCallable": "Non è possibile chiamare l'oggetto di tipo \"None\"",
        "noneNotIterable": "Impossibile utilizzare l'oggetto di tipo \"None\" come valore iterabile",
        "noneNotSubscriptable": "L'oggetto di tipo \"Nessuno\" non è sottoponibile a pedice",
        "noneNotUsableWith": "Impossibile utilizzare l'oggetto di tipo \"None\" con \"with\"",
        "noneOperator": "Operatore \"{operator}\" non supportato per \"None\"",
        "noneUnknownMember": "\"{name}\" non è un membro noto di \"None\"",
        "notRequiredArgCount": "Previsto un singolo argomento tipo dopo \"NotRequired\"",
        "notRequiredNotInTypedDict": "\"NotRequired\" non è consentito in questo contesto",
        "objectNotCallable": "L'oggetto di tipo \"{type}\" non è chiamabile",
        "obscuredClassDeclaration": "La dichiarazione di classe \"{name}\" è oscurata da una dichiarazione con lo stesso nome",
        "obscuredFunctionDeclaration": "La dichiarazione della funzione \"{name}\" è oscurata da una dichiarazione con lo stesso nome",
        "obscuredMethodDeclaration": "La dichiarazione del metodo \"{name}\" è oscurata da una dichiarazione con lo stesso nome",
        "obscuredParameterDeclaration": "La dichiarazione del parametro \"{name}\" è oscurata da una dichiarazione con lo stesso nome",
        "obscuredTypeAliasDeclaration": "La dichiarazione dell'alias di tipo \"{name}\" è nascosta da una dichiarazione con lo stesso nome",
        "obscuredVariableDeclaration": "La dichiarazione \"{name}\" è oscurata da una dichiarazione con lo stesso nome",
        "operatorLessOrGreaterDeprecated": "L'operatore \"<>\" non è supportato in Python 3. Usare invece \"!=\"",
        "optionalExtraArgs": "Previsto un argomento tipo dopo \"Facoltativo\"",
        "orPatternIrrefutable": "Criterio inconfutabile consentito solo come ultimo criterio secondario in un criterio \"o\"",
        "orPatternMissingName": "Tutti i criteri secondari all'interno di un criterio \"or\" devono avere come destinazione gli stessi nomi",
        "overlappingKeywordArgs": "Il dizionario tipizzato si sovrappone al parametro della parola chiave: {names}",
        "overlappingOverload": "L'overload {obscured} per \"{name}\" non verrà mai usato perché i parametri si sovrappongono all'overload {obscuredBy}",
        "overloadAbstractMismatch": "I metodi di overload devono essere tutti astratti o no",
        "overloadClassMethodInconsistent": "Gli overload per \"{name}\" usano @classmethod in modo incoerente",
        "overloadFinalInconsistencyImpl": "L'overload per “{name}” è contrassegnato @final ma l'implementazione non lo è",
        "overloadFinalInconsistencyNoImpl": "L'overload {index} per “{name}” è contrassegnato @final ma l'overload 1 non lo è",
        "overloadImplementationMismatch": "L'implementazione di overload non è coerente con la firma dell'overload {index}",
        "overloadReturnTypeMismatch": "L'overload {prevIndex} per \"{name}\" si sovrappone all'overload {newIndex} e restituisce un tipo incompatibile",
        "overloadStaticMethodInconsistent": "Gli overload per \"{name}\" usano @staticmethod in modo incoerente",
        "overloadWithoutImplementation": "\"{name}\" è contrassegnato come overload, ma non viene fornita alcuna implementazione",
        "overriddenMethodNotFound": "Il metodo \"{name}\" è contrassegnato come override, ma non è presente alcun metodo di base con lo stesso nome",
        "overrideDecoratorMissing": "Il metodo \"{name}\" non è contrassegnato come override, ma esegue l'override di un metodo nella classe \"{className}\"",
        "paramAfterKwargsParam": "Il parametro non può seguire il parametro \"**\"",
        "paramAlreadyAssigned": "Il parametro \"{name}\" è già assegnato",
        "paramAnnotationMissing": "Annotazione di tipo mancante per il parametro \"{name}\"",
        "paramAssignmentMismatch": "Non è possibile assegnare l'espressione di tipo \"{sourceType}\" al parametro di tipo \"{paramType}\"",
        "paramNameMissing": "Nessun parametro denominato \"{name}\"",
        "paramSpecArgsKwargsUsage": "I membri \"args\" e \"kwargs\" di ParamSpec devono essere entrambi visualizzati all'interno di una firma di funzione",
        "paramSpecArgsMissing": "Gli argomenti per ParamSpec \"{type}\" sono mancanti",
        "paramSpecArgsUsage": "Il membro \"args\" di ParamSpec è valido solo se usato con il parametro *args",
        "paramSpecAssignedName": "ParamSpec deve essere assegnato a una variabile denominata \"{name}\"",
        "paramSpecContext": "ParamSpec non è consentito in questo contesto",
        "paramSpecDefaultNotTuple": "Sono previsti puntini di sospensione, un'espressione di tupla o ParamSpec per il valore predefinito di ParamSpec",
        "paramSpecFirstArg": "Nome previsto di ParamSpec come primo argomento",
        "paramSpecKwargsUsage": "Il membro \"kwargs\" di ParamSpec è valido solo se usato con il parametro **kwargs",
        "paramSpecNotUsedByOuterScope": "ParamSpec \"{name}\" non ha significato in questo contesto",
        "paramSpecScopedToReturnType": "L’ambito ParamSpec \"{name}\" è un elemento richiamabile all'interno del tipo restituito e non può essere usato come riferimento nel corpo della funzione",
        "paramSpecUnknownArg": "ParamSpec non supporta più di un argomento",
        "paramSpecUnknownMember": "\"{name}\" non è un membro noto di ParamSpec",
        "paramSpecUnknownParam": "\"{name}\" è un parametro sconosciuto per ParamSpec",
        "paramTypeCovariant": "Non è possibile usare la variabile di tipo covariante nel tipo di parametro",
        "paramTypePartiallyUnknown": "Tipo di parametro \"{paramName}\" parzialmente sconosciuto",
        "paramTypeUnknown": "Tipo di parametro \"{paramName}\" sconosciuto",
        "parenthesizedContextManagerIllegal": "Le parentesi all'interno dell'istruzione \"con\" richiedono Python 3.9 o versione successiva",
        "patternNeverMatches": "Il criterio non verrà mai confrontato per il tipo di oggetto \"{type}\"",
        "positionArgAfterNamedArg": "L'argomento posizionale non può essere visualizzato dopo gli argomenti della parola chiave",
        "positionOnlyAfterArgs": "Separatore di parametri di sola posizione non consentito dopo il parametro \"*\"",
        "positionOnlyAfterKeywordOnly": "Il parametro \"/\" deve essere visualizzato prima del parametro \"*\"",
        "positionOnlyAfterNon": "Il parametro di sola posizione non è consentito dopo un parametro che non è di sola posizione",
        "positionOnlyFirstParam": "Separatore di argomenti di sola posizione non consentito come primo parametro",
        "positionOnlyIncompatible": "Il separatore di parametri di sola posizione richiede Python 3.8 o versione successiva",
        "privateImportFromPyTypedModule": "\"{name}\" non è esportato dal modulo \"{module}\"",
        "privateUsedOutsideOfClass": "\"{name}\" è privato e utilizzato all'esterno del modulo in cui è dichiarato",
        "privateUsedOutsideOfModule": "\"{name}\" è privato e utilizzato all'esterno del modulo in cui è dichiarato",
        "propertyOverridden": "\"{name}\" esegue erroneamente l’override di una proprietà con lo stesso nome nella classe \"{className}\"",
        "propertyStaticMethod": "Metodi statici non consentiti per getter, setter o deleter di proprietà",
        "protectedUsedOutsideOfClass": "\"{name}\" è protetto e usato al di fuori della classe in cui è dichiarato",
        "protocolBaseClass": "La classe di protocollo \"{classType}\" non può derivare dalla classe non di protocollo \"{baseType}\".",
        "protocolBaseClassWithTypeArgs": "Gli argomenti tipo non sono consentiti con la classe Protocollo quando si usa la sintassi dei parametri tipo",
        "protocolIllegal": "L'uso del \"protocollo\" richiede Python 3.7 o versione successiva",
        "protocolNotAllowed": "\"Protocol\" non può essere usato in questo contesto",
        "protocolUnsafeOverlap": "La classe si sovrappone a \"{name}\" in modo non sicuro e può produrre una corrispondenza in fase di esecuzione",
        "protocolVarianceContravariant": "La variabile di tipo \"{variable}\" usata nel protocollo generico \"{class}\" deve essere controvariante",
        "protocolVarianceCovariant": "La variabile di tipo \"{variable}\" usata nel protocollo generico \"{class}\" deve essere covariante",
        "protocolVarianceInvariant": "La variabile di tipo \"{variable}\" usata nel protocollo generico \"{class}\" deve essere invariabile",
        "pyrightCommentInvalidDiagnosticBoolValue": "La direttiva di commento Pyright deve essere seguita da \"=\" e da un valore true o false",
        "pyrightCommentInvalidDiagnosticSeverityValue": "La direttiva di commento Pyright deve essere seguita da \"=\" e da un valore true, false, error, warning, information o none",
        "pyrightCommentMissingDirective": "Il commento pyright deve essere seguito da una direttiva (di base o restrittiva) o da una regola di diagnostica",
        "pyrightCommentNotOnOwnLine": "I commenti Pyright usati per controllare le impostazioni a livello di file devono essere visualizzati nella propria riga",
        "pyrightCommentUnknownDiagnosticRule": "\"{rule}\" è una regola di diagnostica sconosciuta per il commento pyright",
        "pyrightCommentUnknownDiagnosticSeverityValue": "\"{value}\" non è un valore valido per il commento pyright; previsto true, false, error, warning, information o none",
        "pyrightCommentUnknownDirective": "\"{directive}\" è una direttiva sconosciuta per il commento pyright; previsto \"strict\" o \"basic\"",
        "readOnlyArgCount": "Previsto un singolo argomento tipo dopo \"ReadOnly\"",
        "readOnlyNotInTypedDict": "\"ReadOnly\" non consentito in questo contesto",
        "recursiveDefinition": "Non è stato possibile determinare il tipo di \"{name}\" perché fa riferimento a se stesso",
        "relativeImportNotAllowed": "Le importazioni relative non possono essere usate con il modulo \"import .a\". Usare invece \"from . import a\"",
        "requiredArgCount": "Previsto un singolo argomento tipo dopo \"Obbligatorio\"",
        "requiredNotInTypedDict": "\"Required\" non è consentito in questo contesto",
        "returnInAsyncGenerator": "L’istruzione return con valore non è consentita nel generatore asincrono",
        "returnMissing": "La funzione con tipo restituito dichiarato \"{returnType}\" deve restituire un valore in tutti i percorsi di codice",
        "returnOutsideFunction": "\"return\" può essere usata solo all'interno di una funzione.",
        "returnTypeContravariant": "Non è possibile usare la variabile di tipo controvariante nel tipo restituito",
        "returnTypeMismatch": "Non è possibile assegnare l'espressione di tipo \"{exprType}\" al tipo restituito \"{returnType}\"",
        "returnTypePartiallyUnknown": "Il tipo restituito \"{returnType}\" è parzialmente sconosciuto",
        "returnTypeUnknown": "Il tipo restituito è sconosciuto",
        "revealLocalsArgs": "Non è previsto alcun argomento per la chiamata \"reveal_locals\"",
        "revealLocalsNone": "Non sono presenti variabili locali in questo ambito",
        "revealTypeArgs": "Previsto un singolo argomento posizionale per la chiamata \"reveal_type\"",
        "revealTypeExpectedTextArg": "L'argomento \"expected_text\" per la funzione \"reveal_type\" deve essere un valore letterale str",
        "revealTypeExpectedTextMismatch": "Testo di tipo non corrispondente; previsto \"{expected}\" ma ricevuto \"{received}\"",
        "revealTypeExpectedTypeMismatch": "Tipo non corrispondente; previsto \"{expected}\" ma ricevuto \"{received}\"",
        "selfTypeContext": "\"Self\" non è valido in questo contesto",
        "selfTypeMetaclass": "Impossibile utilizzare “Self” all'interno di una metaclasse (una sottoclasse di “type”)",
        "selfTypeWithTypedSelfOrCls": "Non è possibile usare \"Self\" in una funzione con un parametro 'self' o 'cls' con un'annotazione di tipo diversa da \"Self\"",
        "setterGetterTypeMismatch": "Il tipo di valore del setter di proprietà non è assegnabile al tipo restituito del getter",
        "singleOverload": "\"{name}\" è contrassegnato come overload, ma mancano altri overload",
        "slotsAttributeError": "\"{name}\" non è specificato in __slots__",
        "slotsClassVarConflict": "\"{name}\" è in conflitto con la variabile di istanza dichiarata in __slots__",
        "starPatternInAsPattern": "Il modello a stella non può essere usato con la destinazione \"as\"",
        "starPatternInOrPattern": "Il modello a stella non può essere ORed all'interno di altri modelli",
        "starStarWildcardNotAllowed": "** non può essere usato con il carattere jolly \"_\"",
        "staticClsSelfParam": "I metodi statici non devono accettare un parametro \"self\" o \"cls\"",
        "stdlibModuleOverridden": "\"{path}\" sta eseguendo l'override del modulo stdlib \"{name}\"",
        "stringNonAsciiBytes": "Carattere non ASCII non consentito nel valore letterale stringa dei byte",
        "stringNotSubscriptable": "L'espressione stringa non può essere in pedice nell'annotazione di tipo. Racchiudere l'intera annotazione tra virgolette",
        "stringUnsupportedEscape": "Sequenza di escape non supportata nel valore letterale stringa",
        "stringUnterminated": "Il valore letterale stringa non è terminato",
        "stubFileMissing": "File di stub non trovato per \"{importName}\"",
        "stubUsesGetAttr": "Il file dello stub di tipo è incompleto; \"__getattr__\" nasconde gli errori di tipo per il modulo",
        "sublistParamsIncompatible": "I parametri dell’elenco secondario non sono supportati in Python 3.x",
        "superCallArgCount": "Non sono previsti più di due argomenti per la chiamata \"super\".",
        "superCallFirstArg": "È previsto un tipo di classe come primo argomento della chiamata \"super\", ma è stato ricevuto \"{type}\"",
        "superCallSecondArg": "Il secondo argomento della chiamata \"super\" deve essere un oggetto o una classe che deriva da \"{type}\"",
        "superCallZeroArgForm": "Il modulo zero-argument della chiamata \"super\" è valido solo all'interno di un metodo",
        "superCallZeroArgFormStaticMethod": "Il modulo zero-argument della chiamata \"super\" non è valido all'interno di un metodo statico",
        "symbolIsPossiblyUnbound": "\"{name}\" potrebbe non essere associato",
        "symbolIsUnbound": "\"{name}\" non associato",
        "symbolIsUndefined": "\"{name}\" non è definito",
        "symbolOverridden": "\"{name}\" esegue l'override del simbolo con lo stesso nome nella classe \"{className}\"",
        "ternaryNotAllowed": "Espressione ternaria non consentita nell'annotazione di tipo",
        "totalOrderingMissingMethod": "La classe deve definire uno dei valori di \"__lt__\", \"__le__\", \"__gt__\" o \"__ge__\" per usare total_ordering",
        "trailingCommaInFromImport": "Virgola finale non consentita senza parentesi circostanti",
        "tryWithoutExcept": "L'istruzione Try deve contenere almeno una clausola except or finally",
        "tupleAssignmentMismatch": "Non è possibile assegnare l'espressione con tipo \"{type}\" alla tupla di destinazione",
        "tupleInAnnotation": "Espressione di tupla non consentita nell'annotazione di tipo",
        "tupleIndexOutOfRange": "L'indice {index} non è compreso nell'intervallo per il tipo {type}",
        "typeAliasIllegalExpressionForm": "Modulo di espressione non valido per la definizione dell'alias di tipo",
        "typeAliasIsRecursiveDirect": "L'alias di tipo \"{name}\" non può usare se stesso nella relativa definizione",
        "typeAliasNotInModuleOrClass": "TypeAlias può essere definito solo all'interno di un modulo o di una classe",
        "typeAliasRedeclared": "\"{name}\" è dichiarato come TypeAlias e può essere assegnato una sola volta",
        "typeAliasStatementBadScope": "Un'istruzione Tipo può essere usata solo all'interno di un modulo o di un ambito della classe",
        "typeAliasStatementIllegal": "L'istruzione alias di tipo richiede Python 3.12 o versione successiva",
        "typeAliasTypeBaseClass": "Impossibile utilizzare come classe di base un alias di tipo definito in un'istruzione \"type\"",
        "typeAliasTypeMustBeAssigned": "TypeAliasType deve essere assegnato a una variabile con lo stesso nome dell'alias di tipo",
        "typeAliasTypeNameArg": "Il primo argomento di TypeAliasType deve essere un valore letterale stringa che rappresenta il nome dell'alias di tipo",
        "typeAliasTypeNameMismatch": "Il nome dell'alias di tipo deve corrispondere al nome della variabile a cui è assegnato",
        "typeAliasTypeParamInvalid": "L'elenco dei parametri del tipo deve essere una tupla contenente solo TypeVar, TypeVarTuple o ParamSpec.",
        "typeAnnotationCall": "Espressione di chiamata non consentita nell'espressione di tipo",
        "typeAnnotationVariable": "Variabile non consentita nell'espressione di tipo",
        "typeAnnotationWithCallable": "L'argomento di tipo per \"type\" deve essere una classe. I callable non sono supportati",
        "typeArgListExpected": "Previsto ParamSpec, puntini di sospensione o elenco di tipi",
        "typeArgListNotAllowed": "Espressione di elenco non consentita per questo argomento tipo",
        "typeArgsExpectingNone": "Non sono previsti argomenti di tipo per la classe \"{name}\"",
        "typeArgsMismatchOne": "Previsto un argomento di tipo, ricevuto {received}",
        "typeArgsMissingForAlias": "Sono previsti argomenti di tipo per l'alias di tipo generico \"{name}\"",
        "typeArgsMissingForClass": "Argomenti tipo previsti per la classe generica \"{name}\"",
        "typeArgsTooFew": "Troppo pochi argomenti tipo forniti per \"{name}\"; previsto {expected} ma ricevuto {received}",
        "typeArgsTooMany": "Troppi argomenti tipo forniti per \"{name}\"; previsto {expected} ma ricevuto {received}",
        "typeAssignmentMismatch": "Impossibile assegnare l'espressione di tipo \"{sourceType}\" al tipo dichiarato \"{destType}\"",
        "typeAssignmentMismatchWildcard": "Il simbolo di importazione \"{name}\" ha il tipo \"{sourceType}\", che non può essere assegnato al tipo dichiarato \"{destType}\"",
        "typeCallNotAllowed": "la chiamata type() non deve essere usata nell'annotazione di tipo",
        "typeCheckOnly": "\"{name}\" è contrassegnato come @type_check_only e può essere utilizzato solo nelle annotazioni tipo",
        "typeCommentDeprecated": "L'uso dei commenti di tipo è deprecato. Usare l'annotazione di tipo",
        "typeExpectedClass": "È prevista un'espressione di tipo ma è stato ricevuto \"{type}\"",
        "typeGuardArgCount": "È previsto un singolo argomento di tipo dopo \"TypeGuard\" o \"TypeIs\"",
        "typeGuardParamCount": "Le funzioni e i metodi di protezione dei tipi definiti dall'utente devono avere almeno un parametro di input",
        "typeIsReturnType": "Il tipo restituito di TypeIs (\"{returnType}\") non è coerente con il tipo di parametro di valore (\"{type}\")",
        "typeNotAwaitable": "\"{type}\" non è awaitable",
        "typeNotIntantiable": "Non è possibile creare un'istanza di \"{type}\"",
        "typeNotIterable": "\"{type}\" non è iterabile",
        "typeNotSpecializable": "Non è stato possibile specializzare il tipo \"{type}\"",
        "typeNotSubscriptable": "L'oggetto di tipo \"{type}\" non è sottoponibile a script",
        "typeNotSupportBinaryOperator": "L'operatore \"{operator}\" non è supportato per i tipi \"{leftType}\" e \"{rightType}\".",
        "typeNotSupportBinaryOperatorBidirectional": "L'operatore \"{operator}\" non è supportato per i tipi \"{leftType}\" e \"{rightType}\" quando il tipo previsto è \"{expectedType}\"",
        "typeNotSupportUnaryOperator": "Operatore \"{operator}\" non supportato per il tipo \"{type}\"",
        "typeNotSupportUnaryOperatorBidirectional": "L'operatore \"{operator}\" non è supportato per il tipo \"{type}\" quando il tipo previsto è \"{expectedType}\"",
        "typeNotUsableWith": "Impossibile utilizzare l'oggetto di tipo \"{type}\" con \"with\" perché non implementa {method}",
        "typeParameterBoundNotAllowed": "Il vincolo o il binding non possono essere usati con un parametro di tipo variadic o ParamSpec",
        "typeParameterConstraintTuple": "Il vincolo del parametro di tipo deve essere una tupla di due o più tipi",
        "typeParameterExistingTypeParameter": "Il parametro di tipo \"{name}\" è già in uso",
        "typeParameterNotDeclared": "Il parametro di tipo \"{name}\" non è incluso nell'elenco dei parametri di tipo per \"{container}\"",
        "typeParametersMissing": "È necessario specificare almeno un parametro di tipo",
        "typePartiallyUnknown": "Tipo di \"{name}\" parzialmente sconosciuto",
        "typeUnknown": "Il tipo di \"{name}\" è sconosciuto",
        "typeVarAssignedName": "TypeVar deve essere assegnato a una variabile denominata \"{name}\"",
        "typeVarAssignmentMismatch": "Non è possibile assegnare il tipo \"{type}\" alla variabile di tipo \"{name}\"",
        "typeVarBoundAndConstrained": "TypeVar non può essere contemporaneamente associato e vincolato",
        "typeVarBoundGeneric": "Il tipo associato a TypeVar non può essere generico",
        "typeVarConstraintGeneric": "Il tipo di vincolo TypeVar non può essere generico",
        "typeVarDefaultBoundMismatch": "Il tipo predefinito TypeVar deve essere un sottotipo del tipo associato",
        "typeVarDefaultConstraintMismatch": "Il tipo predefinito TypeVar deve essere uno dei tipi vincolati",
        "typeVarDefaultIllegal": "I tipi predefiniti delle variabili di tipo richiedono Python 3.13 o versione successiva",
        "typeVarDefaultInvalidTypeVar": "Il parametro di tipo \"{name}\" ha un tipo predefinito che fa riferimento a una o più variabili di tipo non compreso nell'ambito",
        "typeVarFirstArg": "Nome previsto di TypeVar come primo argomento",
        "typeVarNoMember": "TypeVar \"{type}\" non ha membri \"{name}\"",
        "typeVarNotSubscriptable": "TypeVar \"{type}\" non sottoponibile a script",
        "typeVarNotUsedByOuterScope": "La variabile di tipo \"{name}\" non ha significato in questo contesto",
        "typeVarPossiblyUnsolvable": "La variabile di tipo \"{name}\" potrebbe non essere risolta se il chiamante non fornisce alcun argomento per il parametro \"{param}\"",
        "typeVarScopedToReturnType": "La variabile di tipo \"{name}\" ha come ambito un elemento richiamabile all'interno del tipo restituito e non può essere usato come riferimento nel corpo della funzione",
        "typeVarSingleConstraint": "TypeVar deve contenere almeno due tipi vincolati",
        "typeVarTupleConstraints": "TypeVarTuple non può avere vincoli di valore",
        "typeVarTupleContext": "TypeVarTuple non è consentito in questo contesto",
        "typeVarTupleDefaultNotUnpacked": "Il tipo predefinito TypeVarTuple deve essere una tupla non compressa o TypeVarTuple",
        "typeVarTupleMustBeUnpacked": "L'operatore Decomprimi è obbligatorio per il valore TypeVarTuple",
        "typeVarTupleUnknownParam": "\"{name}\" è un parametro sconosciuto per TypeVar",
        "typeVarUnknownParam": "\"{name}\" è un parametro sconosciuto per TypeVar",
        "typeVarUsedByOuterScope": "TypeVar \"{name}\" già in uso da un ambito esterno",
        "typeVarUsedOnlyOnce": "TypeVar \"{name}\" viene visualizzato una sola volta nella firma della funzione generica",
        "typeVarVariance": "TypeVar non può essere covariante e controvariante",
        "typeVarWithDefaultFollowsVariadic": "TypeVar \"{typeVarName}\" ha un valore predefinito e non può seguire TypeVarTuple \"{variadicName}\"",
        "typeVarWithoutDefault": "\"{name}\" non può essere visualizzato dopo \"{other}\" nell'elenco dei parametri del tipo, perché non ha un tipo predefinito",
        "typeVarsNotInGenericOrProtocol": "Generic[] o Protocol[] deve includere tutte le variabili di tipo",
        "typedDictAccess": "Non è stato possibile accedere all'elemento in TypedDict",
        "typedDictAssignedName": "TypedDict deve essere assegnato a una variabile denominata \"{name}\"",
        "typedDictBadVar": "Le classi TypedDict possono contenere solo annotazioni di tipo",
        "typedDictBaseClass": "Anche tutte le classi di base per le classi TypedDict devono essere classi TypedDict",
        "typedDictBoolParam": "È previsto che il parametro \"{name}\" abbia il valore True o False",
        "typedDictClosedExtras": "La classe di base \"{name}\" è un TypedDict chiuso; gli elementi aggiuntivi devono essere di tipo \"{type}\"",
        "typedDictClosedNoExtras": "La classe di base \"{name}\" è un TypedDict chiuso; elementi aggiuntivi non consentiti",
        "typedDictDelete": "Non è stato possibile eliminare l'elemento in TypedDict",
        "typedDictEmptyName": "I nomi all'interno di un TypedDict non possono essere vuoti",
        "typedDictEntryName": "Valore letterale stringa previsto per il nome della voce del dizionario",
        "typedDictEntryUnique": "I nomi all'interno di un dizionario devono essere univoci",
        "typedDictExtraArgs": "Argomenti TypedDict aggiuntivi non supportati",
        "typedDictFieldNotRequiredRedefinition": "Non è possibile ridefinire il campo TypedDict \"{name}\" come Non obbligatorio",
        "typedDictFieldReadOnlyRedefinition": "Non è possibile ridefinire l’elemento TypedDict \"{name}\" come Sola lettura",
        "typedDictFieldRequiredRedefinition": "Non è possibile ridefinire il campo TypedDict \"{name}\" come Obbligatorio",
        "typedDictFirstArg": "È previsto il nome della classe TypedDict come primo argomento",
        "typedDictInitsubclassParameter": "TypedDict non supporta __init_subclass__ parametro “{name}”",
        "typedDictNotAllowed": "\"TypedDict\" non può essere usato in questo contesto",
        "typedDictSecondArgDict": "Previsto parametro dict o keyword come secondo parametro",
        "typedDictSecondArgDictEntry": "Voce di dizionario semplice prevista",
        "typedDictSet": "Non è stato possibile assegnare l'elemento in TypedDict",
        "unaccessedClass": "La classe \"{name}\" non è accessibile",
        "unaccessedFunction": "La classe \"{name}\" non è accessibile",
        "unaccessedImport": "Non è possibile accedere all'importazione \"{name}\"",
        "unaccessedSymbol": "Non è possibile accedere a \"{name}\"",
        "unaccessedVariable": "La variabile \"{name}\" non è accessibile",
        "unannotatedFunctionSkipped": "L'analisi della funzione \"{name}\" è stata ignorata perché non è annotata",
        "unaryOperationNotAllowed": "Operatore unario non consentito nell'annotazione di tipo",
        "unexpectedAsyncToken": "È previsto che \"def\", \"with\" o \"for\" seguano \"async\"",
        "unexpectedExprToken": "Token imprevisto alla fine dell'espressione",
        "unexpectedIndent": "Rientro imprevisto",
        "unexpectedUnindent": "Riduci rientro non previsto",
        "unhashableDictKey": "La chiave del dizionario deve essere hashable",
        "unhashableSetEntry": "La voce set deve essere hashable",
        "uninitializedAbstractVariables": "Le variabili definite nella classe di base astratta non vengono inizializzate nella classe finale \"{classType}\"",
        "uninitializedInstanceVariable": "La variabile di istanza \"{name}\" non è inizializzata nel corpo della classe o nel metodo __init__",
        "unionForwardReferenceNotAllowed": "Impossibile utilizzare la sintassi di unione con l'operando stringa. Usare virgolette intorno all'intera espressione",
        "unionSyntaxIllegal": "La sintassi alternativa per le unioni richiede Python 3.10 o versione successiva",
        "unionTypeArgCount": "L'unione richiede due o più argomenti di tipo",
        "unionUnpackedTuple": "L'unione non può includere una tupla decompressa",
        "unionUnpackedTypeVarTuple": "L'unione non può includere un TypeVarTuple non compresso",
        "unnecessaryCast": "Chiamata \"cast\" non necessaria; il tipo è già \"{type}\"",
        "unnecessaryIsInstanceAlways": "Chiamata isinstance non necessaria; \"{testType}\" è sempre un'istanza di \"{classType}\"",
        "unnecessaryIsSubclassAlways": "Chiamata issubclass non necessaria; \"{testType}\" è sempre una sottoclasse di \"{classType}\"",
        "unnecessaryPyrightIgnore": "Commento \"# pyright: ignore\" non necessario",
        "unnecessaryPyrightIgnoreRule": "Regola \"# pyright: ignore\" non necessaria: \"{name}\"",
        "unnecessaryTypeIgnore": "Commento \"# tipo: ignora\" non necessario",
        "unpackArgCount": "Previsto un singolo argomento tipo dopo \"Decomprimi\"",
        "unpackExpectedTypeVarTuple": "È previsto TypeVarTuple o tupla come argomento di tipo per Unpack",
        "unpackExpectedTypedDict": "Previsto argomento di tipo TypedDict per Decomprimi",
        "unpackIllegalInComprehension": "Operazione di decompressione non consentita nella comprensione",
        "unpackInAnnotation": "Operatore di decompressione non consentito nell'annotazione di tipo",
        "unpackInDict": "Operazione di decompressione non consentita nei dizionari",
        "unpackInSet": "Operatore di decompressione non consentito all’interno di un set",
        "unpackNotAllowed": "La decompressione non è consentita in questo contesto",
        "unpackOperatorNotAllowed": "L’operazione di decompressione non è consentita in questo contesto",
        "unpackTuplesIllegal": "L'operazione di decompressione non è consentita nelle tuple precedenti a Python 3.8",
        "unpackedArgInTypeArgument": "Gli argomenti non compressi non possono essere usati negli elenchi di argomenti tipo",
        "unpackedArgWithVariadicParam": "Non è possibile usare l'argomento decompresso per il parametro TypeVarTuple",
        "unpackedDictArgumentNotMapping": "L'espressione dell'argomento dopo ** deve essere un mapping con un tipo di chiave \"str\"",
        "unpackedDictSubscriptIllegal": "L'operatore di decompressione del dizionario nel pedice non è consentito",
        "unpackedSubscriptIllegal": "L'operatore di decompressione nel pedice richiede Python 3.11 o versione successiva",
        "unpackedTypeVarTupleExpected": "Previsto TypeVarTuple decompresso; usa Unpack[{name1}] o *{name2}",
        "unpackedTypedDictArgument": "Impossibile trovare una corrispondenza tra l'argomento TypedDict non compresso e i parametri",
        "unreachableCode": "Il codice non è raggiungibile",
        "unreachableExcept": "La clausola Except non è raggiungibile perché l'eccezione è già gestita",
        "unsupportedDunderAllOperation": "L'operazione su \"__all__\" non è supportata, di conseguenza l'elenco dei simboli esportati potrebbe non essere corretto",
        "unusedCallResult": "Il risultato dell'espressione di chiamata è di tipo \"{type}\" e non è usato. Assegnare alla variabile \"_\" se è intenzionale",
        "unusedCoroutine": "Il risultato della chiamata di funzione asincrona non viene usato. usare \"await\" o assegnare il risultato alla variabile",
        "unusedExpression": "Il valore dell'espressione non è utilizzato",
        "varAnnotationIllegal": "Le annotazioni di tipo per le variabili richiedono Python 3.6 o versione successiva. Usare il commento di tipo per compatibilità con le versioni precedenti",
        "variableFinalOverride": "La variabile \"{name}\" è contrassegnata come Final ed esegue l'override della variabile non Final con lo stesso nome nella classe \"{className}\"",
        "variadicTypeArgsTooMany": "L'elenco di argomenti di tipo può contenere al massimo una tupla o TypeVarTuple non compressa",
        "variadicTypeParamTooManyAlias": "L'alias di tipo può avere al massimo un parametro di tipo TypeVarTuple, ma ne ha ricevuti più ({names})",
        "variadicTypeParamTooManyClass": "La classe generica può avere al massimo un parametro di tipo TypeVarTuple, ma ne ha ricevuti più ({names})",
        "walrusIllegal": "L'operatore \":=\" richiede Python 3.8 o versione successiva",
        "walrusNotAllowed": "L'operatore \":=\" non è consentito in questo contesto senza parentesi circostanti",
        "wildcardInFunction": "Importazione di caratteri jolly non consentita all'interno di una classe o di una funzione",
        "wildcardLibraryImport": "Importazione di caratteri jolly da una libreria non consentita",
        "wildcardPatternTypePartiallyUnknown": "Il tipo acquisito dal modello con caratteri jolly è parzialmente sconosciuto",
        "wildcardPatternTypeUnknown": "Il tipo acquisito dal criterio con caratteri jolly è sconosciuto",
        "yieldFromIllegal": "L'uso di \"yield from\" richiede Python 3.3 o versione successiva",
        "yieldFromOutsideAsync": "\"yield from\" non consentito in una funzione asincrona",
        "yieldOutsideFunction": "\"yield\" non consentito all'esterno di una funzione o di un'espressione lambda",
        "yieldWithinListCompr": "\"yield\" non consentito all'interno di una comprensione di elenco",
        "zeroCaseStatementsFound": "L’istruzione Match deve includere almeno un’istruzione case",
        "zeroLengthTupleNotAllowed": "Tupla di lunghezza zero non è consentita in questo contesto"
    },
    "DiagnosticAddendum": {
        "annotatedNotAllowed": "Non è possibile usare il modulo speciale \"Annotato\" con controlli di istanza e classe",
        "argParam": "L'argomento corrisponde al parametro \"{paramName}\"",
        "argParamFunction": "L'argomento corrisponde al parametro \"{paramName}\" nella funzione \"{functionName}\"",
        "argsParamMissing": "Il parametro \"*{paramName}\" non ha un parametro corrispondente",
        "argsPositionOnly": "Parametro di sola posizione non corrispondente; previsto {expected} ma ricevuto {received}",
        "argumentType": "Il tipo di argomento è \"{type}\"",
        "argumentTypes": "Tipi di argomento: ({types})",
        "assignToNone": "Non è possibile assegnare il tipo al tipo \"None\"",
        "asyncHelp": "Intendevi \"async con\"?",
        "baseClassIncompatible": "La classe base \"{baseClass}\" non è compatibile con il tipo \"{type}\"",
        "baseClassIncompatibleSubclass": "La classe base \"{baseClass}\" deriva da \"{subclass}\", che non è compatibile con il tipo \"{type}\"",
        "baseClassOverriddenType": "La classe di base \"{baseClass}\" fornisce il tipo \"{type}\", di cui viene eseguito l'override",
        "baseClassOverridesType": "Override della classe base \"{baseClass}\" con tipo \"{type}\"",
        "bytesTypePromotions": "Imposta disableBytesTypePromotions su false per abilitare il comportamento di innalzamento di livello del tipo per \"bytearray\" e \"memoryview\"",
        "conditionalRequiresBool": "Il metodo __bool__ per il tipo \"{operandType}\" restituisce il tipo \"{boolReturnType}\" anziché \"bool\"",
        "dataClassFieldLocation": "Dichiarazione di campo",
        "dataClassFrozen": "\"{name}\" è bloccato",
        "dataProtocolUnsupported": "“{name}” è un protocollo dati",
        "descriptorAccessBindingFailed": "Impossibile associare il metodo \"{name}\" per la classe descrittore \"{className}\"",
        "descriptorAccessCallFailed": "Impossibile chiamare il metodo \"{name}\" per la classe descrittore \"{className}\"",
        "finalMethod": "Metodo finale",
        "functionParamDefaultMissing": "Nel parametro \"{name}\" manca un argomento predefinito",
        "functionParamName": "Nome del parametro non corrispondente: \"{destName}\" rispetto a \"{srcName}\"",
        "functionParamPositionOnly": "Parametro di sola posizione non corrispondente; il parametro “{name}” non è di sola posizione",
        "functionReturnTypeMismatch": "Il tipo restituito della funzione\"{sourceType}\" non è compatibile con il tipo \"{destType}\"",
        "functionTooFewParams": "La funzione accetta un numero insufficiente di parametri posizionale. Previsto {expected} ma ricevuto {received}",
        "functionTooManyParams": "La funzione accetta un numero eccessivo di parametri posizionale. Previsto {expected} ma ricevuto {received}",
        "genericClassNotAllowed": "Tipo generico con argomenti di tipo non consentiti per i controlli di istanza o classe",
        "incompatibleDeleter": "Il metodo di eliminazione delle proprietà non è compatibile",
        "incompatibleGetter": "Il metodo getter della proprietà non è compatibile",
        "incompatibleSetter": "Il metodo setter di proprietà non è compatibile",
        "initMethodLocation": "Il metodo __init__ è definito nella classe \"{type}\"",
        "initMethodSignature": "Firma del __init__ \"{type}\"",
        "initSubclassLocation": "Il metodo __init_subclass__ è definito nella classe \"{name}\"",
        "invariantSuggestionDict": "Prova a passare da \"dict\" a \"Mapping\", che è covariante nel tipo di valore",
        "invariantSuggestionList": "Prova a passare da \"list\" a \"Sequence\", che è covariante",
        "invariantSuggestionSet": "Provare a passare da \"ste\" a \"contenitore\" che è covariante",
        "keyNotRequired": "\"{name}\" non è una chiave obbligatoria in \"{type}\", quindi l'accesso potrebbe causare un'eccezione di runtime",
        "keyReadOnly": "\"{name}\" è una chiave di sola lettura in \"{type}\"",
        "keyRequiredDeleted": "\"{name}\" è una chiave obbligatoria e non può essere eliminata",
        "keyUndefined": "\"{name}\" non è una chiave definita in \"{type}\"",
        "kwargsParamMissing": "Il parametro \"**{paramName}\" non ha un parametro corrispondente",
        "listAssignmentMismatch": "Il tipo \"{type}\" non è compatibile con l'elenco di destinazione",
        "literalAssignmentMismatch": "impossibile assegnare \"{sourceType}\" al tipo \"{destType}\"",
        "matchIsNotExhaustiveHint": "Se la gestione completa non è prevista, aggiungere \"case _: pass\"",
        "matchIsNotExhaustiveType": "Tipo non gestito: \"{type}\"",
        "memberAssignment": "L'espressione di tipo \"{type}\" non può essere assegnata al membro \"{name}\" della classe \"{classType}\".",
        "memberIsAbstract": "\"{type}.{name}\" non implementato",
        "memberIsAbstractMore": "e {{count}} altro...",
        "memberIsClassVarInProtocol": "“{name}” è definito come ClassVar nel protocollo",
        "memberIsFinalInProtocol": "\"{name}\" è contrassegnato come Finale nel protocollo",
        "memberIsInitVar": "Il membro \"{name}\" è un campo solo init",
        "memberIsInvariant": "\"{name}\" è invariante perché modificabile",
        "memberIsNotClassVarInClass": "\"{name}\" deve essere definito come ClassVar per essere compatibile con il protocollo",
        "memberIsNotClassVarInProtocol": "“{name}” non è definito come ClassVar nel protocollo",
        "memberIsNotFinalInProtocol": "\"{name}\" non è contrassegnato come Finale nel protocollo",
        "memberIsWritableInProtocol": "\"{name}\" è scrivibile nel protocollo",
        "memberSetClassVar": "Non è possibile assegnare il membro \"{name}\" tramite un'istanza di classe perché è una ClassVar",
        "memberTypeMismatch": "\"{name}\" è un tipo non compatibile",
        "memberUnknown": "Il membro \"{name}\" è sconosciuto",
        "metaclassConflict": "La metaclasse \"{metaclass1}\" è in conflitto con \"{metaclass2}\"",
        "missingDeleter": "Manca il metodo di eliminazione delle proprietà",
        "missingGetter": "Metodo getter proprietà mancante",
        "missingSetter": "Metodo setter proprietà mancante",
        "namedParamMissingInDest": "Il parametro della parola chiave \"{name}\" non è presente nella destinazione",
        "namedParamMissingInSource": "Parametro della parola chiave \"{name}\" mancante nell’origine",
        "namedParamTypeMismatch": "Non è possibile assegnare il parametro di parola chiave \"{name}\" di tipo \"{sourceType}\" al tipo \"{destType}\"",
        "namedTupleNotAllowed": "Non è possibile usare NamedTuple per i controlli di istanze o classi",
        "newMethodLocation": "Il metodo __new__ è definito nella classe \"{type}\"",
        "newMethodSignature": "La firma del __new__ è \"{type}\"",
        "newTypeClassNotAllowed": "Impossibile utilizzare la classe creata con NewType con controlli di classe e di istanza",
        "noOverloadAssignable": "Nessuna funzione di overload corrisponde al tipo \"{type}\"",
        "noneNotAllowed": "Non è possibile usare None per i controlli di istanze o classi",
        "orPatternMissingName": "Nomi mancanti: {name}",
        "overloadIndex": "L'overload {index} è la corrispondenza più vicina",
        "overloadNotAssignable": "Uno o più overload di \"{name}\" non sono assegnabili",
        "overloadSignature": "La firma di overload è definita qui",
        "overriddenMethod": "Metodo sottoposto a override",
        "overriddenSymbol": "Simbolo sottoposto a override",
        "overrideInvariantMismatch": "Il tipo di override \"{overrideType}\" non è uguale al tipo di base \"{baseType}\"",
        "overrideIsInvariant": "La variabile è modificabile, quindi il relativo tipo è invariante",
        "overrideNoOverloadMatches": "Nessuna firma di overload nell'override è compatibile con il metodo di base",
        "overrideNotClassMethod": "Il metodo di base è dichiarato come metodo di classe, ma l'override non è",
        "overrideNotInstanceMethod": "Il metodo di base è dichiarato come metodo di istanza, ma l’override non lo è",
        "overrideNotStaticMethod": "Il metodo di base è dichiarato come metodo statico, ma l'override non è",
        "overrideOverloadNoMatch": "La sostituzione non gestisce tutti gli overload del metodo di base",
        "overrideOverloadOrder": "Gli overload per il metodo di override devono essere nello stesso ordine del metodo di base",
        "overrideParamKeywordNoDefault": "Parametro della parola chiave \"{name}\" non corrispondente: il parametro di base ha un valore di argomento predefinito, il parametro di override non è",
        "overrideParamKeywordType": "Tipo del parametro della parola chiave \"{name}\" non corrispondente: il parametro di base è di tipo \"{baseType}\", il parametro di override è di tipo \"{overrideType}\"",
        "overrideParamName": "Nome del parametro {index} non corrispondente: il parametro di base è denominato \"{baseName}\", il parametro di override è denominato \"{overrideName}\"",
        "overrideParamNameExtra": "Parametro \"{name}\" mancante nella base",
        "overrideParamNameMissing": "Parametro \"{name}\" mancante nell'override",
        "overrideParamNamePositionOnly": "Mancata corrispondenza del parametro {index}: il parametro di base \"{baseName}\" è un parametro di parola chiave, il parametro di override è di sola posizione",
        "overrideParamNoDefault": "Parametro \"{name}\" non corrispondente: il parametro di base ha un valore di argomento predefinito, il parametro di override non è",
        "overrideParamType": "Tipo di parametro {index} non corrispondente: il parametro di base è di tipo \"{baseType}\", il parametro di override è di tipo \"{overrideType}\"",
        "overridePositionalParamCount": "Numero di parametri posizionali non corrispondente. Il metodo di base ne ha {baseCount}, ma l'override ne ha {overrideCount}",
        "overrideReturnType": "Tipo restituito non corrispondente: il metodo di base restituisce il tipo \"{baseType}\", l'override restituisce il tipo \"{overrideType}\"",
        "overrideType": "La classe di base definisce il tipo come \"{type}\"",
        "paramAssignment": "Impossibile assegnare il parametro {index}: il tipo \"{sourceType}\" al tipo \"{destType}\"",
        "paramSpecMissingInOverride": "Parametri ParamSpec mancanti nel metodo di override",
        "paramType": "Tipo di parametro \"{paramType}\"",
        "privateImportFromPyTypedSource": "Importa da \"{module}\"",
        "propertyAccessFromProtocolClass": "Non è possibile accedere a una proprietà definita all'interno di una classe di protocollo come variabile di classe",
        "propertyMethodIncompatible": "Il metodo di proprietà \"{name}\" non è compatibile",
        "propertyMethodMissing": "Metodo di proprietà \"{name}\" mancante nell'override",
        "propertyMissingDeleter": "La proprietà \"{name}\" non ha un deleter definito",
        "propertyMissingSetter": "La proprietà \"{name}\" non ha un setter definito",
        "protocolIncompatible": "\"{sourceType}\" non è compatibile con il protocollo \"{destType}\"",
        "protocolMemberMissing": "\"{name}\" non è presente",
        "protocolRequiresRuntimeCheckable": "La classe del protocollo deve essere @runtime_checkable in modo che sia possibile usarla con i controlli di istanza e classe",
        "protocolSourceIsNotConcrete": "\"{sourceType}\" non è un tipo di classe concreto e non può essere assegnato al tipo \"{destType}\"",
        "protocolUnsafeOverlap": "Gli attributi di “{name}” hanno gli stessi nomi del protocollo",
        "pyrightCommentIgnoreTip": "Usare \"# pyright: ignore[<diagnostic rules>] per eliminare la diagnostica per una singola riga",
        "readOnlyAttribute": "L'attributo \"{name}\" è di sola lettura",
        "seeClassDeclaration": "Vedere la dichiarazione di classe",
        "seeDeclaration": "Vedere la dichiarazione",
        "seeFunctionDeclaration": "Vedere la dichiarazione di funzione",
        "seeMethodDeclaration": "Vedere la dichiarazione del metodo",
        "seeParameterDeclaration": "Vedere la dichiarazione del parametro",
        "seeTypeAliasDeclaration": "Vedere la dichiarazione di alias di tipo",
        "seeVariableDeclaration": "Vedere la dichiarazione di variabile",
        "tupleAssignmentMismatch": "Il tipo \"{type}\" non è compatibile con la tupla di destinazione",
        "tupleEntryTypeMismatch": "Il tipo della voce di tupla {entry} non è corretto",
        "tupleSizeIndeterminateSrc": "Dimensioni tupla non corrispondenti; previsto {expected} ma ricevuto indeterminato",
        "tupleSizeIndeterminateSrcDest": "Dimensioni della tupla non corrispondenti; previsto {expected} o più, ma ricevuto indeterminato",
        "tupleSizeMismatch": "Dimensioni tupla non corrispondenti; previsto {expected} ma ricevuto {received}",
        "tupleSizeMismatchIndeterminateDest": "Dimensioni della tupla non corrispondenti; previsto {expected} o più ma ricevuto {received}",
        "typeAliasInstanceCheck": "Non è possibile usare l'alias di tipo creato con l'istruzione \"type\" con controlli di classe e istanza",
        "typeAssignmentMismatch": "impossibile assegnare il tipo \"{sourceType}\" al tipo \"{destType}\"",
        "typeBound": "Il tipo \"{sourceType}\" non è compatibile con il tipo associato \"{destType}\" per la variabile di tipo \"{name}\"",
        "typeConstrainedTypeVar": "Il tipo \"{type}\" non è compatibile con la variabile di tipo vincolato \"{name}\"",
        "typeIncompatible": "\"{sourceType}\" non è compatibile con \"{destType}\"",
        "typeNotClass": "\"{type}\" non è una classe",
        "typeNotStringLiteral": "\"{type}\" non è un valore letterale stringa",
        "typeOfSymbol": "Il tipo di \"{name}\" è \"{type}\"",
        "typeParamSpec": "Il tipo \"{type}\" non è compatibile con il \"{name}\" ParamSpec",
        "typeUnsupported": "Il tipo \"{type}\" non è supportato",
        "typeVarDefaultOutOfScope": "La variabile di tipo \"{name}\" non è nell'ambito",
        "typeVarIsContravariant": "Il parametro di tipo \"{name}\" è controvariante, ma \"{sourceType}\" non è un supertipo di \"{destType}\"",
        "typeVarIsCovariant": "Il parametro di tipo \"{name}\" è covariante, ma \"{sourceType}\" non è un sottotipo di \"{destType}\"",
        "typeVarIsInvariant": "Il parametro di tipo \"{name}\" è invariante, ma \"{sourceType}\" non è uguale a \"{destType}\"",
        "typeVarNotAllowed": "TypeVar non consentito per i controlli di istanze o classi",
        "typeVarTupleRequiresKnownLength": "Non è possibile associare TypeVarTuple a una tupla di lunghezza sconosciuta",
        "typeVarUnnecessarySuggestion": "Usare invece {type}",
        "typeVarUnsolvableRemedy": "Specificare un overload che specifica il tipo restituito quando l'argomento non viene fornito",
        "typeVarsMissing": "Variabili di tipo mancanti: {names}",
        "typedDictBaseClass": "La classe \"{type}\" non è un TypedDict",
        "typedDictClassNotAllowed": "Classe TypedDict non consentita per i controlli di istanze o classi",
        "typedDictClosedExtraNotAllowed": "Non è possibile aggiungere l'elemento \"{name}\"",
        "typedDictClosedExtraTypeMismatch": "Non è possibile aggiungere l'elemento \"{name}\" con tipo \"{type}\"",
        "typedDictClosedFieldNotRequired": "Non è possibile aggiungere l'elemento \"{name}\" perché deve essere NotRequired",
        "typedDictExtraFieldNotAllowed": "\"{name}\" non è presente in \"{type}\"",
        "typedDictExtraFieldTypeMismatch": "Il tipo di \"{name}\" non è compatibile con il tipo \"__extra_items__\" in \"{type}\"",
        "typedDictFieldMissing": "\"{name}\" mancante nel \"{type}\"",
        "typedDictFieldNotReadOnly": "\"{name}\" non è di sola lettura in \"{type}\"",
        "typedDictFieldNotRequired": "\"{name}\" non è obbligatorio in \"{type}\"",
        "typedDictFieldRequired": "\"{name}\" è obbligatorio in \"{type}\"",
        "typedDictFieldTypeMismatch": "Il tipo \"{type}\" non può essere assegnato all’elemento \"{name}\"",
        "typedDictFieldUndefined": "\"{name}\" è un elemento non definito nel tipo \"{type}\"",
        "typedDictFinalMismatch": "\"{sourceType}\" non è compatibile con \"{destType}\" a causa di una @final mancata corrispondenza",
        "typedDictNotAllowed": "Non è possibile usare TypedDict per i controlli di istanze o classi",
        "unhashableType": "Il tipo \"{type}\" non è hashable",
        "uninitializedAbstractVariable": "La variabile di istanza \"{name}\" è definita nella classe di base astratta \"{classType}\" ma non è inizializzata",
        "unreachableExcept": "\"{exceptionType}\" è una sottoclasse di \"{parentType}\"",
        "useDictInstead": "Usare Dict[T1, T2] per indicare un tipo di dizionario",
        "useListInstead": "Usare List[T] per indicare un tipo di elenco o Union[T1, T2] per indicare un tipo di unione",
        "useTupleInstead": "Usare tuple[T1, ..., Tn] per indicare un tipo di tupla o Union[T1, T2] per indicare un tipo di unione",
        "useTypeInstead": "In alternativa, usare Type[T]",
        "varianceMismatchForClass": "La varianza dell'argomento tipo \"{typeVarName}\" non è compatibile con la classe di base \"{className}\"",
        "varianceMismatchForTypeAlias": "La varianza dell'argomento tipo \"{typeVarName}\" non è compatibile con \"{typeAliasParam}\""
    }
}
