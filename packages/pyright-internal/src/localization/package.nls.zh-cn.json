{
    "CodeAction": {
        "createTypeStub": "创建类型 Stub",
        "createTypeStubFor": "为 \"{moduleName}\" 创建类型 Stub",
        "executingCommand": "正在执行命令",
        "filesToAnalyzeCount": "要分析的 {count} 个文件",
        "filesToAnalyzeOne": "1 个要分析的文件",
        "findingReferences": "正在查找引用",
        "organizeImports": "整理 Import",
        "renameShadowedFile": "将“{oldFile}”重命名为“{newFile}”"
    },
    "Completion": {
        "autoImportDetail": "自动导入",
        "indexValueDetail": "索引值"
    },
    "Diagnostic": {
        "abstractMethodInvocation": "无法调用方法“{method}”，因为它是抽象的且未实施",
        "annotatedMetadataInconsistent": "带批注的元数据类型“{metadataType}”与类型“{type}”不兼容",
        "annotatedParamCountMismatch": "参数批注计数不匹配: 应为 {expected}，但收到 {received}",
        "annotatedTypeArgMissing": "“Annotated”应为一个类型参数和一个或多个批注",
        "annotationBytesString": "类型表达式不能使用字节字符串文本",
        "annotationFormatString": "类型表达式不能使用格式字符串文本(f-string)",
        "annotationNotSupported": "此语句不支持类型批注",
        "annotationRawString": "类型表达式不能使用原始字符串文本",
        "annotationSpansStrings": "类型表达式不能跨越多个字符串文本",
        "annotationStringEscape": "类型表达式不能包含转义字符",
        "argAssignment": "无法将“{argType}”类型的参数分配给“{paramType}”类型的参数",
        "argAssignmentFunction": "无法将\"{argType}\"类型的参数分配给函数\"{functionName}\"中的\"{paramType}\"类型参数",
        "argAssignmentParam": "无法将“{argType}”类型的参数分配给“{paramType}”类型的参数“{paramName}”",
        "argAssignmentParamFunction": "无法将“{argType}”类型的参数分配给函数“{functionName}”中类型为“{paramType}”的参数“{paramName}”",
        "argMissingForParam": "参数 {name} 缺少参数",
        "argMissingForParams": "参数 {names} 缺少参数",
        "argMorePositionalExpectedCount": "预期还有 {expected} 个位置参数",
        "argMorePositionalExpectedOne": "应为 1 个以上位置参数",
        "argPositional": "应为位置参数",
        "argPositionalExpectedCount": "应为 {expected} 个位置参数",
        "argPositionalExpectedOne": "应为 1 个位置参数",
        "argTypePartiallyUnknown": "参数类型部分未知",
        "argTypeUnknown": "参数类型未知",
        "assertAlwaysTrue": "断言表达式的计算结果始终为 true",
        "assertTypeArgs": "“assert_type”需要两个位置参数",
        "assertTypeTypeMismatch": "“assert_type”不匹配:应为“{expected}”，但收到“{received}”",
        "assignmentExprComprehension": "赋值表达式目标“{name}”不能使用与目标推导式相同的名称",
        "assignmentExprContext": "赋值表达式必须在模块、函数或 lambda 中",
        "assignmentExprInSubscript": "仅在 Python 3.10 和更高版本中支持下标中的赋值表达式",
        "assignmentInProtocol": "Protocol 类中的实例或类变量必须在类主体内显式声明",
        "assignmentTargetExpr": "表达式不能是赋值目标",
        "asyncNotInAsyncFunction": "不允许在 async 函数之外使用 \"async\"",
        "awaitIllegal": "使用 “await” 需要 Python 3.5 或更高版本",
        "awaitNotAllowed": "类型表达式不能使用 \"await\"",
        "awaitNotInAsync": "仅允许在 async 函数内使用 \"await\"",
        "backticksIllegal": "Python 3.x 中不支持由反引号环绕的表达式；请改用 repr",
        "baseClassCircular": "类不能从自身派生",
        "baseClassFinal": "基类 \"{type}\" 被标记为 final 类，无法子类化",
        "baseClassIncompatible": "{type} 的基类相互不兼容",
        "baseClassInvalid": "类的参数必须是基类",
        "baseClassMethodTypeIncompatible": "类“{classType}”的基类以不兼容的方式定义方法“{name}”",
        "baseClassUnknown": "基类类型未知，隐蔽派生类的类型",
        "baseClassVariableTypeIncompatible": "类“{classType}”的基类以不兼容的方式定义变量“{name}”",
        "binaryOperationNotAllowed": "类型表达式中不允许使用二元运算符",
        "bindTypeMismatch": "无法绑定方法“{methodName}”，因为“{type}”不能分配给参数“{paramName}”",
        "breakInExceptionGroup": "\"except*\" 块中不允许 \"break\"",
        "breakOutsideLoop": "“break”只能在循环中使用",
        "bytesUnsupportedEscape": "bytes 文本中不受支持的转义序列",
        "callableExtraArgs": "\"Callable\"应只有两个类型参数",
        "callableFirstArg": "应为参数类型列表或“...”",
        "callableNotInstantiable": "无法实例化类型“{type}”",
        "callableSecondArg": "返回类型应为\"Callable\"的第二个类型参数",
        "casePatternIsIrrefutable": "仅最后一个 case 语句允许使用无可辩驳的模式",
        "classAlreadySpecialized": "类型\"{type}\"已专用化",
        "classDecoratorTypeUnknown": "非类型化类修饰器遮盖类类型;忽略修饰器",
        "classDefinitionCycle": "“{name}”的类定义取决于自身",
        "classGetItemClsParam": "__class_getitem__替代应采用“cls”参数",
        "classMethodClsParam": "类方法应采用“cls”参数",
        "classNotRuntimeSubscriptable": "类 \"{name}\" 的下标将生成运行时异常; 请将类型表达式括在引号中",
        "classPatternBuiltInArgPositional": "类模式仅接受位置子模式",
        "classPatternPositionalArgCount": "类“{type}”的位置模式太多; 应为 {expected}，但收到了 {received}",
        "classPatternTypeAlias": "无法在类模式中使用“{type}”，因为它是专用类型别名",
        "classPropertyDeprecated": "类属性在 Python 3.11 中已弃用，在 Python 3.13 中将不受支持",
        "classTypeParametersIllegal": "类类型参数语法需要 Python 3.12 或更高版本",
        "classVarFirstArgMissing": "\"ClassVar\"后应为类型参数",
        "classVarNotAllowed": "此上下文中不允许使用“ClassVar”",
        "classVarOverridesInstanceVar": "类变量\"{name}\"替代类\"{className}\"中的同名实例变量",
        "classVarTooManyArgs": "“ClassVar”后应只有一个类型参数",
        "classVarWithTypeVar": "“ClassVar”类型不能包含类型变量",
        "clsSelfParamTypeMismatch": "参数“{name}”的类型必须是类“{classType}”的超类型",
        "codeTooComplexToAnalyze": "代码太复杂，无法分析；通过重构为子例程或减少条件代码路径来降低复杂性",
        "collectionAliasInstantiation": "无法实例化类型“{type}”，请改用“{alias}”",
        "comparisonAlwaysFalse": "条件的计算结果始终为 False，因为类型“{leftType}”和“{rightType}”没有重叠",
        "comparisonAlwaysTrue": "条件的计算结果始终为 True，因为类型“{leftType}”和“{rightType}”没有重叠",
        "comprehensionInDict": "推导式不能与其他字典条目一起使用",
        "comprehensionInSet": "推导式不能与其他 set 条目一起使用",
        "concatenateContext": "此上下文中不允许使用“Concatenate”",
        "concatenateParamSpecMissing": "“Concatenate”的最后一个类型参数必须是 ParamSpec 或 \"...\"",
        "concatenateTypeArgsMissing": "“Concatenate” 至少需要两个类型参数",
        "conditionalOperandInvalid": "类型“{type}”的条件操作数无效",
        "constantRedefinition": "“{name}”是常量 (因为它是大写)且无法重新定义",
        "constructorParametersMismatch": "类“{classType}”中__new__和__init__的签名不匹配",
        "containmentAlwaysFalse": "表达式的计算结果始终为 False，因为类型“{leftType}”和“{rightType}”没有重叠",
        "containmentAlwaysTrue": "表达式的计算结果始终为 True，因为类型“{leftType}”和“{rightType}”没有重叠",
        "continueInExceptionGroup": "\"except*\" 块中不允许 \"continue\"",
        "continueOutsideLoop": "“continue”只能在循环中使用",
        "coroutineInConditionalExpression": "始终计算结果为 True 的条件表达式引用协同例程",
        "dataClassBaseClassFrozen": "非冻结类不能从已冻结类继承",
        "dataClassBaseClassNotFrozen": "冻结类不能从未冻结的类继承",
        "dataClassConverterFunction": "类型“{argType}”的参数不是类型为“{fieldType}”的字段“{fieldName}”的有效转换器",
        "dataClassConverterOverloads": "“{funcName}”的重载不是类型为“{fieldType}”的字段“{fieldName}”的有效转换器",
        "dataClassFieldInheritedDefault": "“{fieldName}”替代同名字段，但缺少默认值",
        "dataClassFieldWithDefault": "没有默认值的字段不能出现在具有默认值的字段之后",
        "dataClassFieldWithPrivateName": "数据类字段不能使用专用名称",
        "dataClassFieldWithoutAnnotation": "不带类型批注的数据类字段将导致运行时异常",
        "dataClassPostInitParamCount": "数据类__post_init__参数计数不正确；InitVar 字段数为 {expected}",
        "dataClassPostInitType": "数据类__post_init__方法参数类型不匹配 \"{fieldName}\"字段",
        "dataClassSlotsOverwrite": "__slots__已在类中定义",
        "dataClassTransformExpectedBoolLiteral": "静态计算结果为 True 或 False 的预期表达式",
        "dataClassTransformFieldSpecifier": "应为类或函数的 tuple，但收到类型 \"{type}\"",
        "dataClassTransformPositionalParam": "“dataclass_transform”的所有参数都必须是关键字参数",
        "dataClassTransformUnknownArgument": "dataclass_transform不支持参数“{name}”",
        "dataProtocolInSubclassCheck": "issubclass 调用中不允许使用数据协议(包括非方法属性)",
        "declaredReturnTypePartiallyUnknown": "声明的返回类型“{returnType}”部分未知",
        "declaredReturnTypeUnknown": "声明的返回类型未知",
        "defaultValueContainsCall": "参数默认值表达式中不允许函数调用和可变对象",
        "defaultValueNotAllowed": "“*”或“**”的参数不能有默认值",
        "delTargetExpr": "无法删除表达式",
        "deprecatedClass": "类\"{name}\"已弃用",
        "deprecatedConstructor": "类\"{name}\"的构造函数已弃用",
        "deprecatedDescriptorDeleter": "已弃用描述符“{name}”的“__delete__”方法",
        "deprecatedDescriptorGetter": "已弃用描述符“{name}”的“__get__”方法",
        "deprecatedDescriptorSetter": "已弃用描述符“{name}”的“__set__”方法",
        "deprecatedFunction": "函数“{name}”已弃用",
        "deprecatedMethod": "类“{className}”中的“{name}”方法已弃用",
        "deprecatedPropertyDeleter": "已弃用 property \"{name}\" 的 deleter",
        "deprecatedPropertyGetter": "已弃用 property \"{name}\" 的 getter",
        "deprecatedPropertySetter": "已弃用 property \"{name}\" 的 setter",
        "deprecatedType": "自 Python {version} 起，此类型已弃用；请改用“{replacement}”",
        "dictExpandIllegalInComprehension": "推导式中不允许使用字典扩展",
        "dictInAnnotation": "类型表达式中不允许使用字典表达式",
        "dictKeyValuePairs": "字典条目必须包含键/值对",
        "dictUnpackIsNotMapping": "字典解包运算符的预期映射",
        "dunderAllSymbolNotPresent": "\"{name}\"已在__all__中指定，但在模块中不存在",
        "duplicateArgsParam": "只允许一个 \"*\" 参数",
        "duplicateBaseClass": "不允许重复的基类",
        "duplicateCapturePatternTarget": "捕获目标“{name}”不能在同一模式中出现多次",
        "duplicateCatchAll": "仅允许一个 catch-all except 子句",
        "duplicateEnumMember": "Enum 成员 \"{name}\" 已声明",
        "duplicateGenericAndProtocolBase": "只允许一个 Generic[...] 或 Protocol[...] 基类",
        "duplicateImport": "已多次导入“{importName}”",
        "duplicateKeywordOnly": "只允许一个“*”分隔符",
        "duplicateKwargsParam": "仅允许一个 “**” 参数",
        "duplicateParam": "参数“{name}”重复",
        "duplicatePositionOnly": "只允许一个“/”参数",
        "duplicateStarPattern": "模式序列中只允许一个“*”模式",
        "duplicateStarStarPattern": "只允许一个“**”条目",
        "duplicateUnpack": "list 中仅允许一个解包操作",
        "ellipsisAfterUnpacked": "\"...\" 不能与未打包的 TypeVarTuple 或 tuple 一起使用",
        "ellipsisContext": "不允许在此上下文中使用 \"...\"",
        "ellipsisSecondArg": "仅允许 \"...\" 作为两个参数中的第二个参数",
        "enumClassOverride": "Enum 类 \"{name}\" 是 final 类，无法子类化",
        "enumMemberDelete": "无法删除 Enum 成员 \"{name}\"",
        "enumMemberSet": "无法分配 Enum 成员 \"{name}\"",
        "enumMemberTypeAnnotation": "enum 成员不允许使用类型批注",
        "exceptGroupMismatch": "Try 语句不能同时包含 \"except\" 和 \"except*\"",
        "exceptGroupRequiresType": "异常组语法(\"except*\")需要异常类型",
        "exceptionGroupIncompatible": "异常组语法 (\"except*\") 需要 Python 3.11 或更高版本",
        "exceptionGroupTypeIncorrect": "except* 中的异常类型不能派生自 BaseGroupException",
        "exceptionTypeIncorrect": "\"{type}\" 不是派生自 BaseException",
        "exceptionTypeNotClass": "“{type}”不是有效的异常类",
        "exceptionTypeNotInstantiable": "异常类型\"{type}\"的构造函数需要一个或多个参数",
        "expectedAfterDecorator": "修饰器后应有函数或类声明",
        "expectedArrow": "应为“->”，后跟返回类型批注",
        "expectedAsAfterException": "异常类型后应为“as”",
        "expectedAssignRightHandExpr": "应为 “=” 右侧的表达式",
        "expectedBinaryRightHandExpr": "应为运算符右侧的表达式",
        "expectedBoolLiteral": "应为 True 或 False",
        "expectedCase": "应为 “case” 语句",
        "expectedClassName": "预期的类名",
        "expectedCloseBrace": "\"{\" 未关闭",
        "expectedCloseBracket": "“[”未关闭",
        "expectedCloseParen": "\"(\" 未关闭",
        "expectedColon": "应为 \":\"",
        "expectedComplexNumberLiteral": "模式匹配的预期复数文本",
        "expectedDecoratorExpr": "Python 3.9 之前的修饰器不支持表达式窗体",
        "expectedDecoratorName": "预期的修饰器名称",
        "expectedDecoratorNewline": "修饰器末尾应有新行",
        "expectedDelExpr": "\"del\"后应为表达式",
        "expectedElse": "应为 \"else\"",
        "expectedEquals": "应为 \"=\"",
        "expectedExceptionClass": "异常类或对象无效",
        "expectedExceptionObj": "应为异常对象、异常类或 None",
        "expectedExpr": "应为表达式",
        "expectedFunctionAfterAsync": "\"async\"后面应有函数定义",
        "expectedFunctionName": "“def”后应为函数名称",
        "expectedIdentifier": "预期标识符",
        "expectedImport": "应为 \"import\"",
        "expectedImportAlias": "应为 “as” 后面的符号",
        "expectedImportSymbols": "\"import\" 后应有一个或多个符号名称",
        "expectedIn": "应为 \"in\"",
        "expectedInExpr": "\"in\"后应为表达式",
        "expectedIndentedBlock": "应为缩进块",
        "expectedMemberName": "\".\" 后应为属性名称",
        "expectedModuleName": "预期模块名称",
        "expectedNameAfterAs": "\"as\" 后应有符号名",
        "expectedNamedParameter": "关键字参数必须跟在 “*” 之后",
        "expectedNewline": "需要换行符",
        "expectedNewlineOrSemicolon": "语句必须用换行符或分号分隔",
        "expectedOpenParen": "应为 \"(\"",
        "expectedParamName": "应为参数名称",
        "expectedPatternExpr": "预期的模式表达式",
        "expectedPatternSubjectExpr": "预期的模式主题表达式",
        "expectedPatternValue": "应为 “a.b”形式的模式值表达式",
        "expectedReturnExpr": "“return” 后应有表达式",
        "expectedSliceIndex": "预期索引或切片表达式",
        "expectedTypeNotString": "应为类型，但收到字符串文本",
        "expectedTypeParameterName": "应为类型参数名称",
        "expectedYieldExpr": "yield 语句中的预期表达式",
        "finalClassIsAbstract": "类“{type}”被标记为 final，并且必须实现所有抽象符号",
        "finalContext": "不允许在此上下文中使用 \"Final\"",
        "finalInLoop": "无法在循环中分配 \"Final\" 变量",
        "finalMethodOverride": "方法 \"{name}\" 无法替代在类 \"{className}\" 中定义的 final 方法",
        "finalNonMethod": "不能将函数“{name}”标记为 @final，因为它不是方法",
        "finalReassigned": "\"{name}\"声明为 Final，无法重新分配",
        "finalRedeclaration": "\"{name}\"以前声明为 Final",
        "finalRedeclarationBySubclass": "无法重新声明“{name}”，因为父类“{className}”将其声明为 Final",
        "finalTooManyArgs": "“Final”后应为单个类型参数",
        "finalUnassigned": "\"{name}\" 被声明为 Final，但未分配值",
        "formatStringBrace": "f 字符串文本中不允许使用单个右大括号；使用双右大括号",
        "formatStringBytes": "格式字符串文本(f 字符串)不能为二进制",
        "formatStringDebuggingIllegal": "F 字符串调试说明符“=”需要 Python 3.8 或更高版本",
        "formatStringEscape": "Python 3.12 之前 f 字符串的表达式部分中不允许使用转义序列(反斜杠)",
        "formatStringExpectedConversion": "在 f 字符串中应为 \"!\" 之后的转换说明符",
        "formatStringIllegal": "格式化字符串文本(f 字符串)需要 Python 3.6 或更高版本",
        "formatStringInPattern": "模式中不允许使用格式字符串",
        "formatStringNestedFormatSpecifier": "表达式嵌套在格式字符串说明符内太深",
        "formatStringNestedQuote": "嵌套在 f 字符串中的字符串不能使用与 Python 3.12 之前的 f 字符串相同的引号字符",
        "formatStringUnicode": "格式字符串文本(f 字符串)不能为 unicode",
        "formatStringUnterminated": "f 字符串中未终止的表达式；应为 \"}\"",
        "functionDecoratorTypeUnknown": "非类型化函数修饰器遮盖函数类型；忽略修饰器",
        "functionInConditionalExpression": "始终计算结果为 True 的条件表达式引用函数",
        "functionTypeParametersIllegal": "函数类型参数语法需要 Python 3.12 或更高版本",
        "futureImportLocationNotAllowed": "从__future__导入必须位于文件的开头",
        "generatorAsyncReturnType": "async 生成器函数的返回类型必须与 \"AsyncGenerator[{yieldType}, Any]\" 兼容",
        "generatorNotParenthesized": "如果不是唯一参数，生成器表达式必须带圆括号",
        "generatorSyncReturnType": "生成器函数的返回类型必须与 \"Generator[{yieldType}, Any, Any]\"兼容",
        "genericBaseClassNotAllowed": "“Generic” 基类不能与类型参数语法一起使用",
        "genericClassAssigned": "无法分配泛型类类型",
        "genericClassDeleted": "无法删除泛型类类型",
        "genericInstanceVariableAccess": "通过类访问泛型实例变量是不明确的",
        "genericNotAllowed": "\"Generic\" 在此上下文中无效",
        "genericTypeAliasBoundTypeVar": "类中的泛型类型别名不能使用绑定类型变量 {names}",
        "genericTypeArgMissing": "“Generic”至少需要一个类型参数",
        "genericTypeArgTypeVar": "“Generic”的类型参数必须是类型变量",
        "genericTypeArgUnique": "“Generic”的类型参数必须是唯一",
        "globalReassignment": "\"{name}\" 已在 global 声明之前分配",
        "globalRedefinition": "\"{name}\" 已声明为 global",
        "implicitStringConcat": "不允许隐式字符串串联",
        "importCycleDetected": "在导入链中检测到的周期数",
        "importDepthExceeded": "导入链深度超过 {depth}",
        "importResolveFailure": "无法解析导入“{importName}”",
        "importSourceResolveFailure": "无法从源解析导入“{importName}”",
        "importSymbolUnknown": "“{name}”是未知的导入符号",
        "incompatibleMethodOverride": "方法“{name}”以不兼容的方式替代类“{className}”",
        "inconsistentIndent": "取消缩进量与以前的缩进不匹配",
        "inconsistentTabs": "缩进中制表符和空格的使用不一致",
        "initMethodSelfParamTypeVar": "\"__init__\" 方法 “self” 参数的类型注释不能包含类范围的类型变量",
        "initMustReturnNone": "“__init__”的返回类型必须为 None",
        "initSubclassCallFailed": "__init_subclass__ 方法的关键字参数不正确",
        "initSubclassClsParam": "__init_subclass__替代应采用“cls”参数",
        "initVarNotAllowed": "此上下文中不允许使用“InitVar”",
        "instanceMethodSelfParam": "实例方法应采用 “self” 参数",
        "instanceVarOverridesClassVar": "实例变量\"{name}\"替代类\"{className}\"中的同名类变量",
        "instantiateAbstract": "无法实例化抽象类“{type}”",
        "instantiateProtocol": "无法实例化 Protocol 类 \"{type}\"",
        "internalBindError": "绑定文件“{file}”时发生内部错误:{message}",
        "internalParseError": "分析文件“{file}”时发生内部错误:{message}",
        "internalTypeCheckingError": "类型检查文件“{file}”时发生内部错误:{message}",
        "invalidIdentifierChar": "标识符中的字符无效",
        "invalidStubStatement": "语句在类型 stub 文件中无意义",
        "invalidTokenChars": "令牌中的字符\"{text}\"无效",
        "isInstanceInvalidType": "\"isinstance\" 的第二个参数必须是类或类的 tuple",
        "isSubclassInvalidType": "\"issubclass\" 的第二个参数必须是类或类的 tuple",
        "keyValueInSet": "不允许在 set 内使用键/值对",
        "keywordArgInTypeArgument": "关键字参数不能在类型参数列表中使用",
        "keywordArgShortcutIllegal": "关键字参数快捷方式需要 Python 3.14 或更高版本",
        "keywordOnlyAfterArgs": "“*”参数后不允许使用仅限关键字的参数分隔符",
        "keywordParameterMissing": "一个或多个关键字参数必须遵循 \"*\"参数",
        "keywordSubscriptIllegal": "不支持下标中的关键字参数",
        "lambdaReturnTypePartiallyUnknown": "lambda 的返回类型“{returnType}”部分未知",
        "lambdaReturnTypeUnknown": "lambda 的返回类型未知",
        "listAssignmentMismatch": "无法将 \"{type}\" 类型的表达式分配给目标列表",
        "listInAnnotation": "类型表达式中不允许使用 List 表达式",
        "literalEmptyArgs": "“Literal”后应有一个或多个类型参数",
        "literalNamedUnicodeEscape": "\"Literal\" 字符串批注不支持已命名的 unicode 转义序列",
        "literalNotAllowed": "如果没有类型参数，则 \"Literal\" 不能用于此上下文",
        "literalNotCallable": "无法实例化 Literal 类型",
        "literalUnsupportedType": "\"Literal\" 的类型参数必须是 None、文本值(int、bool、str 或 bytes)或 enum 值",
        "matchIncompatible": "Match 语句需要 Python 3.10 或更高版本",
        "matchIsNotExhaustive": "match 语句中的事例不会彻底处理所有值",
        "maxParseDepthExceeded": "超出最大分析深度;将表达式分解为较小的子表达式",
        "memberAccess": "无法访问类“{type}”的属性“{name}”",
        "memberDelete": "无法删除类“{type}”的属性“{name}”",
        "memberSet": "无法为类“{type}”的属性“{name}”赋值。",
        "metaclassConflict": "派生类的元类必须是其所有基类的元类的子类",
        "metaclassDuplicate": "只能提供一个元类",
        "metaclassIsGeneric": "元类不能是泛型",
        "methodNotDefined": "未定义“{name}”方法",
        "methodNotDefinedOnType": "未在类型\"{type}\"上定义\"{name}\"方法",
        "methodOrdering": "无法创建一致的方法排序",
        "methodOverridden": "“{name}”在类型“{type}”不兼容的类“{className}”中替代同名的方法",
        "methodReturnsNonObject": "“{name}”方法不返回对象",
        "missingSuperCall": "方法“{methodName}”在父类中不调用同名方法",
        "mixingBytesAndStr": "Bytes 和 str 值无法串联",
        "moduleAsType": "模块不能用作类型",
        "moduleNotCallable": "模块不可调用",
        "moduleUnknownMember": "“{memberName}”不是模块“{moduleName}”的已知属性",
        "namedExceptAfterCatchAll": "命名的 except 子句不能出现在 catch-all except 子句后",
        "namedParamAfterParamSpecArgs": "关键字参数“{name}”不能出现在 ParamSpec args 参数之后的签名中",
        "namedTupleEmptyName": "命名 tuple 中的名称不能为空",
        "namedTupleEntryRedeclared": "无法替代 \"{name}\"，因为父类 \"{className}\" 是命名的 tuple",
        "namedTupleFirstArg": "应将命名的 tuple 类名作为第一个参数",
        "namedTupleMultipleInheritance": "不支持使用 NamedTuple 进行多个继承",
        "namedTupleNameKeyword": "字段名称不能是关键字",
        "namedTupleNameType": "应为指定条目名称和类型的双条目 tuple",
        "namedTupleNameUnique": "命名的 tuple 中的名称必须唯一",
        "namedTupleNoTypes": "“namedtuple”不提供元组条目的类型；请改用“NamedTuple”",
        "namedTupleSecondArg": "应将命名的 tuple 条目 list 作为第二个参数",
        "newClsParam": "__new__替代应采用“cls”参数",
        "newTypeAnyOrUnknown": "NewType 的第二个参数必须是已知类，而不是 Any 或 Unknown",
        "newTypeBadName": "NewType 的第一个参数必须是字符串文本",
        "newTypeLiteral": "NewType 不能与 Literal 类型一起使用",
        "newTypeNameMismatch": "必须将 NewType 分配给同名变量",
        "newTypeNotAClass": "应为 NewType 的第二个参数的类",
        "newTypeParamCount": "NewType 需要两个位置参数",
        "newTypeProtocolClass": "NewType 不能与结构类型(Protocol 或 TypedDict 类)一起使用",
        "noOverload": "“{name}”的重载与提供的参数不匹配",
        "noReturnContainsReturn": "声明的 return 类型为 \"NoReturn\" 的函数不能包含 return 语句",
        "noReturnContainsYield": "声明的返回类型为 “NoReturn” 的函数不能包含 yield 语句",
        "noReturnReturnsNone": "所声明的返回类型为 \"NoReturn\" 的函数无法返回 \"None\"",
        "nonDefaultAfterDefault": "非默认参数遵循默认参数",
        "nonLocalInModule": "模块级不允许使用 nonlocal 声明",
        "nonLocalNoBinding": "找不到 nonlocal \"{name}\" 的绑定",
        "nonLocalReassignment": "\"{name}\" 已在 nonlocal 声明之前分配",
        "nonLocalRedefinition": "\"{name}\" 已声明为 nonlocal",
        "noneNotCallable": "无法调用类型为“None”的对象",
        "noneNotIterable": "类型为“None”的对象不能用作可迭代值",
        "noneNotSubscriptable": "类型为“None”的对象不可下标",
        "noneNotUsableWith": "Object of type \"None\" cannot be used with \"with\"",
        "noneNotUsableWithAsync": "Object of type \"None\" cannot be used with \"async with\"",
        "noneOperator": "“None”不支持运算符\"{operator}\"",
        "noneUnknownMember": "“{name}”不是 \"None\" 的已知属性",
        "notRequiredArgCount": "“NotRequired” 之后应为单个类型参数",
        "notRequiredNotInTypedDict": "此上下文中不允许使用“NotRequired”",
        "objectNotCallable": "类型为“{type}”的对象不可调用",
        "obscuredClassDeclaration": "类声明\"{name}\"被同名的声明遮蔽",
        "obscuredFunctionDeclaration": "函数声明“{name}”被同名声明遮盖",
        "obscuredMethodDeclaration": "方法声明“{name}”被同名声明遮盖",
        "obscuredParameterDeclaration": "参数声明“{name}”被同名声明遮盖",
        "obscuredTypeAliasDeclaration": "类型别名声明“{name}”被同名声明遮盖",
        "obscuredVariableDeclaration": "声明“{name}”被同名声明遮盖",
        "operatorLessOrGreaterDeprecated": "Python 3 不支持运算符“<>”；请改用 \"!=\"",
        "optionalExtraArgs": "\"Optional\"后面应有一个类型参数",
        "orPatternIrrefutable": "无可辩驳的模式仅允许作为 \"or\"模式中的最后一个子模式",
        "orPatternMissingName": "“or”模式中的所有子节点必须以相同的名称为目标",
        "overlappingKeywordArgs": "类型化字典与以下关键字参数重叠: {names}",
        "overlappingOverload": "永远不会使用“{name}”的重载 {obscured}，因为其参数与重载 {obscuredBy} 重叠",
        "overloadAbstractImplMismatch": "重载必须与实现的抽象状态匹配",
        "overloadAbstractMismatch": "重载必须全是抽象重载，或者全都不是抽象重载",
        "overloadClassMethodInconsistent": "“{name}”的重载使用 @classmethod 的方式不一致",
        "overloadFinalInconsistencyImpl": "“{name}”的重载被标记为 @final，但实施未被标记",
        "overloadFinalInconsistencyNoImpl": "“{name}”的重载 {index} 被标记为 @final，但重载 1 未被标记",
        "overloadImplementationMismatch": "重载实现与重载 {index} 的签名不一致",
        "overloadReturnTypeMismatch": "“{name}”的重载 {prevIndex} 与重载 {newIndex} 重叠，并返回不兼容的类型",
        "overloadStaticMethodInconsistent": "“{name}”的重载使用 @staticmethod 的方式不一致",
        "overloadWithoutImplementation": "\"{name}\" 被标记为 overload，但未提供实现",
        "overriddenMethodNotFound": "方法 \"{name}\" 被标记为 override，但不存在同名的基方法",
        "overrideDecoratorMissing": "方法 \"{name}\" 未被标记为替代，但 override 类 \"{className}\" 中的方法",
        "paramAfterKwargsParam": "参数不能跟随“**”参数",
        "paramAlreadyAssigned": "已分配参数“{name}”",
        "paramAnnotationMissing": "参数“{name}”缺少类型批注",
        "paramAssignmentMismatch": "无法将\"{sourceType}\"类型的表达式分配给\"{paramType}\"类型的参数",
        "paramNameMissing": "没有名为“{name}”的参数",
        "paramSpecArgsKwargsDuplicate": "已提供 ParamSpec \"{type}\" 的参数",
        "paramSpecArgsKwargsUsage": "ParamSpec 的 \"args\" 和 \"kwargs\" 属性必须同时出现在函数签名中",
        "paramSpecArgsMissing": "缺少 ParamSpec“{type}”的参数",
        "paramSpecArgsUsage": "ParamSpec 的 \"args\" 属性仅在与 *args 参数一起使用时有效",
        "paramSpecAssignedName": "必须将 ParamSpec 分配给名为“{name}”的变量",
        "paramSpecContext": "此上下文中不允许使用 ParamSpec",
        "paramSpecDefaultNotTuple": "ParamSpec 的默认值应为省略号、tuple 表达式或 ParamSpec",
        "paramSpecFirstArg": "ParamSpec 作为第一个参数的预期名称",
        "paramSpecKwargsUsage": "ParamSpec 的 \"kwargs\" 属性仅在与 **kwargs 参数一起使用时有效",
        "paramSpecNotUsedByOuterScope": "ParamSpec“{name}”在此上下文中没有意义",
        "paramSpecUnknownArg": "ParamSpec 不支持多个参数",
        "paramSpecUnknownMember": "“{name}”不是 ParamSpec 的已知属性",
        "paramSpecUnknownParam": "“{name}”是 ParamSpec 的未知参数",
        "paramTypeCovariant": "不能在参数类型中使用协变类型变量",
        "paramTypePartiallyUnknown": "参数\"{paramName}\"的类型部分未知",
        "paramTypeUnknown": "参数“{paramName}”的类型未知",
        "parenthesizedContextManagerIllegal": "Parentheses within \"with\" statement requires Python 3.9 or newer",
        "patternNeverMatches": "主题类型“{type}”的模式永远不会匹配",
        "positionArgAfterNamedArg": "位置参数不能出现在关键字参数之后",
        "positionArgAfterUnpackedDictArg": "Positional argument cannot appear after keyword argument unpacking",
        "positionOnlyAfterArgs": "“*”参数后不允许使用仅位置参数分隔符",
        "positionOnlyAfterKeywordOnly": "“/”参数必须出现在“*”参数之前",
        "positionOnlyAfterNon": "非仅位置参数后面不允许仅位置参数",
        "positionOnlyFirstParam": "不允许将仅位置参数分隔符用作第一个参数",
        "positionOnlyIncompatible": "仅位置参数分隔符需要 Python 3.8 或更高版本",
        "privateImportFromPyTypedModule": "未从模块“{module}”导出“{name}”",
        "privateUsedOutsideOfClass": "\"{name}\"是专用的，在声明它的类之外使用",
        "privateUsedOutsideOfModule": "“{name}”是专用的，在声明它的模块外部使用",
        "propertyOverridden": "\"{name}\" 错误地替代了类 \"{className}\" 中同名的 property",
        "propertyStaticMethod": "property getter、setter 或 deleter 不允许使用静态方法",
        "protectedUsedOutsideOfClass": "“{name}”在声明它的类之外受到保护并被使用",
        "protocolBaseClass": "Protocol 类 \"{classType}\" 不能派生自非 Protocol 类 \"{baseType}\"",
        "protocolBaseClassWithTypeArgs": "使用类型参数语法时，Protocol 类不允许使用类型参数",
        "protocolIllegal": "使用 \"Protocol\" 需要 Python 3.7 或更高版本",
        "protocolNotAllowed": "\"Protocol\" 不能用于此上下文",
        "protocolTypeArgMustBeTypeParam": "\"Protocol\" 的类型参数必须是类型参数",
        "protocolUnsafeOverlap": "类与“{name}”不安全地重叠，并且可能在运行时生成匹配项",
        "protocolVarianceContravariant": "泛型 Protocol \"{class}\" 中使用的类型变量 \"{variable}\" 应为反变量",
        "protocolVarianceCovariant": "泛型 Protocol \"{class}\" 中使用的类型变量 \"{variable}\" 应为共变量",
        "protocolVarianceInvariant": "泛型 Protocol \"{class}\" 中使用的类型变量 \"{variable}\" 应为固定变量",
        "pyrightCommentInvalidDiagnosticBoolValue": "Pyright 注释指令后面必须跟有“=”和 true 或 false 值",
        "pyrightCommentInvalidDiagnosticSeverityValue": "Pyright 注释指令后面必须跟有“=”，并且值为 true、false、error、warning、information 或 none",
        "pyrightCommentMissingDirective": "Pyright 注释后面必须是指令(basic 或 strict)或诊断规则",
        "pyrightCommentNotOnOwnLine": "用于控制文件级设置的 Pyright 注释必须显示在其自己的行上",
        "pyrightCommentUnknownDiagnosticRule": "“{rule}”是 pyright 注释的未知诊断规则",
        "pyrightCommentUnknownDiagnosticSeverityValue": "\"{value}\"是 pyright 注释的无效值；应为 true、false、error、warning、information 或 none",
        "pyrightCommentUnknownDirective": "\"{directive}\"是 pyright 注释的未知指令；应为 “strict” 或 “basic”",
        "readOnlyArgCount": "“ReadOnly”后应为单个类型参数",
        "readOnlyNotInTypedDict": "此上下文中不允许使用“ReadOnly”",
        "recursiveDefinition": "无法确定“{name}”的类型，因为它引用其自身",
        "relativeImportNotAllowed": "相对导入不能与“import .a”窗体一起使用；改用 \"from . import a\"",
        "requiredArgCount": "\"Required\"后应为单个类型参数",
        "requiredNotInTypedDict": "此上下文中不允许使用\"Required\"",
        "returnInAsyncGenerator": "async 生成器中不允许使用具有值的 return 语句",
        "returnInExceptionGroup": "\"except*\" 块中不允许 \"return\"",
        "returnMissing": "所声明的返回类型为“{returnType}”的函数必须在所有代码路径上返回值",
        "returnOutsideFunction": "“return”只能在函数中使用",
        "returnTypeContravariant": "逆变类型变量不能用于返回类型",
        "returnTypeMismatch": "类型“{exprType}”不可分配给返回类型“{returnType}”",
        "returnTypePartiallyUnknown": "返回类型“{returnType}”部分未知",
        "returnTypeUnknown": "返回类型未知",
        "revealLocalsArgs": "“reveal_locals”调用应没有参数",
        "revealLocalsNone": "此范围内没有 locals 变量",
        "revealTypeArgs": "“reveal_type”调用应为单个位置参数",
        "revealTypeExpectedTextArg": "函数“reveal_type”的“expected_text”参数必须是 str 文本值",
        "revealTypeExpectedTextMismatch": "类型文本不匹配；应为\"{expected}\"但收到\"{received}\"",
        "revealTypeExpectedTypeMismatch": "类型不匹配;应为“{expected}”，但收到“{received}”",
        "selfTypeContext": "“Self”在此上下文中无效",
        "selfTypeMetaclass": "“Self”不能在元类(“type”的子类)中使用",
        "selfTypeWithTypedSelfOrCls": "“Self”不能在具有“self”或“cls”参数的函数中使用，该参数的类型批注不是“Self”",
        "setterGetterTypeMismatch": "Property setter 值类型不可分配给 getter 返回类型",
        "singleOverload": "“{name}”被标记为重载，但缺少其他重载",
        "slotsAttributeError": "未在__slots__中指定“{name}”",
        "slotsClassVarConflict": "\"{name}\"与__slots__中声明的实例变量冲突",
        "starPatternInAsPattern": "星形模式不能与“as”目标一起使用",
        "starPatternInOrPattern": "在其他模式中，星形图案不能为 ORed",
        "starStarWildcardNotAllowed": "** 不能与通配符“_”一起使用",
        "staticClsSelfParam": "静态方法不应采用“self”或“cls”参数",
        "stdlibModuleOverridden": "\"{path}\"正在替代 stdlib 模块\"{name}\"",
        "stringNonAsciiBytes": "不允许使用非 ASCII 字符(以字节为单位)字符串文本",
        "stringNotSubscriptable": "字符串表达式不能在类型表达式中使用下标; 请将整个表达式括在引号中",
        "stringUnsupportedEscape": "字符串文本中不受支持的转义序列",
        "stringUnterminated": "字符串文本未终止",
        "stubFileMissing": "找不到 \"{importName}\" 的 Stub 文件",
        "stubUsesGetAttr": "类型 stub 文件不完整; \"__getattr__\" 遮盖了模块的类型错误",
        "sublistParamsIncompatible": "Python 3.x 不支持 Sublist 参数",
        "superCallArgCount": "“super” 调用应不超过两个参数",
        "superCallFirstArg": "应将类类型作为“super”调用的第一个参数，但收到“{type}”",
        "superCallSecondArg": "“super”调用的第二个参数必须是派生自“{type}”的对象或类",
        "superCallZeroArgForm": "\"super\" 调用的零参数形式仅在方法中有效",
        "superCallZeroArgFormStaticMethod": "“super”调用的零参数形式在静态方法中无效",
        "symbolIsPossiblyUnbound": "“{name}”可能未绑定",
        "symbolIsUnbound": "“{name}”未绑定",
        "symbolIsUndefined": "未定义“{name}”",
        "symbolOverridden": "“{name}”替代类“{className}”中的同名符号",
        "ternaryNotAllowed": "类型表达式中不允许使用三元表达式",
        "totalOrderingMissingMethod": "类必须定义“__lt__”、“__le__”、“__gt__”或“__ge__”之一才能使用total_ordering",
        "trailingCommaInFromImport": "不允许使用尾随逗号，没有括号",
        "tryWithoutExcept": "Try 语句必须至少有一个 except 或 finally 子句",
        "tupleAssignmentMismatch": "无法将类型为 \"{type}\" 的表达式分配给目标 tuple",
        "tupleInAnnotation": "类型表达式中不允许使用 tuple 表达式",
        "tupleIndexOutOfRange": "类型 {type} 的索引 {index} 超出范围",
        "typeAliasIllegalExpressionForm": "类型别名定义的表达式形式无效",
        "typeAliasIsRecursiveDirect": "类型别名“{name}”不能在其定义中使用自身",
        "typeAliasNotInModuleOrClass": "TypeAlias 只能在模块或类范围内定义",
        "typeAliasRedeclared": "“{name}”声明为 TypeAlias，只能分配一次",
        "typeAliasStatementBadScope": "type 语句只能在模块或类范围内使用",
        "typeAliasStatementIllegal": "类型别名语句需要 Python 3.12 或更高版本",
        "typeAliasTypeBaseClass": "\"type\" 语句中定义的类型别名不能用作基类",
        "typeAliasTypeMustBeAssigned": "必须将 TypeAliasType 分配给与类型别名同名的变量",
        "typeAliasTypeNameArg": "TypeAliasType 的第一个参数必须是表示类型别名名称的字符串文本",
        "typeAliasTypeNameMismatch": "类型别名的名称必须与分配到的变量的名称匹配",
        "typeAliasTypeParamInvalid": "类型参数列表必须是仅包含 TypeVar、TypeVarTuple 或 ParamSpec 的 tuple",
        "typeAnnotationCall": "类型表达式中不允许使用调用表达式",
        "typeAnnotationVariable": "类型表达式中不允许使用变量",
        "typeAnnotationWithCallable": "“type”的类型参数必须为类; 不支持可调用项",
        "typeArgListExpected": "应为 ParamSpec、省略号或类型 list",
        "typeArgListNotAllowed": "此类型参数不允许使用 list 表达式",
        "typeArgsExpectingNone": "类“{name}”不应有类型参数",
        "typeArgsMismatchOne": "应为一个类型参数，但收到 {received}",
        "typeArgsMissingForAlias": "泛型类型别名“{name}”的预期类型参数",
        "typeArgsMissingForClass": "泛型类“{name}”的预期类型参数",
        "typeArgsTooFew": "为“{name}”提供的类型参数太少；应为 {expected}，但收到 {received}",
        "typeArgsTooMany": "为“{name}”提供的类型参数太多；应为 {expected}，但收到 {received}",
        "typeAssignmentMismatch": "类型“{sourceType}”不可分配给声明的类型“{destType}”",
        "typeAssignmentMismatchWildcard": "导入符号“{name}”的类型为“{sourceType}”，该类型不可分配给声明的类型“{destType}”",
        "typeCallNotAllowed": "不应在类型表达式中使用 type() 调用",
        "typeCheckOnly": "“{name}”标记为 @type_check_only，并且只能在类型注释中使用",
        "typeCommentDeprecated": "已弃用 type 注释; 请改用 type 批注",
        "typeExpectedClass": "应为类，但收到“{type}”",
        "typeFormArgs": "\"TypeForm\" 接受单个位置参数",
        "typeGuardArgCount": "“TypeGuard”或“TypeIs”后应为单个类型参数",
        "typeGuardParamCount": "用户定义的类型防护函数和方法必须至少有一个输入参数",
        "typeIsReturnType": "TypeIs 的返回类型(“{returnType}”)与值参数类型(“{type}”)不一致",
        "typeNotAwaitable": "\"{type}\" 并非 awaitable",
        "typeNotIntantiable": "无法实例化\"{type}\"",
        "typeNotIterable": "“{type}”不可迭代",
        "typeNotSpecializable": "无法专用化类型“{type}”",
        "typeNotSubscriptable": "类型为“{type}”的对象不可下标",
        "typeNotSupportBinaryOperator": "类型“{leftType}”和“{rightType}”不支持运算符“{operator}”",
        "typeNotSupportBinaryOperatorBidirectional": "预期类型为“{expectedType}”时，类型“{leftType}”和“{rightType}”不支持运算符“{operator}”",
        "typeNotSupportUnaryOperator": "类型“{type}”不支持运算符“{operator}”",
        "typeNotSupportUnaryOperatorBidirectional": "预期类型为 \"{expectedType}\"时，类型\"{type}\"不支持运算符\"{operator}\"",
        "typeNotUsableWith": "Object of type \"{type}\" cannot be used with \"with\" because it does not correctly implement {method}",
        "typeNotUsableWithAsync": "Object of type \"{type}\" cannot be used with \"async with\" because it does not correctly implement {method}",
        "typeParameterBoundNotAllowed": "绑定或约束不能与 variadic 类型参数或 ParamSpec 一起使用",
        "typeParameterConstraintTuple": "类型参数约束必须是两个或更多类型的元组",
        "typeParameterExistingTypeParameter": "类型参数\"{name}\"已在使用中",
        "typeParameterNotDeclared": "类型参数“{name}”未包含在“{container}”的类型参数列表中",
        "typeParametersMissing": "必须至少指定一个类型参数",
        "typePartiallyUnknown": "“{name}”的类型部分未知",
        "typeUnknown": "\"{name}\"类型未知",
        "typeVarAssignedName": "必须将 TypeVar 分配给名为“{name}”的变量",
        "typeVarAssignmentMismatch": "无法将类型\"{type}\"分配给类型变量\"{name}\"",
        "typeVarBoundAndConstrained": "TypeVar 不能同时绑定和约束",
        "typeVarBoundGeneric": "TypeVar 绑定类型不能是泛型",
        "typeVarConstraintGeneric": "TypeVar 约束类型不能是泛型",
        "typeVarDefaultBoundMismatch": "TypeVar 默认类型必须是绑定类型的子类型",
        "typeVarDefaultConstraintMismatch": "TypeVar 默认类型必须是受约束类型之一",
        "typeVarDefaultIllegal": "类型变量默认类型需要 Python 3.13 或更高版本",
        "typeVarDefaultInvalidTypeVar": "类型参数“{name}”的默认类型是指超出范围的一个或多个类型变量",
        "typeVarFirstArg": "TypeVar 作为第一个参数的预期名称",
        "typeVarInvalidForMemberVariable": "属性类型不能使用作用域为本地方法的类型变量\"{name}\"",
        "typeVarNoMember": "TypeVar“{type}”没有属性“{name}”",
        "typeVarNotSubscriptable": "TypeVar“{type}”不可下标",
        "typeVarNotUsedByOuterScope": "类型变量“{name}”在此上下文中没有意义",
        "typeVarPossiblyUnsolvable": "如果调用方没有为参数提供参数\"{param}\"，则类型变量\"{name}\"可能无法解析",
        "typeVarSingleConstraint": "TypeVar 必须至少有两种约束类型",
        "typeVarTupleConstraints": "TypeVarTuple 不能有值约束",
        "typeVarTupleContext": "此上下文中不允许使用 TypeVarTuple",
        "typeVarTupleDefaultNotUnpacked": "TypeVarTuple 默认类型必须是未打包的 tuple 或 TypeVarTuple",
        "typeVarTupleMustBeUnpacked": "TypeVarTuple 值需要解包运算符",
        "typeVarTupleUnknownParam": "“{name}”是 TypeVarTuple 的未知参数",
        "typeVarUnknownParam": "\"{name}\" 是 TypeVar 的未知参数",
        "typeVarUsedByOuterScope": "TypeVar“{name}”已被外部作用域使用",
        "typeVarUsedOnlyOnce": "TypeVar \"{name}\" 在泛型函数签名中仅显示一次",
        "typeVarVariance": "TypeVar 不能同时为协变和逆变",
        "typeVarWithDefaultFollowsVariadic": "TypeVar“{typeVarName}”具有默认值，并且不能遵循 TypeVarTuple“{variadicName}”",
        "typeVarWithoutDefault": "“{name}”不能出现在类型参数列表的“{other}”后面，因为它没有默认类型",
        "typeVarsNotInGenericOrProtocol": "Generic[] 或 Protocol[] 必须包括所有类型变量",
        "typedDictAccess": "无法存取 TypedDict 中的项",
        "typedDictAssignedName": "必须将 TypedDict 分配给名为“{name}”的变量",
        "typedDictBadVar": "TypedDict 类只能包含类型批注",
        "typedDictBaseClass": "TypedDict 类的所有基类也必须是 TypedDict 类",
        "typedDictBoolParam": "预期“{name}”参数的值为 True 或 False",
        "typedDictClosedExtras": "基类 \"{name}\" 是 closed TypedDict; 额外的项必须是类型 \"{type}\"",
        "typedDictClosedNoExtras": "基类 \"{name}\" 是 closed TypedDict; 不允许使用额外的项",
        "typedDictDelete": "无法删除 TypedDict 中的项",
        "typedDictEmptyName": "TypedDict 中的名称不能为空",
        "typedDictEntryName": "字典条目名称的预期字符串文本",
        "typedDictEntryUnique": "字典中的名称必须唯一",
        "typedDictExtraArgs": "不支持额外的 TypedDict 参数",
        "typedDictExtraItemsClosed": "如果 TypedDict 支持额外项目，则无法将其 closed",
        "typedDictFieldNotRequiredRedefinition": "无法将 TypedDict 项“{name}”重新定义为 NotRequired",
        "typedDictFieldReadOnlyRedefinition": "无法将 TypedDict 项“{name}”重新定义为 ReadOnly",
        "typedDictFieldRequiredRedefinition": "无法将 TypedDict 项“{name}”重新定义为 Required",
        "typedDictFirstArg": "应将 TypedDict 类名作为第一个参数",
        "typedDictInClassPattern": "类模式中不允许使用 TypedDict 类",
        "typedDictInitsubclassParameter": "TypedDict 不支持 __init_subclass__ parameter“{name}”",
        "typedDictNotAllowed": "\"TypedDict\" 不能用于此上下文",
        "typedDictSecondArgDict": "预期的 dict 或关键字参数作为第二个参数",
        "typedDictSecondArgDictEntry": "应为简单字典条目",
        "typedDictSet": "无法在 TypedDict 中分配项",
        "unaccessedClass": "未存取类“{name}”",
        "unaccessedFunction": "无法存取函数\"{name}\"",
        "unaccessedImport": "未存取导入“{name}”",
        "unaccessedSymbol": "未存取“{name}”",
        "unaccessedVariable": "无法存取变量“{name}”",
        "unannotatedFunctionSkipped": "已跳过对函数“{name}”的分析，因为它未被批注",
        "unaryOperationNotAllowed": "类型表达式中不允许使用一元运算符",
        "unexpectedAsyncToken": "“def”、“with” 或 “for” 应跟随 “async”",
        "unexpectedExprToken": "表达式末尾出现意外标记",
        "unexpectedIndent": "意外缩进",
        "unexpectedUnindent": "不应取消缩进",
        "unhashableDictKey": "字典密钥必须可哈希",
        "unhashableSetEntry": "Set 条目必须是可哈希的",
        "uninitializedAbstractVariables": "抽象基类中定义的变量未在 final 类 \"{classType}\" 中初始化",
        "uninitializedInstanceVariable": "未在类体或__init__方法中初始化实例变量“{name}”",
        "unionForwardReferenceNotAllowed": "Union 语法不能与字符串操作数一起使用; 请在整个表达式周围使用引号",
        "unionSyntaxIllegal": "联合的替代语法需要 Python 3.10 或更高版本",
        "unionTypeArgCount": "Union 需要两个或更多类型参数",
        "unionUnpackedTuple": "Union 不能包含未打包的 tuple",
        "unionUnpackedTypeVarTuple": "Union 不能包含未打包的 TypeVarTuple",
        "unnecessaryCast": "不必要的 \"cast\" 调用；类型已为“{type}”",
        "unnecessaryIsInstanceAlways": "不必要的 isinstance 调用；“{testType}”始终是“{classType}”的实例",
        "unnecessaryIsInstanceNever": "不必要的 isinstance 调用；“{testType}”始终不是“{classType}”的实例",
        "unnecessaryIsSubclassAlways": "不必要的 issubclass 调用；“{testType}”始终是“{classType}”的子类",
        "unnecessaryIsSubclassNever": "不必要的 issubclass 调用；“{testType}”始终不是“{classType}”的子类",
        "unnecessaryPyrightIgnore": "不必要的 \"# pyright: ignore\" 注释",
        "unnecessaryPyrightIgnoreRule": "不必要的 \"# pyright: ignore\"规则: \"{name}\"",
        "unnecessaryTypeIgnore": "不必要的 \"# type: ignore\" 注释",
        "unpackArgCount": "\"Unpack\"后应为单个类型参数",
        "unpackExpectedTypeVarTuple": "Unpack 预期接收 TypeVarTuple 或 tuple 作为类型参数",
        "unpackExpectedTypedDict": "Unpack 预期接收 TypedDict 类型参数",
        "unpackIllegalInComprehension": "在推导式中不允许使用解包操作",
        "unpackInAnnotation": "类型表达式中不允许使用解包运算符",
        "unpackInDict": "字典中不允许解压缩操作",
        "unpackInSet": "set 内不允许使用解包运算符",
        "unpackNotAllowed": "此上下文中不允许 Unpack",
        "unpackOperatorNotAllowed": "此上下文中不允许解压缩操作",
        "unpackTuplesIllegal": "Python 3.8 之前的元组中不允许解包操作",
        "unpackedArgInTypeArgument": "未打包的参数不能用于此上下文",
        "unpackedArgWithVariadicParam": "未打包的参数不能用于 TypeVarTuple 参数",
        "unpackedDictArgumentNotMapping": "** 后面的参数表达式必须是具有“str”键类型的映射",
        "unpackedDictSubscriptIllegal": "不允许在下标中使用字典解包运算符",
        "unpackedSubscriptIllegal": "下标中的解包运算符需要 Python 3.11 或更高版本",
        "unpackedTypeVarTupleExpected": "应为未打包的 TypeVarTuple；使用 Unpack[{name1}] 或 *{name2}",
        "unpackedTypedDictArgument": "无法将解压缩的 TypedDict 参数与参数匹配",
        "unreachableCode": "代码无法访问",
        "unreachableCodeType": "类型分析指示代码不可访问",
        "unreachableExcept": "无法访问 Except 子句，因为已处理异常",
        "unsupportedDunderAllOperation": "不支持对“__all__”执行操作，因此导出的符号列表可能不正确",
        "unusedCallResult": "调用表达式的结果类型为 \"{type}\" 且未使用；如果这是有意为之，则分配给变量 “_”",
        "unusedCoroutine": "未使用 async 函数调用的结果; 请使用 \"await\" 或将结果分配给变量",
        "unusedExpression": "表达式值未使用",
        "varAnnotationIllegal": "变量的 Type 批注需要 Python 3.6 或更高版本; 请使用 type 注释以与以前的版本兼容",
        "variableFinalOverride": "变量\"{name}\"被标记为 Final，并替代类\"{className}\"中同名的非 Final 变量",
        "variadicTypeArgsTooMany": "类型参数列表最多可以有一个未打包的 TypeVarTuple 或 tuple",
        "variadicTypeParamTooManyAlias": "类型别名最多可以有一个 TypeVarTuple 类型参数，但收到多个 ({names})",
        "variadicTypeParamTooManyClass": "泛型类最多可以有一个 TypeVarTuple 类型参数，但收到多个 ({names})",
        "walrusIllegal": "运算符 \":=\" 需要 Python 3.8 或更高版本",
        "walrusNotAllowed": "此上下文中不允许使用运算符 \":=\"，且不带括号",
        "wildcardInFunction": "类或函数中不允许使用通配符 import",
        "wildcardLibraryImport": "不允许从库中 import 通配符",
        "wildcardPatternTypePartiallyUnknown": "通配符模式捕获的类型部分未知",
        "wildcardPatternTypeUnknown": "通配符模式捕获的类型未知",
        "yieldFromIllegal": "使用“yield from”需要 Python 3.3 或更高版本",
        "yieldFromOutsideAsync": "async 函数中不允许使用 \"yield from\"",
        "yieldOutsideFunction": "不允许在函数或 lambda 之外使用“yield”",
        "yieldWithinComprehension": "允许在推导式中使用 \"yield\"",
        "zeroCaseStatementsFound": "Match 语句必须至少包含一个 case 语句",
        "zeroLengthTupleNotAllowed": "此上下文中不允许使用零长度 tuple"
    },
    "DiagnosticAddendum": {
        "annotatedNotAllowed": "\"Annotated\" 特殊形式不能与实例和类检查一起使用",
        "argParam": "参数对应于参数“{paramName}”",
        "argParamFunction": "参数对应于函数“{functionName}”中的参数“{paramName}”",
        "argsParamMissing": "参数“*{paramName}”没有相应的参数",
        "argsPositionOnly": "仅位置参数不匹配；应为 {expected}，但收到 {received}",
        "argumentType": "参数类型为“{type}”",
        "argumentTypes": "参数类型:({types})",
        "assignToNone": "类型不可分配给“None”",
        "asyncHelp": "是否表示“async with”?",
        "baseClassIncompatible": "基类“{baseClass}”与类型“{type}”不兼容",
        "baseClassIncompatibleSubclass": "基类“{baseClass}”派生自与类型“{type}”不兼容的“{subclass}”",
        "baseClassOverriddenType": "基类\"{baseClass}\"提供被替代的类型\"{type}\"",
        "baseClassOverridesType": "基类“{baseClass}”替代类型{type}”",
        "bytesTypePromotions": "将 disableBytesTypePromotions 设置为 false，以启用“bytearray”和“memoryview”的类型提升行为",
        "conditionalRequiresBool": "类型“{operandType}”的方法__bool__返回类型“{boolReturnType}”而不是“bool”",
        "dataClassFieldLocation": "字段声明",
        "dataClassFrozen": "\"{name}\"已冻结",
        "dataProtocolUnsupported": "“{name}”是数据协议",
        "descriptorAccessBindingFailed": "无法绑定描述符类“{className}”的方法“{name}”",
        "descriptorAccessCallFailed": "无法为描述符类“{className}”调用方法“{name}”",
        "finalMethod": "Final 方法",
        "functionParamDefaultMissing": "参数“{name}”缺少默认参数",
        "functionParamName": "参数名称不匹配: \"{destName}\" versus \"{srcName}\"",
        "functionParamPositionOnly": "仅位置参数不匹配; 参数“{name}”并非仅限位置",
        "functionReturnTypeMismatch": "函数返回类型\"{sourceType}\"与类型\"{destType}\"不兼容",
        "functionTooFewParams": "函数接受的位置参数太少；应为 {expected}，但收到 {received}",
        "functionTooManyParams": "函数接受太多位置参数；应为 {expected}，但收到 {received}",
        "genericClassNotAllowed": "不允许对实例或类检查使用具有类型参数的泛型类型",
        "incompatibleDeleter": "Property deleter 方法不兼容",
        "incompatibleGetter": "Property getter 方法不兼容",
        "incompatibleSetter": "Property setter 方法不兼容",
        "initMethodLocation": "__init__方法已在类“{type}”中定义",
        "initMethodSignature": "__init__的签名为“{type}”",
        "initSubclassLocation": "__init_subclass__ 方法在类“{name}”中定义",
        "invariantSuggestionDict": "请考虑从 “dict” 切换到 “Mapping”(在值类型中为协变)",
        "invariantSuggestionList": "考虑从“list”切换到“Sequence”(协变)",
        "invariantSuggestionSet": "请考虑从“set”切换到“Container”，后者是协变的",
        "isinstanceClassNotSupported": "实例和类检查不支持“{type}”",
        "keyNotRequired": "“{type}”中“{name}”不是必需的密钥，因此访问可能会导致运行时异常",
        "keyReadOnly": "“{name}”是“{type}”中的只读密钥",
        "keyRequiredDeleted": "“{name}”是必需的密钥，无法删除",
        "keyUndefined": "“{name}”不是“{type}”中定义的密钥",
        "kwargsParamMissing": "参数“**{paramName}”没有相应的参数",
        "listAssignmentMismatch": "类型“{type}”与目标列表不兼容",
        "literalAssignmentMismatch": "“{sourceType}”不可分配给类型“{destType}”",
        "matchIsNotExhaustiveHint": "如果未进行详尽处理，请添加\"case _: pass\"",
        "matchIsNotExhaustiveType": "未处理的类型: \"{type}\"",
        "memberAssignment": "无法将类型“{type}”的表达式分配给类“{classType}”的属性“{name}”",
        "memberIsAbstract": "未实现“{type}.{name}”",
        "memberIsAbstractMore": "还有 {count} 个...",
        "memberIsClassVarInProtocol": "“{name}”在协议中定义为 ClassVar",
        "memberIsInitVar": "\"{name}\" 是 init-only 的字段",
        "memberIsInvariant": "“{name}”是固定的，因为它是可变的",
        "memberIsNotClassVarInClass": "“{name}”必须定义为 ClassVar 才能与协议兼容",
        "memberIsNotClassVarInProtocol": "“{name}”未在协议中定义为 ClassVar",
        "memberIsNotReadOnlyInProtocol": "“{name}”在协议中不是只读的",
        "memberIsReadOnlyInProtocol": "“{name}”在协议中是只读的",
        "memberIsWritableInProtocol": "“{name}”在协议中是可写入的",
        "memberSetClassVar": "无法通过类实例分配属性“{name}”，因为它是 ClassVar",
        "memberTypeMismatch": "\"{name}\"是不兼容的类型",
        "memberUnknown": "属性“{name}”未知",
        "metaclassConflict": "元类“{metaclass1}”与“{metaclass2}”存在冲突",
        "missingDeleter": "缺少 Property deleter 方法",
        "missingGetter": "缺少 Property getter 方法",
        "missingSetter": "缺少 Property setter 方法",
        "namedParamMissingInDest": "额外参数“{name}”",
        "namedParamMissingInSource": "缺少关键字参数“{name}”",
        "namedParamTypeMismatch": "类型为“{sourceType}”的关键字参数“{name}”与类型“{destType}”不兼容",
        "namedTupleNotAllowed": "不能对实例或类检查使用 NamedTuple",
        "newMethodLocation": "__new__方法已在类“{type}”中定义",
        "newMethodSignature": "__new__的签名为“{type}”",
        "newTypeClassNotAllowed": "不能将使用 NewType 创建的类用于实例和类检查",
        "noOverloadAssignable": "没有重载函数与类型“{type}”匹配",
        "noneNotAllowed": "不能对实例或类检查使用 None",
        "orPatternMissingName": "缺少名称: {name}",
        "overloadIndex": "重载 {index} 是最接近的匹配项",
        "overloadNotAssignable": "无法分配“{name}”的一个或多个重载",
        "overloadSignature": "此处定义了重载签名",
        "overriddenMethod": "替代的方法",
        "overriddenSymbol": "替代符号",
        "overrideInvariantMismatch": "替代类型“{overrideType}”与基类型“{baseType}”不同",
        "overrideIsInvariant": "变量是可变的，因此其类型是固定的",
        "overrideNoOverloadMatches": "替代中没有与基本方法兼容的重载签名",
        "overrideNotClassMethod": "基方法声明为 classmethod，但替代不是",
        "overrideNotInstanceMethod": "基方法声明为实例方法，但替代不是",
        "overrideNotStaticMethod": "基方法声明为 staticmethod，但替代不是",
        "overrideOverloadNoMatch": "替代不处理基方法的所有重载",
        "overrideOverloadOrder": "替代方法的重载必须与基方法的顺序相同",
        "overrideParamKeywordNoDefault": "关键字参数\"{name}\"不匹配: 基参数具有默认参数值，替代参数不匹配",
        "overrideParamKeywordType": "关键字参数“{name}”类型不匹配: 基参数是类型“{baseType}”，替代参数为类型“{overrideType}”",
        "overrideParamName": "参数{index}名称不匹配: 基参数命名为 \"{baseName}\"，替代参数命名为 \"{overrideName}\"",
        "overrideParamNameExtra": "基数中缺少参数“{name}”",
        "overrideParamNameMissing": "替代中缺少参数“{name}”",
        "overrideParamNamePositionOnly": "参数 {index} 不匹配: 基参数“{baseName}”是关键字参数，替代参数为仅位置参数",
        "overrideParamNoDefault": "参数 {index} 不匹配: 基参数具有默认参数值，替代参数不匹配",
        "overrideParamType": "参数 {index} 类型不匹配: 基参数为类型“{baseType}”，替代参数为类型“{overrideType}”",
        "overridePositionalParamCount": "位置参数计数不匹配；基方法具有 {baseCount}，但替代具有 {overrideCount}",
        "overrideReturnType": "返回类型不匹配:基方法返回类型\"{baseType}\"，替代返回类型\"{overrideType}\"",
        "overrideType": "基类将类型定义为\"{type}\"",
        "paramAssignment": "参数 {index}: 类型“{sourceType}”与类型“{destType}”不兼容",
        "paramSpecMissingInOverride": "替代方法中缺少 ParamSpec 参数",
        "paramType": "参数类型为“{paramType}”",
        "privateImportFromPyTypedSource": "改为从\"{module}\"导入",
        "propertyAccessFromProtocolClass": "不能以类变量形式存取协议类中定义的属性",
        "propertyMethodIncompatible": "Property 方法 \"{name}\" 不兼容",
        "propertyMethodMissing": "替代中缺少 Property 方法 \"{name}\"",
        "propertyMissingDeleter": "Property \"{name}\" 没有定义的 deleter",
        "propertyMissingSetter": "Property \"{name}\" 没有定义的 setter",
        "protocolIncompatible": "“{sourceType}”与协议“{destType}”不兼容",
        "protocolMemberMissing": "“{name}”不存在",
        "protocolRequiresRuntimeCheckable": "Protocol 类必须为 @runtime_checkable 才能用于实例和类检查",
        "protocolSourceIsNotConcrete": "“{sourceType}”不是具体类类型，无法分配给类型“{destType}”",
        "protocolUnsafeOverlap": "“{name}”的属性与协议具有相同的名称",
        "pyrightCommentIgnoreTip": "使用 \"# pyright: ignore[<diagnostic rules>]\" 抑制单行诊断",
        "readOnlyAttribute": "属性“{name}”为只读",
        "seeClassDeclaration": "查看类声明",
        "seeDeclaration": "参见声明",
        "seeFunctionDeclaration": "请参阅函数声明",
        "seeMethodDeclaration": "请参阅方法声明",
        "seeParameterDeclaration": "请参阅参数声明",
        "seeTypeAliasDeclaration": "请参阅类型别名声明",
        "seeVariableDeclaration": "查看变量声明",
        "tupleAssignmentMismatch": "类型 \"{type}\" 与目标 tuple 不兼容",
        "tupleEntryTypeMismatch": "Tuple 条目 {entry} 的类型不正确",
        "tupleSizeIndeterminateSrc": "Tuple 大小不匹配; 应为 {expected}，但收到不确定的值",
        "tupleSizeIndeterminateSrcDest": "Tuple 大小不匹配; 应为 {expected} 或更多，但收到不确定的值",
        "tupleSizeMismatch": "Tuple 大小不匹配; 应为 {expected}，但收到 {received}",
        "tupleSizeMismatchIndeterminateDest": "Tuple 大小不匹配; 应为 {expected} 或更多，但收到 {received}",
        "typeAliasInstanceCheck": "使用 \"type\" 语句创建的类型别名不能与实例和类检查一起使用",
        "typeAssignmentMismatch": "类型“{sourceType}”不可分配给类型“{destType}”",
        "typeBound": "类型“{sourceType}”不可分配给类型变量“{name}”的上限“{destType}”",
        "typeConstrainedTypeVar": "类型“{type}”不可分配给受约束的类型变量“{name}”",
        "typeIncompatible": "“{sourceType}”不可分配给“{destType}”",
        "typeNotClass": "“{type}”不是类",
        "typeNotStringLiteral": "“{type}”不是字符串文本",
        "typeOfSymbol": "“{name}”的类型为“{type}”",
        "typeParamSpec": "类型“{type}”与 ParamSpec“{name}”不兼容",
        "typeUnsupported": "类型“{type}”不受支持",
        "typeVarDefaultOutOfScope": "类型变量“{name}”不在范围内",
        "typeVarIsContravariant": "类型参数 \"{name}\" 是逆变的，但 \"{sourceType}\" 不是 \"{destType}\" 的超类型",
        "typeVarIsCovariant": "类型参数 \"{name}\" 是协变的，但 \"{sourceType}\" 不是 \"{destType}\" 的子类型",
        "typeVarIsInvariant": "类型参数 \"{name}\" 是固定的，但 \"{sourceType}\" 与 \"{destType}\" 不同",
        "typeVarNotAllowed": "不允许对实例或类检查使用 TypeVar",
        "typeVarTupleRequiresKnownLength": "TypeVarTuple 不能绑定到长度未知的 tuple",
        "typeVarUnnecessarySuggestion": "请改用 {type}",
        "typeVarUnsolvableRemedy": "提供一个重载，该重载指定未提供参数时的返回类型",
        "typeVarsMissing": "缺少类型变量: {names}",
        "typedDictBaseClass": "类“{type}”不是 TypedDict",
        "typedDictClassNotAllowed": "不允许对实例或类检查使用 TypedDict 类",
        "typedDictClosedExtraNotAllowed": "无法添加项“{name}”",
        "typedDictClosedExtraTypeMismatch": "无法添加类型为“{type}”的项“{name}”",
        "typedDictClosedFieldNotRequired": "无法添加项“{name}”，因为它必须是 NotRequired",
        "typedDictExtraFieldNotAllowed": "“{type}”中不存在“{name}”",
        "typedDictExtraFieldTypeMismatch": "“{name}”的类型与“{type}”中的 “extra_items” 类型不兼容",
        "typedDictFieldMissing": "\"{type}\"中缺少\"{name}\"",
        "typedDictFieldNotReadOnly": "\"{name}\"在\"{type}\"中不是只读的",
        "typedDictFieldNotRequired": "“{type}”中不需要“{name}”",
        "typedDictFieldRequired": "\"{type}\"中需要\"{name}\"",
        "typedDictFieldTypeMismatch": "类型“{type}”不可分配给项“{name}”",
        "typedDictFieldUndefined": "“{name}”是类型“{type}”中的未定义项",
        "typedDictFinalMismatch": "\"{sourceType}\"与\"{destType}\"不兼容，因为@final不匹配",
        "typedDictKeyAccess": "使用 [\"{name}\"] 引用 TypedDict 中的项",
        "typedDictNotAllowed": "不能对实例或类检查使用 TypedDict",
        "unhashableType": "类型“{type}”不可哈希",
        "uninitializedAbstractVariable": "实例变量“{name}”在抽象基类“{classType}”中定义，但未初始化",
        "unreachableExcept": "“{exceptionType}”是“{parentType}”的子类",
        "useDictInstead": "使用 dict[T1, T2] 指示字典类型",
        "useListInstead": "使用 list[T] 指示 list 类型或使用 T1 | T2 指示 union 类型",
        "useTupleInstead": "使用 tuple[T1, ..., Tn] 指示 tuple 类型或使用 T1 | T2 指示 union 类型",
        "useTypeInstead": "改用 type[T]",
        "varianceMismatchForClass": "类型参数\"{typeVarName}\"的差异与基类\"{className}\"不兼容",
        "varianceMismatchForTypeAlias": "类型参数\"{typeVarName}\"的差异与\"{typeAliasParam}\"不兼容"
    },
    "Service": {
        "longOperation": "枚举工作区源文件需要很长时间。请考虑打开子文件夹。[了解详细信息](https://aka.ms/workspace-too-many-files)"
    }
}
