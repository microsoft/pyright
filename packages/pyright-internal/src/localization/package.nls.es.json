{
    "CodeAction": {
        "createTypeStub": "Crear Tipo Stub",
        "createTypeStubFor": "Crear Tipo Stub Para \"{moduleName}\"",
        "executingCommand": "Ejecutando el comando",
        "filesToAnalyzeCount": "{count} archivos para analizar",
        "filesToAnalyzeOne": "1 archivo para analizar",
        "findingReferences": "Buscando referencias",
        "organizeImports": "Organizar Importaciones",
        "renameShadowedFile": "Cambie el nombre de \"{oldFile}\" a \"{newFile}\""
    },
    "Completion": {
        "autoImportDetail": "Importación automática",
        "indexValueDetail": "Valor de índice"
    },
    "Diagnostic": {
        "abstractMethodInvocation": "No se puede llamar al método \"{method}\" porque es abstracto y no se ha implementado.",
        "annotatedMetadataInconsistent": "El tipo de metadatos anotados \"{metadataType}\" no es compatible con el tipo \"{type}\"",
        "annotatedParamCountMismatch": "El recuento de anotaciones del parámetro no coincide: se esperaba {expected}, pero se recibió {received}",
        "annotatedTypeArgMissing": "Se espera un argumento de tipo y una o más anotaciones para \"Annotated\".",
        "annotationBytesString": "Las expresiones de tipo no pueden usar literales de cadena de bytes",
        "annotationFormatString": "Las expresiones de tipo no pueden usar literales de cadena de formato (f-strings)",
        "annotationNotSupported": "No se admite la anotación de tipo para esta declaración",
        "annotationRawString": "Las expresiones de tipo no pueden usar literales de cadena sin formato",
        "annotationSpansStrings": "Las expresiones de tipo no pueden abarcar varios literales de cadena",
        "annotationStringEscape": "Las expresiones de tipo no pueden contener caracteres de escape",
        "argAssignment": "Argumento de tipo \"{argType}\" no puede ser asignado a parámetro de tipo \"{paramType}\"",
        "argAssignmentFunction": "El argumento de tipo \"{argType}\" no puede ser asignado a parámetro de tipo \"{paramType}\" en función \"{functionName}\"",
        "argAssignmentParam": "Argumento de tipo \"{argType}\" no puede ser asignado a parámetro \"{paramName}\" de tipo \"{paramType}\"",
        "argAssignmentParamFunction": "Argumento de tipo \"{argType}\" no puede ser asignado a parámetro \"{paramName}\" de tipo \"{paramType}\" en función \"{functionName}\"",
        "argMissingForParam": "Falta el argumento para el parámetro {name}",
        "argMissingForParams": "Faltan argumentos para los parámetros {names}",
        "argMorePositionalExpectedCount": "Más argumentos posicionales {expected} esperados",
        "argMorePositionalExpectedOne": "Se espera 1 argumento posicional más",
        "argPositional": "Argumento posicional esperado",
        "argPositionalExpectedCount": "Argumentos posicionales esperados {expected}",
        "argPositionalExpectedOne": "Se espera 1 argumento posicional",
        "argTypePartiallyUnknown": "El tipo de argumento es parcialmente desconocido",
        "argTypeUnknown": "Tipo de argumento desconocido",
        "assertAlwaysTrue": "La expresión Assert siempre se evalúa como true",
        "assertTypeArgs": "\"assert_type\" espera dos argumentos posicionales",
        "assertTypeTypeMismatch": "Error de coincidencia \"assert_type\": se esperaba \"{expected}\" pero se ha recibido \"{received}\"",
        "assignmentExprComprehension": "El destino de la expresión de asignación \"{name}\" no puede usar el mismo nombre que la comprensión para el destino",
        "assignmentExprContext": "La expresión de asignación debe estar dentro de un módulo, función o lambda",
        "assignmentExprInSubscript": "Las expresiones de asignación dentro de un subíndice solo se admiten en Python 3.10 y versiones posteriores.",
        "assignmentInProtocol": "Las variables de instancia o clase dentro de una clase Protocol deben declararse explícitamente en el cuerpo de la clase.",
        "assignmentTargetExpr": "La expresión no puede ser objetivo de asignación",
        "asyncNotInAsyncFunction": "No se permite el uso de \"async\" fuera de la función async",
        "awaitIllegal": "El uso de \"await\" requiere Python 3.5 o posterior.",
        "awaitNotAllowed": "Las expresiones de tipo no pueden usar \"await\"",
        "awaitNotInAsync": "\"await\" solo se permite dentro de una función async",
        "backticksIllegal": "En Python 3.x no se admiten expresiones rodeadas de puntos suspensivos; utilice repr en su lugar.",
        "baseClassCircular": "La clase no se puede derivar de sí misma",
        "baseClassFinal": "La clase base \"{type}\" está marcada como final y no puede ser subclasificada",
        "baseClassIncompatible": "Las clases base de {type} son mutuamente incompatibles",
        "baseClassInvalid": "El argumento de la clase debe ser una clase base",
        "baseClassMethodTypeIncompatible": "Las clases base para la clase \"{classType}\" definen el método \"{name}\" de forma incompatible",
        "baseClassUnknown": "Se desconoce el tipo de la clase base, lo que oculta el tipo de la clase derivada.",
        "baseClassVariableTypeIncompatible": "Las clases base para la clase \"{classType}\" definen la variable \"{name}\" de forma incompatible",
        "binaryOperationNotAllowed": "Operador binario no permitido en la expresión de tipo",
        "bindTypeMismatch": "No se pudo enlazar el método \"{methodName}\" porque \"{type}\" no se puede asignar al parámetro \"{paramName}\"",
        "breakOutsideLoop": "\"break\" solo se puede usar dentro de un bucle",
        "callableExtraArgs": "Se esperaban solo dos argumentos de tipo para \"Callable\".",
        "callableFirstArg": "Lista de tipos de parámetros esperados o \"...\"",
        "callableNotInstantiable": "No se puede instanciar el tipo \"{type}\"",
        "callableSecondArg": "Tipo de retorno esperado como segundo argumento de tipo para \"Callable\"",
        "casePatternIsIrrefutable": "El patrón irrefutable solo se permite para la última instrucción case",
        "classAlreadySpecialized": "El tipo \"{type}\" ya está especializado",
        "classDecoratorTypeUnknown": "El decorador de clase sin tipo oculta el tipo de clase; omitiendo el elemento Decorator",
        "classDefinitionCycle": "La definición de clase para \"{name}\" depende de sí misma.",
        "classGetItemClsParam": "__class_getitem__ debe tomar un parámetro \"cls\"",
        "classMethodClsParam": "Los métodos de clase deben tomar un parámetro \"cls\"",
        "classNotRuntimeSubscriptable": "El subíndice para la clase \"{name}\" generará una excepción en tiempo de ejecución; encierre la expresión de tipo entre comillas",
        "classPatternBuiltInArgPositional": "El patrón de clase solo acepta subpatrones posicionales",
        "classPatternPositionalArgCount": "Demasiados patrones posicionales para la clase \"{type}\"; esperado {expected} pero recibido {received}",
        "classPatternTypeAlias": "\"{type}\" no se puede usar en un patrón de clase porque es un alias de tipo especializado",
        "classPropertyDeprecated": "Las propiedades de clase están en desuso en Python 3.11 y no se admitirán en Python 3.13.",
        "classTypeParametersIllegal": "La sintaxis de los parámetros de tipo de clase requiere Python 3.12 o posterior.",
        "classVarFirstArgMissing": "Se esperaba un argumento de tipo después de \"ClassVar\"",
        "classVarNotAllowed": "\"ClassVar\" no está permitido en este contexto",
        "classVarOverridesInstanceVar": "La variable de clase \"{name}\" anula la variable de instancia del mismo nombre en la clase \"{className}\"",
        "classVarTooManyArgs": "Solo se esperaba un argumento de tipo después de \"ClassVar\"",
        "classVarWithTypeVar": "El tipo \"ClassVar\" no puede incluir variables de tipo",
        "clsSelfParamTypeMismatch": "El tipo de parámetro \"{name}\" debe ser un supertipo de su clase \"{classType}\"",
        "codeTooComplexToAnalyze": "El código es demasiado complejo para analizarlo; reduzca la complejidad refactorizándolo en subrutinas o reduciendo las rutas de código condicional.",
        "collectionAliasInstantiation": "No se puede crear una instancia del tipo \"{type}\"; use \"{alias}\" en su lugar.",
        "comparisonAlwaysFalse": "La condición siempre se evaluará como False, ya que los tipos \"{leftType}\" y \"{rightType}\" no se superponen.",
        "comparisonAlwaysTrue": "La condición siempre se evaluará como True, ya que los tipos \"{leftType}\" y \"{rightType}\" no se superponen.",
        "comprehensionInDict": "La comprensión no puede utilizarse con otras entradas del diccionario",
        "comprehensionInSet": "La comprensión no se puede usar con otras entradas de set",
        "concatenateContext": "\"Concatenate\" no se permite en este contexto",
        "concatenateParamSpecMissing": "El último argumento de tipo para \"Concatenate\" debe ser un ParamSpec o \"...\"",
        "concatenateTypeArgsMissing": "\"Concatenate\" requiere al menos dos argumentos de tipo",
        "conditionalOperandInvalid": "Operando condicional no válido de tipo \"{type}\"",
        "constantRedefinition": "\"{name}\" es constante (porque está en mayúsculas) y no se puede volver a definir",
        "constructorParametersMismatch": "Error de coincidencia entre la firma de __new__ y __init__ en la clase \"{classType}\"",
        "containmentAlwaysFalse": "La expresión siempre se evaluará como False, ya que los tipos \"{leftType}\" y \"{rightType}\" no tienen superposición",
        "containmentAlwaysTrue": "La expresión siempre se evaluará como True, ya que los tipos \"{leftType}\" y \"{rightType}\" no tienen superposición",
        "continueInFinally": "\"continue\" no puede utilizarse dentro de una cláusula finally",
        "continueOutsideLoop": "\"continue\" solo puede utilizarse dentro de un bucle",
        "coroutineInConditionalExpression": "La expresión condicional hace referencia a una corrutina que siempre se evalúa como True",
        "dataClassBaseClassFrozen": "Una clase no inmovilizada no puede heredar de una clase inmovilizada",
        "dataClassBaseClassNotFrozen": "Una clase congelada no puede heredar de una clase que no esté congelada",
        "dataClassConverterFunction": "Argumento de tipo \"{argType}\" no es un convertidor válido para el campo \"{fieldName}\" de tipo \"{fieldType}\"",
        "dataClassConverterOverloads": "No hay sobrecargas de \"{funcName}\" que sean convertidores válidos para el campo \"{fieldName}\" de tipo \"{fieldType}\"",
        "dataClassFieldInheritedDefault": "\"{fieldName}\" invalida un campo con el mismo nombre, pero falta un valor predeterminado",
        "dataClassFieldWithDefault": "Los campos sin valores predeterminados no pueden aparecer después de los campos con valores predeterminados",
        "dataClassFieldWithPrivateName": "El campo Dataclass no puede utilizar un nombre privado",
        "dataClassFieldWithoutAnnotation": "El campo Dataclass sin anotación de tipo provocará una excepción en tiempo de ejecución",
        "dataClassPostInitParamCount": "Dataclass __post_init__ recuento de parámetros incorrecto; el número de campos InitVar es {expected}.",
        "dataClassPostInitType": "El tipo de parámetro del método __post_init__ de la clase de datos no coincide con el del campo \"{fieldName}\".",
        "dataClassSlotsOverwrite": "__slots__ ya está definido en la clase",
        "dataClassTransformExpectedBoolLiteral": "Expresión esperada que se evalúa estáticamente como True o False",
        "dataClassTransformFieldSpecifier": "Se esperaba una tuple de clases o funciones, pero se recibió el tipo \"{type}\"",
        "dataClassTransformPositionalParam": "Todos los argumentos de \"dataclass_transform\" deben ser argumentos de palabra clave",
        "dataClassTransformUnknownArgument": "El argumento \"{name}\" no es compatible con dataclass_transform",
        "dataProtocolInSubclassCheck": "No se permiten protocolos de datos (que incluyen atributos que no son de método) en llamadas issubclass",
        "declaredReturnTypePartiallyUnknown": "El tipo de retorno declarado, \"{returnType}\", es parcialmente desconocido",
        "declaredReturnTypeUnknown": "El tipo de retorno declarado es desconocido",
        "defaultValueContainsCall": "No se permiten llamadas de función y objetos mutables dentro de la expresión de valor predeterminado del parámetro",
        "defaultValueNotAllowed": "Los parámetros con \"*\" o \"**\" no pueden tener valor por defecto",
        "delTargetExpr": "No se puede eliminar la expresión",
        "deprecatedClass": "La clase \"{name}\" está en desuso",
        "deprecatedConstructor": "El constructor de la clase \"{name}\" está obsoleto",
        "deprecatedDescriptorDeleter": "El método \"__delete__\" para el \"{name}\" de descriptor está en desuso",
        "deprecatedDescriptorGetter": "El método \"__get__\" para el \"{name}\" de descriptor está en desuso",
        "deprecatedDescriptorSetter": "El método \"__set__\" para el \"{name}\" de descriptor está en desuso",
        "deprecatedFunction": "La función \"{name}\" está obsoleta",
        "deprecatedMethod": "El método \"{name}\" en la clase \"{className}\" está en desuso",
        "deprecatedPropertyDeleter": "El deleter de la property \"{name}\" está en desuso",
        "deprecatedPropertyGetter": "El getter de la property \"{name}\" está en desuso",
        "deprecatedPropertySetter": "El setter de la property \"{name}\" está en desuso",
        "deprecatedType": "Este tipo está obsoleto a partir de la {version} de Python; utilice en su lugar \"{replacement}\".",
        "dictExpandIllegalInComprehension": "No se permite la ampliación del diccionario en la comprensión",
        "dictInAnnotation": "Expresión de diccionario no permitida en expresión de tipo",
        "dictKeyValuePairs": "Las entradas del diccionario deben contener pares clave/valor",
        "dictUnpackIsNotMapping": "Asignación esperada para el operador de desempaquetado del diccionario",
        "dunderAllSymbolNotPresent": "\"{name}\" se especifica en __all__ pero no está presente en el módulo",
        "duplicateArgsParam": "Solo se permite un parámetro \"*\".",
        "duplicateBaseClass": "Clase base duplicada no permitida",
        "duplicateCapturePatternTarget": "El destino de captura \"{name}\" no puede aparecer más de una vez dentro del mismo patrón",
        "duplicateCatchAll": "Solo se permite una cláusula de except",
        "duplicateEnumMember": "El miembro Enum \"{name}\" ya está declarado",
        "duplicateGenericAndProtocolBase": "Solo se permite una clase base Generic[...] o Protocol[...].",
        "duplicateImport": "\"{importName}\" se importa más de una vez",
        "duplicateKeywordOnly": "Solo se permite un separador \"*\".",
        "duplicateKwargsParam": "Solo se permite un parámetro \"**\".",
        "duplicateParam": "Parámetro duplicado \"{name}\"",
        "duplicatePositionOnly": "Solo se permite un parámetro \"/\"",
        "duplicateStarPattern": "Solo se permite un patrón \"*\" en una secuencia de patrones",
        "duplicateStarStarPattern": "Solo se permite una entrada \"**\"",
        "duplicateUnpack": "Solo se permite una operación de desempaquetado en la lista",
        "ellipsisAfterUnpacked": "\"...\" no se puede usar con una TypeVarTuple o tuple sin empaquetar",
        "ellipsisContext": "\"...\" no está permitido en este contexto",
        "ellipsisSecondArg": "\"...\" está permitido sólo como el segundo de dos argumentos",
        "enumClassOverride": "La clase Enum \"{name}\" es final y no puede ser subclasificada",
        "enumMemberDelete": "No se puede eliminar el miembro de Enum \"{name}\"",
        "enumMemberSet": "No se puede asignar el miembro de Enum \"{name}\"",
        "enumMemberTypeAnnotation": "No se permiten anotaciones de tipo para miembros de enumeración",
        "exceptionGroupIncompatible": "La sintaxis de grupo de excepciones (\"except*\") requiere Python 3.11 o posterior.",
        "exceptionGroupTypeIncorrect": "El tipo de excepción en except* no puede derivarse de BaseGroupException",
        "exceptionTypeIncorrect": "\"{type}\" no se deriva de BaseException",
        "exceptionTypeNotClass": "\"{type}\" no es una clase de excepción válida",
        "exceptionTypeNotInstantiable": "El constructor para el tipo de excepción \"{type}\" requiere uno o más argumentos",
        "expectedAfterDecorator": "Se esperaba una declaración de función o clase después del decorador",
        "expectedArrow": "Se esperaba \"->\" seguido de una anotación de tipo de retorno",
        "expectedAsAfterException": "Se esperaba \"as\" después del tipo de excepción",
        "expectedAssignRightHandExpr": "Expresión esperada a la derecha de \"=\"",
        "expectedBinaryRightHandExpr": "Expresión esperada a la derecha del operador",
        "expectedBoolLiteral": "Se esperaba True o False",
        "expectedCase": "Declaración \"case\" esperada",
        "expectedClassName": "Nombre de clase esperado",
        "expectedCloseBrace": "\"{\" no estaba cerrado",
        "expectedCloseBracket": "\"[\" no estaba cerrado",
        "expectedCloseParen": "\"(\" no estaba cerrado",
        "expectedColon": "Se esperaba \":\"",
        "expectedComplexNumberLiteral": "Número complejo literal esperado para la concordancia de patrones",
        "expectedDecoratorExpr": "Forma de expresión no compatible con Decorator anterior a Python 3.9",
        "expectedDecoratorName": "Nombre esperado del Decorator",
        "expectedDecoratorNewline": "Nueva línea esperada al final de Decorator",
        "expectedDelExpr": "Expresión esperada después de \"del\"",
        "expectedElse": "Se espera \"else\"",
        "expectedEquals": "Se esperaba \"=\"",
        "expectedExceptionClass": "Clase o objeto de excepción no válido",
        "expectedExceptionObj": "Objeto de excepción esperado, clase de excepción o None",
        "expectedExpr": "Se esperaba una expresión",
        "expectedFunctionAfterAsync": "Definición de función esperada después de \"async\"",
        "expectedFunctionName": "Se esperaba nombre de la función luego de \"def\"",
        "expectedIdentifier": "Identificador esperado",
        "expectedImport": "Se espera \"import\"",
        "expectedImportAlias": "Símbolo esperado después de \"as\"",
        "expectedImportSymbols": "Se esperan uno o más nombres de símbolos tras la importación",
        "expectedIn": "Se esperaba \"in\"",
        "expectedInExpr": "Expresión esperada después de \"in\"",
        "expectedIndentedBlock": "Bloque con sangría previsto",
        "expectedMemberName": "Se esperaba un nombre de atributo después de \".\"",
        "expectedModuleName": "Nombre de módulo esperado",
        "expectedNameAfterAs": "Se esperaba un nombre de símbolo después de \"as\"",
        "expectedNamedParameter": "El parámetro de palabra clave debe ir después de \"*\".",
        "expectedNewline": "Nueva línea esperada",
        "expectedNewlineOrSemicolon": "Las declaraciones deben ir separadas por nuevas líneas o punto y coma",
        "expectedOpenParen": "Se espera \"(\"",
        "expectedParamName": "Nombre esperado del parámetro",
        "expectedPatternExpr": "Expresión del patrón esperado",
        "expectedPatternSubjectExpr": "Expresión de asunto de patrón esperada",
        "expectedPatternValue": "Expresión de valor de patrón esperada de la forma \"a.b\"",
        "expectedReturnExpr": "Expresión esperada después de \"return\"",
        "expectedSliceIndex": "Expresión de índice o segmento esperada",
        "expectedTypeNotString": "Se esperaba un tipo pero se ha recibido una cadena literal",
        "expectedTypeParameterName": "Nombre de parámetro de tipo esperado",
        "expectedYieldExpr": "Expresión esperada en la instrucción yield",
        "finalClassIsAbstract": "La clase \"{type}\" está marcada como final y debe implementar todos los símbolos abstractos",
        "finalContext": "\"Final\" no está permitido en este contexto",
        "finalInLoop": "No se puede asignar una variable \"Final\" dentro de un bucle",
        "finalMethodOverride": "El método \"{name}\" no puede anular el método final definido en la clase \" {className}\"",
        "finalNonMethod": "La función \"{name}\" no se puede marcar @final porque no es un método",
        "finalReassigned": "\"{name}\" se declara como Final y no se puede reasignar",
        "finalRedeclaration": "\"{name}\" se declaró anteriormente como Final",
        "finalRedeclarationBySubclass": "\"{name}\" no puede ser redeclarado porque la clase padre \"{className}\" lo declara como Final",
        "finalTooManyArgs": "Se esperaba un único argumento de tipo después de \"Final\".",
        "finalUnassigned": "\"{name}\" se declara Final, pero no se asigna valor",
        "formatStringBrace": "No se permite una llave de cierre única dentro del literal de cadena f; usar llave de cierre doble",
        "formatStringBytes": "Los literales de cadena de formato (f-strings) no pueden ser binarios",
        "formatStringDebuggingIllegal": "El especificador de depuración de cadena F \"=\" requiere Python 3.8 o posterior",
        "formatStringEscape": "Secuencia de escape (barra diagonal inversa) no permitida en la parte de expresión de f-string anterior a Python 3.12",
        "formatStringExpectedConversion": "Se esperaba un especificador de conversión después de \"!\" en f-string",
        "formatStringIllegal": "Los literales de cadena de formato (f-strings) requieren Python 3.6 o posterior",
        "formatStringInPattern": "Cadena de formato no permitida en el patrón",
        "formatStringNestedFormatSpecifier": "Expresiones anidadas demasiado profundamente dentro del especificador de cadena de formato",
        "formatStringNestedQuote": "Las cadenas anidadas dentro de una cadena f no pueden usar el mismo carácter de comillas que la cadena f anterior a Python 3.12",
        "formatStringUnicode": "Los literales de cadena de formato (cadenas f) no pueden ser unicode",
        "formatStringUnterminated": "Expresión sin terminar en f-string; se esperaba \"}\"",
        "functionDecoratorTypeUnknown": "Un decorator de función no tipificado oculta el tipo de función; ignorar el decorator",
        "functionInConditionalExpression": "La expresión condicional hace referencia a una función que siempre se evalúa como True",
        "functionTypeParametersIllegal": "La sintaxis del parámetro de tipo de función requiere Python 3.12 o posterior",
        "futureImportLocationNotAllowed": "Las importaciones desde __future__ deben estar al principio del fichero",
        "generatorAsyncReturnType": "El tipo de retorno de la función generadora async debe ser compatible con \"AsyncGenerator[{yieldType}, Any]\"",
        "generatorNotParenthesized": "Las expresiones del generador deben ir entre paréntesis si no son el único argumento",
        "generatorSyncReturnType": "El tipo de retorno de la función generadora debe ser compatible con \"Generator[{yieldType}, Any, Any]\"",
        "genericBaseClassNotAllowed": "La clase base \"Generic\" no se puede usar con la sintaxis de parámetro de tipo",
        "genericClassAssigned": "No se puede asignar un tipo de clase genérico",
        "genericClassDeleted": "No se puede eliminar el tipo de clase genérica",
        "genericInstanceVariableAccess": "El acceso a la variable de instancia genérica a través de la clase es ambiguo",
        "genericNotAllowed": "\"Generic\" no es válido en este contexto",
        "genericTypeAliasBoundTypeVar": "Los alias de tipo genérico dentro de una clase no pueden utilizar variables de tipo vinculadas {names}.",
        "genericTypeArgMissing": "\"Generic\" requiere al menos un argumento de tipo",
        "genericTypeArgTypeVar": "El argumento de tipo para \"Generic\" debe ser una variable de tipo",
        "genericTypeArgUnique": "Los argumentos de tipo para \"Generic\" deben ser únicos",
        "globalReassignment": "\"{name}\" se asigna antes de la declaración global",
        "globalRedefinition": "\"{name}\" ya ha sido declarado global",
        "implicitStringConcat": "No se permite la concatenación implícita de cadenas",
        "importCycleDetected": "Ciclo detectado en la cadena de importación",
        "importDepthExceeded": "La profundidad de la cadena de importación superó {depth}",
        "importResolveFailure": "No se ha podido resolver la importación \"{importName}\".",
        "importSourceResolveFailure": "La importación \"{importName}\" no se ha podido resolver desde el origen",
        "importSymbolUnknown": "\"{name}\" es un símbolo de importación desconocido",
        "incompatibleMethodOverride": "El método \"{name}\" sobrescribe la clase \"{className}\" de forma incompatible",
        "inconsistentIndent": "La cantidad sin sangría no coincide con la sangría anterior",
        "inconsistentTabs": "Uso incoherente de tabuladores y espacios en la sangría",
        "initMethodSelfParamTypeVar": "La anotación de tipo para el parámetro \"self\" del método \"__init__\" no puede contener variables de tipo con ámbito de clase",
        "initMustReturnNone": "El tipo de retorno de \"__init__\" debe ser None",
        "initSubclassCallFailed": "Argumentos de palabra clave incorrectos para el método __init_subclass__",
        "initSubclassClsParam": "__init_subclass__ debe tomar un parámetro \"cls\"",
        "initVarNotAllowed": "\"InitVar\" no se permite en este contexto",
        "instanceMethodSelfParam": "Los métodos de instancia deben tomar un parámetro \"self\"",
        "instanceVarOverridesClassVar": "La variable de instancia \"{name}\" invalida la variable de clase del mismo nombre en la clase \"{className}\"",
        "instantiateAbstract": "No se puede instanciar la clase abstracta \"{type}\"",
        "instantiateProtocol": "No se puede crear una instancia de la clase Protocol \"{type}\"",
        "internalBindError": "Se ha producido un error interno al vincular el archivo \"{file}\": {message}",
        "internalParseError": "Se ha producido un error interno al procesar el archivo \"{file}\": {message}",
        "internalTypeCheckingError": "Se ha producido un error interno al comprobar el tipo de archivo \"{file}\":{message}",
        "invalidIdentifierChar": "Carácter no válido en el identificador",
        "invalidStubStatement": "La declaración no tiene sentido dentro de un archivo de tipo stub",
        "invalidTokenChars": "Carácter \"{text}\" no válido en el token",
        "isInstanceInvalidType": "El segundo argumento de \"isinstance\" debe ser una clase o tuple de clases",
        "isSubclassInvalidType": "El segundo argumento de \"issubclass\" debe ser una clase o tuple de clases",
        "keyValueInSet": "No se permiten pares de clave/valor dentro de un set",
        "keywordArgInTypeArgument": "No se pueden usar argumentos de palabra clave en listas de argumentos de tipo",
        "keywordArgShortcutIllegal": "El acceso directo del argumento de palabra clave requiere Python 3.14 o posterior",
        "keywordOnlyAfterArgs": "No se permite el separador de argumentos por palabra clave después del parámetro \"*\".",
        "keywordParameterMissing": "Uno o varios parámetros de palabra clave deben seguir el parámetro \"*\"",
        "keywordSubscriptIllegal": "No se admiten argumentos de palabra clave dentro de subíndices",
        "lambdaReturnTypePartiallyUnknown": "El tipo de retorno de la lambda \"{returnType}\" es parcialmente desconocido.",
        "lambdaReturnTypeUnknown": "Se desconoce el tipo de retorno de la lambda",
        "listAssignmentMismatch": "La expresión con el tipo \"{type}\" no puede asignarse a la lista de destino",
        "listInAnnotation": "No se permite la expresión de List en la expresión de tipo",
        "literalEmptyArgs": "Se esperaban uno o varios argumentos de tipo después de \"Literal\"",
        "literalNamedUnicodeEscape": "No se admiten secuencias de escape Unicode con nombre en las anotaciones de cadena de \"Literales\".",
        "literalNotAllowed": "\"Literal\" no se puede usar en este contexto sin un argumento de tipo",
        "literalNotCallable": "El tipo Literal no puede instanciarse",
        "literalUnsupportedType": "Los argumentos de tipo para \"Literal\" deben ser None, un valor literal (int, bool, str, o bytes), o un valor enum",
        "matchIncompatible": "Las declaraciones de Match requieren Python 3.10 o posterior",
        "matchIsNotExhaustive": "Los casos dentro de la declaración de match no tratan exhaustivamente todos los valores",
        "maxParseDepthExceeded": "Se ha superado la profundidad máxima de análisis; divida la expresión en subexpresiones más pequeñas.",
        "memberAccess": "No se puede tener acceso al atributo \"{name}\" para la clase \"{type}\"",
        "memberDelete": "No se puede eliminar el atributo \"{name}\" de la clase \"{type}\"",
        "memberSet": "No se puede asignar al atributo \"{name}\" para la clase \"{type}\"",
        "metaclassConflict": "La metaclase de una clase derivada debe ser una subclase de las metaclases de todas sus clases base",
        "metaclassDuplicate": "Solo se puede proporcionar una metaclase",
        "metaclassIsGeneric": "La metaclase no puede ser genérica",
        "methodNotDefined": "Método \"{name}\" no definido",
        "methodNotDefinedOnType": "Método \"{name}\" no definido en el tipo \"{type}\"",
        "methodOrdering": "No se puede crear una ordenación coherente de los métodos",
        "methodOverridden": "\"{name}\" invalida el método del mismo nombre en la clase \"{className}\" con el tipo incompatible \"{type}\"",
        "methodReturnsNonObject": "El método \"{name}\" no devuelve un objeto",
        "missingSuperCall": "El método \"{methodName}\" no llama al método del mismo nombre en la clase principal.",
        "mixingBytesAndStr": "No se pueden concatenar los valores de bytes y str",
        "moduleAsType": "El módulo no se puede usar como tipo.",
        "moduleNotCallable": "No se puede llamar al módulo",
        "moduleUnknownMember": "\"{memberName}\" no es un atributo conocido del módulo \"{moduleName}\"",
        "namedExceptAfterCatchAll": "Una cláusula except con nombre no puede aparecer después de la cláusula catch-all except",
        "namedParamAfterParamSpecArgs": "El parámetro de palabra clave \"{name}\" no puede aparecer en la firma después del parámetro ParamSpec args",
        "namedTupleEmptyName": "Los nombres de una tuple con nombre no pueden estar vacíos",
        "namedTupleEntryRedeclared": "No se puede invalidar \"{name}\" porque la clase primaria \"{className}\" es una tuple con nombre",
        "namedTupleFirstArg": "Nombre de clase de tuple como primer argumento",
        "namedTupleMultipleInheritance": "No se admite la herencia múltiple con NamedTuple",
        "namedTupleNameKeyword": "Los nombres de campo no pueden ser una palabra clave",
        "namedTupleNameType": "tuple de dos entradas esperada que especifica el nombre y el tipo de entrada",
        "namedTupleNameUnique": "Los nombres dentro de una tuple con nombre deben ser únicos",
        "namedTupleNoTypes": "\"namedtuple\" no proporciona tipos para las entradas de tupla; utilice en su lugar \"NamedTuple\".",
        "namedTupleSecondArg": "list de entradas de tuple con nombre esperada como segundo argumento",
        "newClsParam": "__new__ debe tomar un parámetro \"cls\"",
        "newTypeAnyOrUnknown": "El segundo argumento de NewType debe ser una clase conocida, no Any ni Unknown",
        "newTypeBadName": "El primer argumento de NewType debe ser una cadena literal",
        "newTypeLiteral": "NewType no se puede usar con el tipo Literal",
        "newTypeNameMismatch": "NewType debe asignarse a una variable con el mismo nombre",
        "newTypeNotAClass": "Clase esperada como segundo argumento de NewType",
        "newTypeParamCount": "NewType requiere dos argumentos posicionales",
        "newTypeProtocolClass": "NewType no se puede usar con un tipo estructural (Protocol o clase TypedDict)",
        "noOverload": "Ninguna sobrecarga para \"{name}\" coincide con los argumentos proporcionados",
        "noReturnContainsReturn": "La función con tipo de return declarado \"NoReturn\" no puede incluir una sentencia return",
        "noReturnContainsYield": "La función con tipo de retorno declarado \"NoReturn\" no puede incluir una instrucción yield",
        "noReturnReturnsNone": "La función con el tipo de valor devuelto declarado \"NoReturn\" no puede devolver \"None\"",
        "nonDefaultAfterDefault": "El argumento no predeterminado sigue al argumento predeterminado",
        "nonLocalInModule": "Declaración Nonlocal no permitida a nivel de módulo",
        "nonLocalNoBinding": "No se ha encontrado ningún enlace para \"{name}\" nonlocal.",
        "nonLocalReassignment": "\"{name}\" se asigna antes de la declaración nonlocal",
        "nonLocalRedefinition": "\"{name}\" ya fue declarado nonlocal",
        "noneNotCallable": "No se puede llamar al objeto de tipo \"None\"",
        "noneNotIterable": "No se puede utilizar un objeto de tipo \"None\" como valor iterable",
        "noneNotSubscriptable": "El objeto de tipo \"None\" no se puede suscribir",
        "noneNotUsableWith": "Object of type \"None\" cannot be used with \"with\"",
        "noneOperator": "El operador \"{operator}\" no es compatible con \"None\".",
        "noneUnknownMember": "\"{name}\" no es un atributo conocido de \"None\"",
        "notRequiredArgCount": "Se esperaba un único argumento de tipo después de \"NotRequired\".",
        "notRequiredNotInTypedDict": "\"NotRequired\" no está permitido en este contexto",
        "objectNotCallable": "El objeto de tipo \"{type}\" no es invocable",
        "obscuredClassDeclaration": "La declaración de clase \"{name}\" queda oculta por una declaración del mismo nombre",
        "obscuredFunctionDeclaration": "La declaración de función \"{name}\" queda oculta por una declaración del mismo nombre",
        "obscuredMethodDeclaration": "La declaración de método \"{name}\" queda oculta por una declaración del mismo nombre",
        "obscuredParameterDeclaration": "La declaración de parámetro \"{name}\" queda oculta por una declaración del mismo nombre",
        "obscuredTypeAliasDeclaration": "La declaración de alias de tipo \"{name}\" queda oculta por una declaración del mismo nombre",
        "obscuredVariableDeclaration": "La declaración \"{name}\" está oculta por una declaración del mismo nombre",
        "operatorLessOrGreaterDeprecated": "El operador \"<>\" no es admitido en Python 3; utilice en su lugar \"!=\".",
        "optionalExtraArgs": "Se esperaba un argumento de tipo después de \"Optional\"",
        "orPatternIrrefutable": "El patrón irrefutable solo se permite como el último subpatrón en un patrón \"or\".",
        "orPatternMissingName": "Todos los subpatrones de un patrón \"or\" deben tener los mismos nombres",
        "overlappingKeywordArgs": "El diccionario escrito se superpone con el parámetro de palabra clave: {names}",
        "overlappingOverload": "La sobrecarga {obscured} para \"{name}\" nunca se utilizará porque sus parámetros se superpone con la sobrecarga {obscuredBy}.",
        "overloadAbstractImplMismatch": "Las sobrecargas deben coincidir con el estado abstracto de la implementación",
        "overloadAbstractMismatch": "Todos los métodos sobrecargados deben ser abstractos o no",
        "overloadClassMethodInconsistent": "Las sobrecargas de \"{name}\" usan @classmethod de forma incoherente",
        "overloadFinalInconsistencyImpl": "La sobrecarga de \"{name}\" está marcada @final pero la implementación no",
        "overloadFinalInconsistencyNoImpl": "La sobrecarga {index} para \"{name}\" está marcada @final pero la sobrecarga 1 no lo está.",
        "overloadImplementationMismatch": "La implementación de la sobrecarga no es consistente con la firma de la sobrecarga {index}",
        "overloadReturnTypeMismatch": "La sobrecarga {prevIndex} para \" {name}\" se superpone con la sobrecarga {newIndex} y devuelve un tipo incompatible",
        "overloadStaticMethodInconsistent": "Las sobrecargas de \"{name}\" usan @staticmethod de forma incoherente",
        "overloadWithoutImplementation": "\"{name}\" está marcado como overload, pero no se proporciona ninguna implementación.",
        "overriddenMethodNotFound": "El método \"{name}\" está marcado como override, pero no existe ningún método base con el mismo nombre",
        "overrideDecoratorMissing": "El método \"{name}\" no está marcado como override, pero está reemplazando un método de la clase \"{className}\"",
        "paramAfterKwargsParam": "El parámetro no puede seguir el parámetro \"**\"",
        "paramAlreadyAssigned": "El parámetro \"{name}\" ya está asignado",
        "paramAnnotationMissing": "Falta la anotación de tipo para el parámetro \"{name}\"",
        "paramAssignmentMismatch": "La expresión de tipo \"{sourceType}\" no se puede asignar al parámetro de tipo \"{paramType}\"",
        "paramNameMissing": "Ningún parámetro llamado \"{name}\"",
        "paramSpecArgsKwargsUsage": "Los atributos \"args\" y \"kwargs\" de ParamSpec deben aparecer ambos dentro de una firma de función",
        "paramSpecArgsMissing": "Faltan argumentos para ParamSpec \"{type}\".",
        "paramSpecArgsUsage": "El atributo \"args\" de ParamSpec solo es válido cuando se usa con el parámetro *args.",
        "paramSpecAssignedName": "ParamSpec debe asignarse a una variable llamada \"{name} \"",
        "paramSpecContext": "ParamSpec no está permitido en este contexto",
        "paramSpecDefaultNotTuple": "Se esperaban puntos suspensivos, una expresión de tuple o ParamSpec para el valor predeterminado de ParamSpec",
        "paramSpecFirstArg": "Se esperaba el nombre de ParamSpec como primer argumento",
        "paramSpecKwargsUsage": "El miembro \"kwargs\" de ParamSpec solo es válido cuando se utiliza con el parámetro **kwargs",
        "paramSpecNotUsedByOuterScope": "ParamSpec \"{name}\" no tiene significado en este contexto",
        "paramSpecUnknownArg": "ParamSpec no admite más de un argumento",
        "paramSpecUnknownMember": "\"{name}\" no es un atributo conocido de ParamSpec",
        "paramSpecUnknownParam": "\"{name}\" es un parámetro desconocido para ParamSpec",
        "paramTypeCovariant": "La variable de tipo covariante no puede utilizarse en el tipo de parámetro",
        "paramTypePartiallyUnknown": "El tipo de parámetro \"{paramName}\" es parcialmente desconocido",
        "paramTypeUnknown": "Se desconoce el tipo del parámetro \"{paramName}\".",
        "parenthesizedContextManagerIllegal": "Parentheses within \"with\" statement requires Python 3.9 or newer",
        "patternNeverMatches": "El patrón nunca coincidirá para el tipo de asunto \"{type}\"",
        "positionArgAfterNamedArg": "El argumento posicional no puede aparecer después de los argumentos de palabra clave",
        "positionOnlyAfterArgs": "No se permite el separador de parámetros de un solo puesto después del parámetro \"*\".",
        "positionOnlyAfterKeywordOnly": "El parámetro \"/\" debe aparecer antes del parámetro \"*\".",
        "positionOnlyAfterNon": "Parámetro de un solo puesto no permitido después del parámetro que no es de solo posición",
        "positionOnlyFirstParam": "Separador parámetros de solo un puesto no permitido como primer parámetro",
        "positionOnlyIncompatible": "El separador de parámetros de un solo puesto requiere Python 3.8 o posterior",
        "privateImportFromPyTypedModule": "\"{name}\" no se exporta desde el módulo \"{module}\"",
        "privateUsedOutsideOfClass": "\"{name}\" es privado y se utiliza fuera de la clase en la que se declara",
        "privateUsedOutsideOfModule": "\"{name}\" es privado y se utiliza fuera del módulo en el que se declara",
        "propertyOverridden": "\"{name}\" invalida incorrectamente la property del mismo nombre en la clase \"{className}\"",
        "propertyStaticMethod": "Métodos estáticos no permitidos para los valores de property getter, setter o deleter",
        "protectedUsedOutsideOfClass": "\"{name}\" está protegido y se usa fuera de la clase en la que se declara",
        "protocolBaseClass": "La clase de Protocol \"{classType}\" no se puede derivar de la clase que no es Protocol \"{baseType}\"",
        "protocolBaseClassWithTypeArgs": "No se permiten argumentos de tipo con la clase Protocol cuando se usa la sintaxis de parámetro de tipo",
        "protocolIllegal": "El uso de \"Protocolo\" requiere Python 3.7 o posterior.",
        "protocolNotAllowed": "\"Protocolo\" no puede utilizarse en este contexto",
        "protocolTypeArgMustBeTypeParam": "El argumento de tipo para \"Protocol\" debe ser un parámetro de tipo",
        "protocolUnsafeOverlap": "La clase se superpone \"{name}\" de forma no segura y podría producir una coincidencia en tiempo de ejecución",
        "protocolVarianceContravariant": "La variable de tipo \"{variable}\" usada en Protocol genérico \"{class}\" debe ser contravariante",
        "protocolVarianceCovariant": "La variable de tipo \"{variable}\" usada en Protocol genérico \"{class}\" debe ser covariante",
        "protocolVarianceInvariant": "La variable de tipo \"{variable}\" usada en Protocol genérico \"{class}\" debe ser invariable",
        "pyrightCommentInvalidDiagnosticBoolValue": "La directiva de comentario Pyright debe ir seguida de \"=\" y un valor de true o false",
        "pyrightCommentInvalidDiagnosticSeverityValue": "La directiva de comentario Pyright debe ir seguida de \"=\" y un valor de true, false, error, warning, information o none.",
        "pyrightCommentMissingDirective": "El comentario de Pyright debe ir seguido de una directiva (basic o estricta) o de una regla de diagnóstico",
        "pyrightCommentNotOnOwnLine": "Los comentarios de Pyright utilizados para controlar los ajustes a nivel de archivo deben aparecer en su propia línea",
        "pyrightCommentUnknownDiagnosticRule": "\"{rule}\" es una regla de diagnóstico desconocida para el comentario pyright",
        "pyrightCommentUnknownDiagnosticSeverityValue": "\"{value}\" es un valor no válido para el comentario pyright; se espera true, false, error, warning, information o none.",
        "pyrightCommentUnknownDirective": "\"{directive}\" es una directiva desconocida para el comentario pyright; se esperaba \"strict\" o \"basic\".",
        "readOnlyArgCount": "Se esperaba un único argumento de tipo después de \"ReadOnly\"",
        "readOnlyNotInTypedDict": "\"ReadOnly\" no está permitido en este contexto",
        "recursiveDefinition": "No se pudo determinar el tipo de \"{name}\" porque hace referencia a sí mismo.",
        "relativeImportNotAllowed": "Las importaciones relativas no pueden utilizarse con la forma \"import .a\"; utilice en su lugar \"from . import a\"",
        "requiredArgCount": "Se esperaba un único argumento de tipo después de \"Required\"",
        "requiredNotInTypedDict": "\"Required\" no está permitido en este contexto",
        "returnInAsyncGenerator": "No se permite la instrucción Return con valor en el generador async",
        "returnMissing": "La función con el tipo de valor devuelto declarado \"{returnType}\" debe devolver un valor en todas las rutas de acceso del código.",
        "returnOutsideFunction": "\"return\" solo se puede usar dentro de una función",
        "returnTypeContravariant": "La variable de tipo contravariante no se puede usar en el tipo de valor devuelto",
        "returnTypeMismatch": "El tipo \"{exprType}\" no se puede asignar al tipo de valor devuelto \"{returnType}\"",
        "returnTypePartiallyUnknown": "El tipo de retorno, \"{returnType}\", es parcialmente desconocido",
        "returnTypeUnknown": "Tipo de retorno desconocido",
        "revealLocalsArgs": "No se esperaba ningún argumento para la llamada \"reveal_locals\"",
        "revealLocalsNone": "No hay locals en este ámbito",
        "revealTypeArgs": "Se esperaba un único argumento posicional para la llamada \"reveal_type\"",
        "revealTypeExpectedTextArg": "El argumento \"expected_text\" de la función \"reveal_type\" debe ser un valor literal str.",
        "revealTypeExpectedTextMismatch": "El tipo de texto no coincide; se esperaba \"{expected}\" pero se ha recibido \"{received}\".",
        "revealTypeExpectedTypeMismatch": "Error de coincidencia de tipos; se esperaba \"{expected}\", pero se recibió \"{received}\"",
        "selfTypeContext": "\"Self\" no es válido en este contexto",
        "selfTypeMetaclass": "\"Self\" no se puede usar dentro de una metaclase (una subclase de \"type\")",
        "selfTypeWithTypedSelfOrCls": "\"Self\" no puede utilizarse en una función con un parámetro `self` o `cls` que tenga una anotación de tipo distinta de \"Self\".",
        "setterGetterTypeMismatch": "El tipo de valor setter de Property no se puede asignar al tipo devuelto por el valor getter",
        "singleOverload": "\"{name}\" está marcado como sobrecarga, pero faltan sobrecargas adicionales",
        "slotsAttributeError": "\"{name}\" no se especificó en __slots__",
        "slotsClassVarConflict": "\"{name}\" entra en conflicto con la variable de instancia declarada en __slots__",
        "starPatternInAsPattern": "El patrón estrella no puede utilizarse con el objetivo \"as\"",
        "starPatternInOrPattern": "El patrón de estrella no puede unirse a otros patrones",
        "starStarWildcardNotAllowed": "** no puede utilizarse con el comodín \"_\".",
        "staticClsSelfParam": "Los métodos estáticos no deben tomar un parámetro \"self\" o \"cls\".",
        "stdlibModuleOverridden": "\"{path}\" está reemplazando el módulo stdlib \"{name}\"",
        "stringNonAsciiBytes": "Carácter no ASCII no permitido en el literal de cadena de bytes",
        "stringNotSubscriptable": "La expresión de cadena no puede ir entre comillas en la expresión de tipo; encierre toda la expresión entre comillas.",
        "stringUnsupportedEscape": "Secuencia de escape no admitida en el literal de cadena",
        "stringUnterminated": "La cadena literal no está terminada",
        "stubFileMissing": "Archivo Stub no encontrado para \"{importName}\"",
        "stubUsesGetAttr": "El archivo stub de tipo está incompleto; \"__getattr__\" oculta errores de tipo para el módulo",
        "sublistParamsIncompatible": "Los parámetros de sublista no están soportados en Python 3.x",
        "superCallArgCount": "No se esperaban más de dos argumentos para la llamada \"super\"",
        "superCallFirstArg": "Se esperaba el tipo de clase como primer argumento de la llamada a \"super\" pero se recibió \"{type}\"",
        "superCallSecondArg": "El segundo argumento de la llamada a \"super\" debe ser un objeto o clase que derive de \"{type}\"",
        "superCallZeroArgForm": "La forma sin argumentos de la llamada \"super\" sólo es válida dentro de un método",
        "superCallZeroArgFormStaticMethod": "La forma sin argumentos de la llamada \"super\" no es válida en un método estático",
        "symbolIsPossiblyUnbound": "\"{name}\" está posiblemente desvinculado",
        "symbolIsUnbound": "\"{name}\" está sin consolidar",
        "symbolIsUndefined": "\"{name}\" no está definido",
        "symbolOverridden": "\"{name}\" anula el símbolo del mismo nombre en la clase \"{className}\"",
        "ternaryNotAllowed": "No se permite la expresión de ternario en la expresión de tipo",
        "totalOrderingMissingMethod": "La clase debe definir uno de \"__lt__\", \"__le__\", \"__gt__\", o \"__ge__\" para utilizar total_ordering",
        "trailingCommaInFromImport": "No se permite la coma final sin paréntesis alrededor",
        "tryWithoutExcept": "La instrucción Try debe tener al menos una cláusula except o finally",
        "tupleAssignmentMismatch": "La expresión con el tipo \"{type}\" no se puede asignar a la tuple de destino",
        "tupleInAnnotation": "No se permite la expresión de tuple en la expresión de tipo",
        "tupleIndexOutOfRange": "El índice {index} está fuera de rango para el tipo {type}.",
        "typeAliasIllegalExpressionForm": "Forma de expresión no válida para la definición de alias de tipo",
        "typeAliasIsRecursiveDirect": "El alias de tipo \"{name}\" no puede usarse a sí mismo en su definición",
        "typeAliasNotInModuleOrClass": "Un TypeAlias solo puede definirse en el ámbito de un módulo o de una clase",
        "typeAliasRedeclared": "\"{name}\" se declara como TypeAlias y solo puede asignarse una vez",
        "typeAliasStatementBadScope": "Una instrucción de type solo se puede usar en el ámbito de un módulo o de una clase",
        "typeAliasStatementIllegal": "La sentencia Type alias requiere Python 3.12 o posterior",
        "typeAliasTypeBaseClass": "Un alias de tipo definido en una instrucción \"type\" no se puede usar como clase base",
        "typeAliasTypeMustBeAssigned": "TypeAliasType debe asignarse a una variable con el mismo nombre que el alias de tipo",
        "typeAliasTypeNameArg": "El primer argumento de TypeAliasType debe ser un literal de cadena que represente el nombre del alias de tipo",
        "typeAliasTypeNameMismatch": "El nombre del alias de tipo debe coincidir con el nombre de la variable a la que se asigna",
        "typeAliasTypeParamInvalid": "La lista de parámetros de tipo debe ser una tuple que contenga solo TypeVar, TypeVarTuple o ParamSpec.",
        "typeAnnotationCall": "No se permite la expresión de llamada en la expresión de tipo",
        "typeAnnotationVariable": "Variable no permitida en la expresión de tipo",
        "typeAnnotationWithCallable": "El argumento de tipo para \"type\" debe ser una clase; no se admiten invocables",
        "typeArgListExpected": "ParamSpec esperado, elipsis o lista de tipos",
        "typeArgListNotAllowed": "Expresión de lista no permitida para este argumento de tipo",
        "typeArgsExpectingNone": "No se esperaban argumentos de tipo para la clase \"{name}\"",
        "typeArgsMismatchOne": "Se esperaba un argumento de tipo pero ha recibido {received}",
        "typeArgsMissingForAlias": "Argumentos de tipo esperados para el alias de tipo genérico \"{name}\"",
        "typeArgsMissingForClass": "Se esperaban argumentos de tipo para la clase genérica \"{name}\"",
        "typeArgsTooFew": "Se han proporcionado muy pocos argumentos de tipo para \"{name}\"; se esperaba {expected} pero se ha recibido {received}.",
        "typeArgsTooMany": "Se proporcionaron demasiados argumentos de tipo para \"{name}\"; se esperaba {expected}, pero se recibieron {received}",
        "typeAssignmentMismatch": "El tipo \"{sourceType}\" no se puede asignar al tipo declarado \"{destType}\"",
        "typeAssignmentMismatchWildcard": "El símbolo de importación \"{name}\" tiene el tipo \"{sourceType}\", que no se puede asignar al tipo declarado \"{destType}\"",
        "typeCallNotAllowed": "La llamada a type() no debe utilizarse en la expresión de tipo",
        "typeCheckOnly": "\"{name}\" está marcado como @type_check_only y solo se puede usar en anotaciones de tipo",
        "typeCommentDeprecated": "El uso de comentarios de type está obsoleto; utilice en su lugar anotaciones de type.",
        "typeExpectedClass": "Se esperaba la clase pero se recibió \"{type}\"",
        "typeFormArgs": "\"TypeForm\" acepta un único argumento posicional",
        "typeGuardArgCount": "Se esperaba un único argumento de tipo después de \"TypeGuard\" o \"TypeIs\"",
        "typeGuardParamCount": "Las funciones y métodos de protección de tipo definidos por el usuario deben tener al menos un parámetro de entrada",
        "typeIsReturnType": "El tipo de valor devuelto de TypeIs (\"{returnType}\") no es coherente con el tipo de parámetro de valor (\"{type}\")",
        "typeNotAwaitable": "\"{type}\" no se awaitable",
        "typeNotIntantiable": "\"{type}\" no puede crear instancias",
        "typeNotIterable": "\"{type}\" no es iterable",
        "typeNotSpecializable": "No se pudo especializar el tipo \"{type}\"",
        "typeNotSubscriptable": "Objeto de tipo \"{type}\" no es subscriptible",
        "typeNotSupportBinaryOperator": "El operador \"{operator}\" no se admite para los tipos \"{leftType}\" y \"{rightType}\"",
        "typeNotSupportBinaryOperatorBidirectional": "No se admite el operador \"{operator}\" para los tipos \"{leftType}\" y \"{rightType}\" cuando el tipo esperado es \"{expectedType}\"",
        "typeNotSupportUnaryOperator": "El operador \"{operator}\" no se admite para el tipo \"{type}\"",
        "typeNotSupportUnaryOperatorBidirectional": "Operador \"{operator}\" no admitido para el tipo \"{type}\" cuando el tipo esperado es \"{expectedType}\"",
        "typeNotUsableWith": "El objeto de tipo \"{type}\" no puede utilizarse con \"con\" porque no implementa {method}.",
        "typeParameterBoundNotAllowed": "No se pueden usar límites o restricciones con un parámetro de tipo variádico o ParamSpec",
        "typeParameterConstraintTuple": "La restricción del parámetro de tipo debe ser una tupla de dos o más tipos",
        "typeParameterExistingTypeParameter": "El parámetro de tipo \"{name}\" ya está en uso",
        "typeParameterNotDeclared": "El parámetro de tipo \"{name}\" no está incluido en la lista de parámetros de tipo para \"{container}\"",
        "typeParametersMissing": "Debe especificarse al menos un parámetro de tipo",
        "typePartiallyUnknown": "El tipo de \"{name}\" es parcialmente desconocido",
        "typeUnknown": "El tipo de \"{name} \" es desconocido",
        "typeVarAssignedName": "TypeVar debe asignarse a una variable llamada \"{name}\"",
        "typeVarAssignmentMismatch": "No se puede asignar el tipo \"{type}\" a la variable de tipo \"{name}\"",
        "typeVarBoundAndConstrained": "TypeVar no puede estar ligado y restringido a la vez",
        "typeVarBoundGeneric": "El tipo vinculado TypeVar no puede ser genérico",
        "typeVarConstraintGeneric": "El tipo de restricción TypeVar no puede ser genérico",
        "typeVarDefaultBoundMismatch": "El tipo predeterminado TypeVar debe ser un subtipo del tipo enlazado.",
        "typeVarDefaultConstraintMismatch": "El tipo predeterminado TypeVar debe ser uno de los tipos restringidos.",
        "typeVarDefaultIllegal": "Los tipos predeterminados de variable de tipo requieren Python 3.13 o posterior",
        "typeVarDefaultInvalidTypeVar": "El parámetro de tipo \"{name}\" tiene un tipo por defecto que hace referencia a una o más variables de tipo que están fuera de ámbito.",
        "typeVarFirstArg": "Nombre esperado de TypeVar como primer argumento",
        "typeVarInvalidForMemberVariable": "El tipo de atributo no puede usar una variable de tipo \"{name}\" con ámbito de método local",
        "typeVarNoMember": "TypeVar \"{type}\" no tiene ningún atributo \"{name}\"",
        "typeVarNotSubscriptable": "TypeVar \"{type}\" no es subscribible",
        "typeVarNotUsedByOuterScope": "La variable de tipo \"{name}\" no tiene ningún significado en este contexto",
        "typeVarPossiblyUnsolvable": "La variable de tipo \"{name}\" puede quedar sin resolver si el autor de la llamada no proporciona ningún argumento para el parámetro \"{param}\"",
        "typeVarSingleConstraint": "TypeVar debe tener al menos dos tipos restringidos",
        "typeVarTupleConstraints": "TypeVarTuple no puede tener restricciones de valor",
        "typeVarTupleContext": "TypeVarTuple no está permitido en este contexto",
        "typeVarTupleDefaultNotUnpacked": "El tipo predeterminado TypeVarTuple debe ser una tuple desempaquetada o TypeVarTuple",
        "typeVarTupleMustBeUnpacked": "Se requiere el operador Unpack para el valor TypeVarTuple.",
        "typeVarTupleUnknownParam": "\"{name}\" es un parámetro desconocido para TypeVarTuple",
        "typeVarUnknownParam": "\"{name}\" es un parámetro desconocido para TypeVar",
        "typeVarUsedByOuterScope": "TypeVar \"{name}\" ya está en uso por un ámbito externo",
        "typeVarUsedOnlyOnce": "TypeVar \"{name}\" solo aparece una vez en la firma de la función genérica",
        "typeVarVariance": "TypeVar no puede ser covariante y contravariante",
        "typeVarWithDefaultFollowsVariadic": "TypeVar \"{typeVarName}\" tiene un valor predeterminado y no puede seguir a TypeVarTuple \"{variadicName}\"",
        "typeVarWithoutDefault": "\"{name}\" no puede aparecer después de \"{other}\" en la lista de parámetros de tipo porque no tiene ningún tipo predeterminado",
        "typeVarsNotInGenericOrProtocol": "Generic[] o Protocol[] deben incluir todas las variables de tipo",
        "typedDictAccess": "No se ha podido acceder al elemento en TypedDict",
        "typedDictAssignedName": "TypedDict debe asignarse a una variable denominada \"{name}\"",
        "typedDictBadVar": "Las clases TypedDict solo pueden contener anotaciones de tipo",
        "typedDictBaseClass": "Todas las clases base de las clases TypedDict deben ser también clases TypedDict",
        "typedDictBoolParam": "Se esperaba que el parámetro \"{name}\" tuviera un valor de True o False.",
        "typedDictClosedExtras": "La clase base \"{name}\" es un TypedDict closed; los elementos adicionales deben ser de tipo \"{type}\"",
        "typedDictClosedNoExtras": "La clase base \"{name}\" es un TypedDict closed; no se permiten elementos adicionales",
        "typedDictDelete": "No se puede eliminar un elemento en TypedDict",
        "typedDictEmptyName": "Los nombres de un TypedDict no pueden estar vacíos",
        "typedDictEntryName": "Cadena literal esperada para el nombre de la entrada del diccionario",
        "typedDictEntryUnique": "Los nombres dentro de un diccionario deben ser únicos",
        "typedDictExtraArgs": "No se admiten argumentos TypedDict adicionales",
        "typedDictFieldNotRequiredRedefinition": "El elemento TypedDict \"{name}\" no se puede redefinir como NotRequired",
        "typedDictFieldReadOnlyRedefinition": "El elemento TypedDict \"{name}\" no se puede redefinir como ReadOnly",
        "typedDictFieldRequiredRedefinition": "El elemento TypedDict \"{name}\" no se puede redefinir como Required",
        "typedDictFirstArg": "Nombre de clase TypedDict esperado como primer argumento",
        "typedDictInitsubclassParameter": "TypedDict no admite __init_subclass__ parámetro \"{name}\"",
        "typedDictNotAllowed": "\"TypedDict\" no puede utilizarse en este contexto",
        "typedDictSecondArgDict": "Parámetro dict o palabra clave esperado como segundo parámetro",
        "typedDictSecondArgDictEntry": "Entrada de diccionario simple esperada",
        "typedDictSet": "No se pudo asignar el elemento en TypedDict",
        "unaccessedClass": "No se accede a la clase \"{name}\"",
        "unaccessedFunction": "No se accede a la función \"{name}",
        "unaccessedImport": "No se accede a la importación \"{name}",
        "unaccessedSymbol": "No se accede a \"{name}\"",
        "unaccessedVariable": "No se accede a la variable \"{name} \".",
        "unannotatedFunctionSkipped": "Se omite el análisis de la función \"{name}\" porque no está anotada",
        "unaryOperationNotAllowed": "Operador unario no permitido en la expresión de tipo",
        "unexpectedAsyncToken": "Se esperaba que \"def\", \"with\" o \"for\" siguieran a \"async\".",
        "unexpectedExprToken": "Token inesperado al final de la expresión",
        "unexpectedIndent": "sangSangría inesperadaría inesperada",
        "unexpectedUnindent": "No se espera sangría",
        "unhashableDictKey": "La clave del diccionario debe ser hash",
        "unhashableSetEntry": "La entrada del set debe ser hashable",
        "uninitializedAbstractVariables": "Las variables definidas en la clase base abstracta no se inicializan en la clase final \"{classType}\"",
        "uninitializedInstanceVariable": "La variable de instancia \"{name}\" no está inicializada en el cuerpo de la clase o en el método __init__.",
        "unionForwardReferenceNotAllowed": "Union syntax cannot be used with string operand; use quotes around entire expression",
        "unionSyntaxIllegal": "La sintaxis alternativa para las uniones requiere Python 3.10 o posterior.",
        "unionTypeArgCount": "Union requiere dos o más argumentos de tipo",
        "unionUnpackedTuple": "La Union no puede incluir una tuple desempaquetada",
        "unionUnpackedTypeVarTuple": "La Union no puede incluir un TypeVarTuple desempaquetado",
        "unnecessaryCast": "Llamada \"cast\" innecesaria; el tipo ya es \"{type}\"",
        "unnecessaryIsInstanceAlways": "Llamada isinstance innecesaria; \"{testType}\" es siempre una instancia de \"{classType}\"",
        "unnecessaryIsSubclassAlways": "Llamada de issubclass innecesaria; \"{testType}\" siempre es una subclase de \"{classType}\"",
        "unnecessaryPyrightIgnore": "Comentario \"# pyright: ignore\" innecesario",
        "unnecessaryPyrightIgnoreRule": "Regla innecesaria \"# pyright: ignore\": \"{name}\"",
        "unnecessaryTypeIgnore": "Comentario \"# type: ignore\" innecesario",
        "unpackArgCount": "Se esperaba un único argumento de tipo después de \"Unpack\"",
        "unpackExpectedTypeVarTuple": "Se esperaba TypeVarTuple o tuple como argumento de tipo para Unpack",
        "unpackExpectedTypedDict": "Se esperaba un argumento de tipo TypedDict para Unpack",
        "unpackIllegalInComprehension": "Operación de desempaquetado no permitida en la comprensión",
        "unpackInAnnotation": "No se permite el operador desempaquetado en la expresión de tipo",
        "unpackInDict": "Operación de desempaquetado no permitida en diccionarios",
        "unpackInSet": "No se permite el operador Unpack dentro de un set",
        "unpackNotAllowed": "Unpack no está permitido en este contexto",
        "unpackOperatorNotAllowed": "La operación de desempaquetado no está permitida en este contexto",
        "unpackTuplesIllegal": "Operación de desempaquetado no permitida en tuplas anteriores a Python 3.8",
        "unpackedArgInTypeArgument": "No se pueden usar argumentos sin empaquetar en este contexto",
        "unpackedArgWithVariadicParam": "No se puede usar un argumento desempaquetado para el parámetro TypeVarTuple",
        "unpackedDictArgumentNotMapping": "La expresión del argumento después de ** debe ser un mapeo con un tipo de clave \"str\".",
        "unpackedDictSubscriptIllegal": "El operador de desempaquetado del diccionario en el subíndice no está permitido",
        "unpackedSubscriptIllegal": "El operador de desempaquetado en el subíndice requiere Python 3.11 o posterior.",
        "unpackedTypeVarTupleExpected": "Se espera un TypeVarTuple desempaquetado; use Unpack[{name1}] o *{name2}",
        "unpackedTypedDictArgument": "No se puede emparejar el argumento TypedDict desempaquetado con los parámetros",
        "unreachableCode": "El código es inalcanzable",
        "unreachableCodeType": "El análisis de tipos indica que no se puede acceder al código",
        "unreachableExcept": "La cláusula Excepto es inalcanzable porque la excepción ya está administrada",
        "unsupportedDunderAllOperation": "No se admite la operación en \"__all__\", por lo que la lista de símbolos exportada puede ser incorrecta.",
        "unusedCallResult": "El resultado de la expresión de llamada es de tipo \"{type}\" y no se usa; asignar a la variable \"_\" si esto es intencionado",
        "unusedCoroutine": "El resultado de la llamada a una función async no se utiliza; utilice \"await\" o asigne el resultado a una variable.",
        "unusedExpression": "El valor de expresión no se usa",
        "varAnnotationIllegal": "Las anotaciones de type para variables requieren Python 3.6 o posterior; utilice el comentario de tipo para la compatibilidad con versiones anteriores.",
        "variableFinalOverride": "La variable \"{name}\" está marcada como Final y anula la variable no Final del mismo nombre en la clase \"{className}\".",
        "variadicTypeArgsTooMany": "La lista de argumentos de tipo puede tener como máximo una TypeVarTuple o tuple desempaquetada",
        "variadicTypeParamTooManyAlias": "Los alias de tipo pueden tener como máximo un parámetro de tipo TypeVarTuple, pero reciben varios ({names})",
        "variadicTypeParamTooManyClass": "La clase genérica puede tener como máximo un parámetro de tipo TypeVarTuple pero recibió múltiples ({names})",
        "walrusIllegal": "El operador \":=\" requiere Python 3.8 o posterior",
        "walrusNotAllowed": "El operador \":=\" no está permitido en este contexto sin paréntesis alrededor",
        "wildcardInFunction": "No se permite la importación de comodines dentro de una clase o función",
        "wildcardLibraryImport": "No se permite la importación de caracteres comodín desde una biblioteca",
        "wildcardPatternTypePartiallyUnknown": "El tipo capturado por el patrón comodín es parcialmente desconocido",
        "wildcardPatternTypeUnknown": "Se desconoce el tipo capturado por el patrón de caracteres comodín",
        "yieldFromIllegal": "El uso de \"yield from\" requiere Python 3.3 o posterior.",
        "yieldFromOutsideAsync": "\"yield from\" no permitido en una función async",
        "yieldOutsideFunction": "\"yield\" no se permite fuera de una función o lambda",
        "yieldWithinComprehension": "\"yield\" no está permitido dentro de una comprensión de lista",
        "zeroCaseStatementsFound": "La instrucción Match debe incluir al menos una instrucción case",
        "zeroLengthTupleNotAllowed": "La tuple de longitud cero no está permitida en este contexto"
    },
    "DiagnosticAddendum": {
        "annotatedNotAllowed": "El formulario especial \"Annotated\" no se puede usar con comprobaciones de instancia y clase",
        "argParam": "El argumento corresponde al parámetro \"{paramName}\"",
        "argParamFunction": "El argumento corresponde al parámetro \"{paramName}\" en la función \"{functionName}\"",
        "argsParamMissing": "El parámetro \"*{paramName}\" no tiene ningún parámetro correspondiente",
        "argsPositionOnly": "Error de coincidencia del parámetro de solo posición; se esperaba {expected}, pero se recibieron {received}",
        "argumentType": "El tipo de argumento es \"{type}\"",
        "argumentTypes": "Tipos de argumento: ({types})",
        "assignToNone": "El tipo no se puede asignar a \"None\"",
        "asyncHelp": "¿Quería decir \"async with\"?",
        "baseClassIncompatible": "La clase base \"{baseClass}\" no es compatible con el tipo \"{type}\"",
        "baseClassIncompatibleSubclass": "La clase base \"{baseClass}\" deriva de \"{subclass}\", que no es compatible con el tipo \"{type}\"",
        "baseClassOverriddenType": "La clase base \"{baseClass}\" proporciona el tipo \"{type}\", que se sobrescribe",
        "baseClassOverridesType": "Invalidaciones de clase base \"{baseClass}\" con el tipo \"{type}\"",
        "bytesTypePromotions": "Establezca disableBytesTypePromotions en false para activar el comportamiento de promoción de tipos para \"bytearray\" y \"memoryview\".",
        "conditionalRequiresBool": "El método __bool__ para el tipo \"{operandType}\" devuelve el tipo \"{boolReturnType}\" en lugar de \"bool\"",
        "dataClassFieldLocation": "en declaración de campo",
        "dataClassFrozen": "\"{name}\" está congelado",
        "dataProtocolUnsupported": "\"{name}\" es un protocolo de datos",
        "descriptorAccessBindingFailed": "No se pudo enlazar el método \"{name}\" para la clase de descriptor \"{className}\"",
        "descriptorAccessCallFailed": "No se pudo llamar al método \"{name}\" para la clase de descriptor \"{className}\"",
        "finalMethod": "Final method",
        "functionParamDefaultMissing": "Falta el argumento predeterminado en el parámetro \"{name}\"",
        "functionParamName": "Nombre de parámetro no coincidente: \"{destName}\" frente a \"{srcName}\"",
        "functionParamPositionOnly": "Error de coincidencia del parámetro de solo posición; el parámetro \"{name}\" no es de solo posición",
        "functionReturnTypeMismatch": "El tipo de valor devuelto de la función \"{sourceType}\" no es compatible con el tipo \"{destType}\"",
        "functionTooFewParams": "La función acepta muy pocos parámetros posicionales; esperado {expected} pero recibido {received}",
        "functionTooManyParams": "La función acepta demasiados parámetros posicionales; esperado {expected} pero recibido {received}",
        "genericClassNotAllowed": "Tipo genérico con argumentos de tipo no permitidos para comprobaciones de instancia o clase",
        "incompatibleDeleter": "El método de deleter de property no es compatible",
        "incompatibleGetter": "El método getter de property no es compatible",
        "incompatibleSetter": "El método setter de la property no es compatible",
        "initMethodLocation": "El método __init__ se define en la clase \"{type}\"",
        "initMethodSignature": "La firma de __init__ es \"{type}\"",
        "initSubclassLocation": "El método __init_subclass__ se define en la clase \"{name}\"",
        "invariantSuggestionDict": "Considere cambiar de \"dict\" a \" Mapping\" que es covariante en el tipo de valor",
        "invariantSuggestionList": "Considere la posibilidad de cambiar de \"lista\" a \"Sequence\" que es covariante",
        "invariantSuggestionSet": "Considere la posibilidad de cambiar de \"set\" a \"Container\" que es covariante",
        "isinstanceClassNotSupported": "\"{type}\" no se admite para las comprobaciones de instancia y clase",
        "keyNotRequired": "\"{name}\" no es una clave necesaria en \"{type}\", por lo que el acceso puede dar lugar a una excepción en tiempo de ejecución",
        "keyReadOnly": "\"{name}\" es una clave de solo lectura en \"{type}\"",
        "keyRequiredDeleted": "\"{name}\" es una clave necesaria y no se puede eliminar",
        "keyUndefined": "\"{name}\" no es una clave definida en \"{type}\"",
        "kwargsParamMissing": "El parámetro \"**{paramName}\" no tiene ningún parámetro correspondiente.",
        "listAssignmentMismatch": "El tipo \"{type}\" es incompatible con la lista de objetivos",
        "literalAssignmentMismatch": "\"{sourceType}\" no se puede asignar al tipo \"{destType}\"",
        "matchIsNotExhaustiveHint": "Si no se pretende un tratamiento exhaustivo, agregue \"case _: pass\"",
        "matchIsNotExhaustiveType": "Tipo no manejado: \"{type}\"",
        "memberAssignment": "La expresión de tipo \"{type}\" no se puede asignar al atributo \"{name}\" de la clase \"{classType}\"",
        "memberIsAbstract": "\"{type}. {name}\" no está implementado",
        "memberIsAbstractMore": "y {count} más...",
        "memberIsClassVarInProtocol": "\"{name}\" se define como ClassVar en el protocolo",
        "memberIsInitVar": "\"{name}\" es un campo init-only",
        "memberIsInvariant": "\"{name}\" es invariable porque es mutable",
        "memberIsNotClassVarInClass": "\"{name}\" debe definirse como ClassVar para que sea compatible con el protocolo",
        "memberIsNotClassVarInProtocol": "\"{name}\" no está definido como ClassVar en el protocolo",
        "memberIsNotReadOnlyInProtocol": "\"{name}\" no es de solo lectura en el protocolo",
        "memberIsReadOnlyInProtocol": "\"{name}\" es de solo lectura en el protocolo",
        "memberIsWritableInProtocol": "\"{name}\" se puede escribir en el protocolo",
        "memberSetClassVar": "El atributo \"{name}\" no se puede asignar a través de una instancia de clase porque es un ClassVar.",
        "memberTypeMismatch": "\"{name}\" es un tipo incompatible",
        "memberUnknown": "Atributo \"{name}\" desconocido",
        "metaclassConflict": "La metaclase \"{metaclass1}\" entra en conflicto con \"{metaclass2}\"",
        "missingDeleter": "Falta el método de deleter de property",
        "missingGetter": "Falta el método getter de la property",
        "missingSetter": "Falta el método setter de property",
        "namedParamMissingInDest": "Parámetro adicional \"{name}\"",
        "namedParamMissingInSource": "Falta el parámetro de palabra clave \"{name}\"",
        "namedParamTypeMismatch": "El parámetro de palabra clave \"{name}\" de tipo \"{sourceType}\" no es compatible con el tipo \"{destType}\"",
        "namedTupleNotAllowed": "No se puede usar NamedTuple para comprobaciones de instancia o clase",
        "newMethodLocation": "El método __new__ está definido en la clase \"{type}\"",
        "newMethodSignature": "La firma de __new__ es \"{type}\"",
        "newTypeClassNotAllowed": "La clase creada con NewType no se puede usar con comprobaciones de instancia y clase",
        "noOverloadAssignable": "Ninguna función sobrecargada coincide con el tipo \"{type}\"",
        "noneNotAllowed": "No se puede usar None para comprobaciones de instancia o clase",
        "orPatternMissingName": "Nombres que faltan: {name}",
        "overloadIndex": "La sobrecarga {index} es la coincidencia más cercana",
        "overloadNotAssignable": "Una o más sobrecargas de \"{name}\" no es asignable",
        "overloadSignature": "Aquí se define la firma de la sobrecarga",
        "overriddenMethod": "Método reemplazado",
        "overriddenSymbol": "Símbolo anulado",
        "overrideInvariantMismatch": "El tipo de invalidación “{overrideType}” no es el mismo que el tipo básico “{baseType}”",
        "overrideIsInvariant": "La variable es mutable, por lo que su tipo es invariable",
        "overrideNoOverloadMatches": "Ninguna firma de sobrecarga en anulación es compatible con el método base",
        "overrideNotClassMethod": "El método base se declara como classmethod pero el Reemplazar no",
        "overrideNotInstanceMethod": "El método base se declara como método de instancia, pero la invalidación no",
        "overrideNotStaticMethod": "El método base se declara como staticmethod pero el reemplazo no",
        "overrideOverloadNoMatch": "La invalidación no controla todas las sobrecargas del método base",
        "overrideOverloadOrder": "Las sobrecargas para el método de anulación deben estar en el mismo orden que el método base",
        "overrideParamKeywordNoDefault": "El parámetro de palabra clave \"{name}\" no coincide: el parámetro base tiene el valor de argumento predeterminado, el parámetro de invalidación no",
        "overrideParamKeywordType": "El parámetro de palabra clave \"{name}\" no coincide: el parámetro base es de tipo \"{baseType}\", el parámetro de invalidación es de tipo \"{overrideType}\"",
        "overrideParamName": "El nombre del parámetro {index} no coincide: el parámetro base se denomina \"{baseName}\", el parámetro de invalidación se denomina \"{overrideName}\"",
        "overrideParamNameExtra": "Falta el parámetro \"{name}\" en la base",
        "overrideParamNameMissing": "Falta el parámetro \"{name}\" en la invalidación",
        "overrideParamNamePositionOnly": "El parámetro {index} no coincide: el parámetro base \"{baseName}\" es un parámetro de palabra clave, el parámetro de invalidación es de solo posición",
        "overrideParamNoDefault": "El parámetro {index} no coincide: el parámetro base tiene un valor de argumento predeterminado, el parámetro de invalidación no",
        "overrideParamType": "El parámetro {index} no coincide: el parámetro base es de tipo \"{baseType}\", el parámetro de invalidación es de tipo \"{overrideType}\"",
        "overridePositionalParamCount": "El recuento de parámetros posicionales no coincide; el método base tiene {baseCount}, pero la invalidación tiene {overrideCount}",
        "overrideReturnType": "Error de tipo de retorno: el método base devuelve el tipo \"{baseType}\", el reemplazo devuelve el tipo \"{overrideType}\".",
        "overrideType": "La clase base define el tipo como \"{type}\"",
        "paramAssignment": "El parámetro {index}: el tipo \"{sourceType}\" no es compatible con el tipo \"{destType}\"",
        "paramSpecMissingInOverride": "Faltan parámetros ParamSpec en el método de invalidación",
        "paramType": "El tipo de parámetro es \"{paramType}\"",
        "privateImportFromPyTypedSource": "Importar desde \"{module}\" en su lugar",
        "propertyAccessFromProtocolClass": "No se puede tener acceso a una propiedad definida dentro de una clase de protocolo como variable de clase",
        "propertyMethodIncompatible": "El método de property \"{name}\" no es compatible",
        "propertyMethodMissing": "Falta el método de property \"{name}\" en la invalidación",
        "propertyMissingDeleter": "Property \"{name}\" no tiene un supresor deleter",
        "propertyMissingSetter": "Property \"{name}\" no tiene el valor setter definido",
        "protocolIncompatible": "\"{sourceType}\" no es compatible con el protocolo \"{destType}\"",
        "protocolMemberMissing": "\"{name}\" no está presente.",
        "protocolRequiresRuntimeCheckable": "La clase de Protocol debe ser @runtime_checkable para usarse con comprobaciones de instancia y clase",
        "protocolSourceIsNotConcrete": "\"{sourceType}\" no es un tipo de clase concreto y no se puede asignar al tipo \"{destType}\"",
        "protocolUnsafeOverlap": "Los atributos de \"{name}\" tienen los mismos nombres que el protocolo",
        "pyrightCommentIgnoreTip": "Utilice \"# pyright: ignore[<diagnostic rules>]\" para suprimir el diagnóstico de una sola línea",
        "readOnlyAttribute": "El atributo \"{name}\" es de solo lectura",
        "seeClassDeclaration": "Ver declaración de clase",
        "seeDeclaration": "Ver declaración",
        "seeFunctionDeclaration": "Ver declaración de función",
        "seeMethodDeclaration": "Consulte la declaración del métodoa",
        "seeParameterDeclaration": "Declaración de parámetro",
        "seeTypeAliasDeclaration": "Véase la declaración de alias de tipo",
        "seeVariableDeclaration": "declaración de variable out",
        "tupleAssignmentMismatch": "El tipo \"{type}\" no es compatible con la tuple de destino",
        "tupleEntryTypeMismatch": "La entrada {entry} de la tuple es de tipo incorrecto",
        "tupleSizeIndeterminateSrc": "El tamaño de la tuple no coincide; se esperaba {expected} pero se recibió uno indeterminado",
        "tupleSizeIndeterminateSrcDest": "El tamaño de la tuple no coincide; se esperaba {expected} o más, pero se recibió uno indeterminado",
        "tupleSizeMismatch": "El tamaño de la tuple no coincide; se esperaba {expected} pero se recibió {received}",
        "tupleSizeMismatchIndeterminateDest": "El tamaño de la tuple no coincide; se esperaba {expected} o más, pero se recibió {received}",
        "typeAliasInstanceCheck": "El alias de tipo creado con la instrucción \"type\" no se puede usar con comprobaciones de instancia y clase",
        "typeAssignmentMismatch": "El tipo \"{sourceType}\" no se puede asignar al tipo \"{destType}\"",
        "typeBound": "El tipo \"{sourceType}\" no se puede asignar al límite superior \"{destType}\" para la variable de tipo \"{name}\"",
        "typeConstrainedTypeVar": "El tipo \"{type}\" no se puede asignar a la variable de tipo restringido \"{name}\"",
        "typeIncompatible": "\"{sourceType}\" no se puede asignar a \"{destType}\"",
        "typeNotClass": "\"{type}\" no es una clase",
        "typeNotStringLiteral": "\"{type}\" no es un literal de cadena",
        "typeOfSymbol": "El tipo de \"{name}\" es \"{type}\"",
        "typeParamSpec": "El tipo \"{type}\" no es compatible con ParamSpec \"{name}\"",
        "typeUnsupported": "El tipo \"{type}\" no es compatible",
        "typeVarDefaultOutOfScope": "La variable de tipo \"{name} \" no está en el ámbito de aplicación",
        "typeVarIsContravariant": "El parámetro de tipo \"{name}\" es contravariante, pero \"{sourceType}\" no es un supertipo de \"{destType}\"",
        "typeVarIsCovariant": "El parámetro de tipo \"{name}\" es covariante, pero \"{sourceType}\" no es un subtipo de \"{destType}\"",
        "typeVarIsInvariant": "El parámetro de tipo \"{name}\" es invariable, pero \"{sourceType}\" no es el mismo que \"{destType}\"",
        "typeVarNotAllowed": "TypeVar no se permite para comprobaciones de instancia o clase",
        "typeVarTupleRequiresKnownLength": "TypeVarTuple no se puede enlazar a una tuple de longitud desconocida",
        "typeVarUnnecessarySuggestion": "Usar {type} en su lugar",
        "typeVarUnsolvableRemedy": "Proporciona una sobrecarga que especifica el tipo de retorno cuando no se proporciona el argumento",
        "typeVarsMissing": "Faltan variables de tipo: {names}",
        "typedDictBaseClass": "La clase “{type}” no es un TypedDict",
        "typedDictClassNotAllowed": "No se permite la clase TypedDict para comprobaciones de instancia o clase",
        "typedDictClosedExtraNotAllowed": "No se puede agregar el elemento \"{name}\"",
        "typedDictClosedExtraTypeMismatch": "No se puede agregar el elemento \"{name}\" con el tipo \"{type}\"",
        "typedDictClosedFieldNotRequired": "No se puede agregar el elemento \"{name}\" porque debe ser NotRequired.",
        "typedDictExtraFieldNotAllowed": "\"{name}\" no está presente en \"{type}\"",
        "typedDictExtraFieldTypeMismatch": "El tipo de \"{name}\" no es compatible con el tipo de \"__extra_items__\" en \"{type}\"",
        "typedDictFieldMissing": "\"{name}\" falta en \"{type}\"",
        "typedDictFieldNotReadOnly": "\"{name}\" no es de solo lectura en \"{type}\"",
        "typedDictFieldNotRequired": "\"{name}\" no es obligatorio en \"{type}\"",
        "typedDictFieldRequired": "\"{name}\" es obligatorio en \"{type}\"",
        "typedDictFieldTypeMismatch": "El tipo \"{type}\" no se puede asignar al elemento \"{name}\"",
        "typedDictFieldUndefined": "\"{name}\" es un elemento no definido en el tipo \"{type}\"",
        "typedDictFinalMismatch": "\"{sourceType}\" no es compatible con \"{destType}\" debido a una discrepancia @final",
        "typedDictKeyAccess": "Utilizar [\"{name}\"] para hacer referencia al elemento en TypedDict",
        "typedDictNotAllowed": "No se puede usar TypedDict para comprobaciones de instancia o clase",
        "unhashableType": "El tipo \"{type}\" no admite hash",
        "uninitializedAbstractVariable": "La variable de instancia \"{name}\" está definida en la clase base abstracta \"{classType} \" pero no inicializada.",
        "unreachableExcept": "\"{exceptionType}\" es una subclase de \"{parentType}\"",
        "useDictInstead": "Usar Dict[T1, T2] para indicar un tipo de diccionario",
        "useListInstead": "Usar List[T] para indicar un tipo de list o Union[T1, T2] para indicar un tipo de union",
        "useTupleInstead": "Utilice tuple[T1, ..., Tn] para indicar un tipo de tuple o Union[T1, T2] para indicar un tipo de union.",
        "useTypeInstead": "Utilice Type[T] en su lugar",
        "varianceMismatchForClass": "La varianza del argumento de tipo \"{typeVarName}\" no es compatible con la clase base \"{className}\"",
        "varianceMismatchForTypeAlias": "La varianza del argumento de tipo \"{typeVarName}\" no es compatible con \"{typeAliasParam}\""
    },
    "Service": {
        "longOperation": "La enumeración de los archivos de origen del área de trabajo está tardando mucho tiempo. Considere la posibilidad de abrir una subcarpeta en su lugar. [Más información](https://aka.ms/workspace-too-many-files)"
    }
}
