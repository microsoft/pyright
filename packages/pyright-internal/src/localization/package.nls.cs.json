{
    "CodeAction": {
        "createTypeStub": "Vytvořit zástupnou proceduru (Stub) typu",
        "createTypeStubFor": "Vytvořit zástupnou proceduru typu (Stub) pro modul {moduleName}",
        "executingCommand": "Spouští se příkaz",
        "filesToAnalyzeCount": "Počet souborů k analýze: {count}",
        "filesToAnalyzeOne": "1 soubor k analýze",
        "findingReferences": "Hledají se odkazy",
        "organizeImports": "Uspořádat direktivy Import",
        "renameShadowedFile": "Přejmenovat „{oldFile}“ na „{newFile}“"
    },
    "Completion": {
        "autoImportDetail": "Automatický import",
        "indexValueDetail": "Hodnota indexu"
    },
    "Diagnostic": {
        "abstractMethodInvocation": "Metodu „{method}“ nelze volat, protože je abstraktní a neimplementovaná.",
        "annotatedMetadataInconsistent": "Typ metadat s poznámkami „{metadataType}“ není kompatibilní s typem „{type}“.",
        "annotatedParamCountMismatch": "Počet poznámek parametrů se neshoduje: očekával(o/y) se {expected}, ale přijal(o/y) se {received}.",
        "annotatedTypeArgMissing": "Byl očekáván jeden argument typu a jedna nebo více poznámek pro Annotated",
        "annotationBytesString": "Výrazy typu nemůžou používat řetězcové literály bajtů.",
        "annotationFormatString": "Výrazy typu nemůžou používat formátovací řetězcové literály (f-strings).",
        "annotationNotSupported": "Poznámka typu není pro tento příkaz podporována",
        "annotationRawString": "Výrazy typu nemůžou používat literály nezpracovaného řetězce.",
        "annotationSpansStrings": "Výrazy typu nemůžou zahrnovat více řetězcových literálů.",
        "annotationStringEscape": "Výrazy typu nemůžou obsahovat řídicí znaky.",
        "argAssignment": "Argument typu {argType} není možné přiřadit k parametru typu {paramType}",
        "argAssignmentFunction": "Argument typu {argType} není možné přiřadit k parametru typu {paramType} ve funkci {functionName}",
        "argAssignmentParam": "Argument typu {argType} není možné přiřadit k parametru {paramName} typu {paramType}",
        "argAssignmentParamFunction": "Argument typu {argType} není možné přiřadit k parametru {paramName} typu {paramType} ve funkci {functionName}",
        "argMissingForParam": "Chybí argument pro parametr {name}",
        "argMissingForParams": "Chybí argumenty pro parametry {names}",
        "argMorePositionalExpectedCount": "Očekával se tento počet dalších pozičních argumentů: {expected}",
        "argMorePositionalExpectedOne": "Očekával se 1 další poziční argument",
        "argPositional": "Očekávaný poziční argument",
        "argPositionalExpectedCount": "Očekávaný počet pozičních argumentů: {expected}",
        "argPositionalExpectedOne": "Očekával se 1 poziční argument",
        "argTypePartiallyUnknown": "Typ argumentu je částečně neznámý",
        "argTypeUnknown": "Typ argumentu je neznámý",
        "assertAlwaysTrue": "Výraz Assert se vždy vyhodnotí jako true",
        "assertTypeArgs": "assert_type očekává dva poziční argumenty",
        "assertTypeTypeMismatch": "Neshoda assert_type: očekávalo se {expected}, ale přijalo se {received}",
        "assignmentExprComprehension": "Cíl výrazu přiřazení „{name}“ nemůže používat stejný název jako porozumění cíli",
        "assignmentExprContext": "Výraz přiřazení musí být uvnitř modulu, funkce nebo výrazu lambda",
        "assignmentExprInSubscript": "Výrazy přiřazení v dolním indexu se podporují jenom v Pythonu 3.10 a novějším",
        "assignmentInProtocol": "Proměnné instance nebo třídy v rámci třídy Protocol musí být explicitně deklarovány v těle třídy",
        "assignmentTargetExpr": "Výraz nemůže být cílem přiřazení",
        "asyncNotInAsyncFunction": "Použití „async“ není povolené mimo funkci async",
        "awaitIllegal": "Použití operátoru await vyžaduje Python 3.5 nebo novější",
        "awaitNotAllowed": "Výrazy typu nemůžou používat výraz await.",
        "awaitNotInAsync": "Operátor await je povolený jenom v rámci asynchronní funkce",
        "backticksIllegal": "V Pythonu 3.x nejsou podporovány výrazy obklopené zpětnými tečkami; místo toho použijte repr",
        "baseClassCircular": "Třída se nemůže odvozovat od sebe sama",
        "baseClassFinal": "Základní třída {type} je označená jako final a nemůže být podtřídou",
        "baseClassIncompatible": "Základní třídy typu {type} jsou vzájemně nekompatibilní",
        "baseClassInvalid": "Argument třídy musí být základní třída",
        "baseClassMethodTypeIncompatible": "Základní třídy pro třídu {classType} definují metodu {name} nekompatibilním způsobem",
        "baseClassUnknown": "Typ základní třídy je neznámý, co zakrývá typ odvozené třídy",
        "baseClassVariableTypeIncompatible": "Základní třídy pro třídu {classType} definují proměnnou {name} nekompatibilním způsobem",
        "binaryOperationNotAllowed": "Ve výrazu typu není povolený binární operátor.",
        "bindParamMissing": "Nepovedlo se vytvořit vazbu metody {methodName}, protože chybí parametr self nebo cls",
        "bindTypeMismatch": "Nepovedlo se vytvořit vazbu metody „{methodName}“, protože „{type}“ nejde přiřadit k parametru „{paramName}“",
        "breakInExceptionGroup": "V bloku except* není povolená možnost break.",
        "breakOutsideLoop": "„break“ se dá použít jenom ve smyčce",
        "bytesUnsupportedEscape": "Nepodporovaná řídicí sekvence v literálu typu bytes",
        "callableExtraArgs": "Pro Callable se očekávaly pouze dva argumenty typu",
        "callableFirstArg": "Očekával se seznam typů parametrů nebo ...",
        "callableNotInstantiable": "Není možné vytvořit instanci typu {type}",
        "callableSecondArg": "Očekával se návratový typ jako druhý argument typu pro Callable",
        "casePatternIsIrrefutable": "Nevyvratitelný vzorec je povolený jenom pro poslední výraz velikosti písmen",
        "classAlreadySpecialized": "Typ {type} je už specializovaný",
        "classDecoratorTypeUnknown": "Dekoratér netypové třídy překrývá typ třídy. dekoratér se ignoruje",
        "classDefinitionCycle": "Definice třídy pro „{name}“ závisí sama na sobě",
        "classGetItemClsParam": "Přepsání __class_getitem__ by mělo mít parametr cls",
        "classMethodClsParam": "Metody třídy by měly mít parametr „cls“",
        "classNotRuntimeSubscriptable": "Dolní index pro třídu {name} vygeneruje výjimku modulu runtime; výraz typu uzavřete do uvozovek.",
        "classPatternBuiltInArgPositional": "Vzor třídy přijímá pouze poziční dílčí vzor",
        "classPatternPositionalArgCount": "Příliš mnoho pozičních vzorů pro třídu \"{type}\"; očekávalo se {expected}, ale přijalo se {received}",
        "classPatternTypeAlias": "Typ „{type}“ nelze použít ve vzorci třídy, protože se jedná o specializovaný alias typu",
        "classPropertyDeprecated": "Vlastnosti třídy jsou v Pythonu 3.11 zastaralé a v Pythonu 3.13 se nebudou podporovat.",
        "classTypeParametersIllegal": "Syntaxe parametru typu třídy vyžaduje Python 312 nebo novější",
        "classVarFirstArgMissing": "Za ClassVar byl očekáván argument typu",
        "classVarNotAllowed": "ClassVar se v tomto kontextu nepovoluje",
        "classVarOverridesInstanceVar": "Proměnná třídy {name} přepíše proměnnou instance se stejným názvem ve třídě {className}",
        "classVarTooManyArgs": "Za „ClassVar“ byl očekáván pouze jeden argument typu",
        "classVarWithTypeVar": "Typ ClassVar nemůže obsahovat proměnné typu",
        "clsSelfParamTypeMismatch": "Typ parametru „{name}“ musí být nadtyp třídy „{classType}“",
        "codeTooComplexToAnalyze": "Kód je příliš složitý na analýzu; snižte složitost refaktorizací do podprogramů nebo redukcí podmíněných cest kódu",
        "collectionAliasInstantiation": "Nelze vytvořit instanci typu „{type}“. Použijte místo toho „{alias}“",
        "comparisonAlwaysFalse": "Podmínka se vždy vyhodnotí jako False, protože typy {leftType} a {rightType} se nepřekrývají",
        "comparisonAlwaysTrue": "Podmínka se vždy vyhodnotí jako True, protože typy {leftType} a {rightType} se nepřekrývají",
        "comprehensionInDict": "Porozumění není možné použít s jinými položkami slovníku",
        "comprehensionInSet": "Porozumění nelze použít s jinými položkami sady (set).",
        "concatenateContext": "Možnost „Concatenate“ není v tomto kontextu povolená.",
        "concatenateParamSpecMissing": "Poslední argument typu pro „Concatenate“ musí být „ParamSpec“ nebo „...“",
        "concatenateTypeArgsMissing": "Možnost „Concatenate“ vyžaduje alespoň dva argumenty typu",
        "conditionalOperandInvalid": "Neplatný podmíněný operand typu {type}",
        "constantRedefinition": "„{name}“ je konstanta (protože je velkými písmeny) a nedá se předefinovat",
        "constructorParametersMismatch": "Neshoda mezi signaturou __new__ a __init__ ve třídě“ {classType}“",
        "containmentAlwaysFalse": "Výraz se vždy vyhodnotí jako False, protože typy „{leftType}“ a „{rightType}“ se nepřekrývají",
        "containmentAlwaysTrue": "Výraz se vždy vyhodnotí jako True, protože typy „{leftType}“ a „{rightType}“ se nepřekrývají.",
        "continueInExceptionGroup": "V bloku except* není povolená možnost continue.",
        "continueOutsideLoop": "continue se dá použít jenom ve smyčce",
        "coroutineInConditionalExpression": "Podmíněný výraz odkazuje na korutinu, která se vždy vyhodnotí jako True.",
        "dataClassBaseClassFrozen": "Nezablokovaná třída nemůže dědit z zmrazené třídy",
        "dataClassBaseClassNotFrozen": "Zablokovaná třída nemůže dědit z třídy, která není zablokovaná",
        "dataClassConverterFunction": "Argument typu {argType} není platný převaděč pro pole {fieldName} typu {fieldType}",
        "dataClassConverterOverloads": "Žádná přetížení {funcName} nejsou platné převaděče pro pole {fieldName} typu {fieldType}",
        "dataClassFieldInheritedDefault": "{fieldName} přepíše pole se stejným názvem, ale chybí mu výchozí hodnota.",
        "dataClassFieldWithDefault": "Pole bez výchozích hodnot se nemůžou zobrazit po polích s výchozími hodnotami",
        "dataClassFieldWithPrivateName": "Pole datové třídy nemůže používat privátní název",
        "dataClassFieldWithoutAnnotation": "Pole dataclass bez poznámky typu způsobí výjimku modulu runtime",
        "dataClassPostInitParamCount": "Datová třída __post_init__ má nesprávný počet parametrů; počet polí InitVar je {expected}",
        "dataClassPostInitType": "Neshoda typu parametru metody __post_init__ datové třídy pro pole {fieldName}",
        "dataClassSlotsOverwrite": "__slots__ je už ve třídě definovaný",
        "dataClassTransformExpectedBoolLiteral": "Očekával se výraz, který se staticky vyhodnotí jako True nebo False",
        "dataClassTransformFieldSpecifier": "Očekávala se řazená kolekce členů (tuple) tříd nebo funkcí, ale byl přijat typ „{type}“.",
        "dataClassTransformPositionalParam": "Všechny argumenty dataclass_transform musí být argumenty klíčových slov",
        "dataClassTransformUnknownArgument": "Argument {name} není v dataclass_transform podporován",
        "dataProtocolInSubclassCheck": "Datové protokoly (které zahrnují atributy bez metody) nejsou ve voláních issubclass povolené.",
        "declaredReturnTypePartiallyUnknown": "Deklarovaný návratový typ {returnType} je částečně neznámý",
        "declaredReturnTypeUnknown": "Deklarovaný návratový typ je neznámý",
        "defaultValueContainsCall": "Volání funkcí a měnitelné objekty nejsou povoleny ve výrazu výchozí hodnoty parametru",
        "defaultValueNotAllowed": "Parametr s * nebo ** nemůže mít výchozí hodnotu",
        "delTargetExpr": "Výraz se nedá odstranit",
        "deprecatedClass": "Třída {name} je zastaralá",
        "deprecatedConstructor": "Konstruktor pro třídu {name} je zastaralý",
        "deprecatedDescriptorDeleter": "Metoda „__delete__“ pro popisovač „{name}“ je zastaralá",
        "deprecatedDescriptorGetter": "Metoda „__get__“ pro popisovač „{name}“ je zastaralá",
        "deprecatedDescriptorSetter": "Metoda „__set__“ pro popisovač „{name}“ je zastaralá",
        "deprecatedFunction": "Funkce {name} je zastaralá.",
        "deprecatedMethod": "Metoda {name} ve třídě {className} je zastaralá.",
        "deprecatedPropertyDeleter": "Metoda deleter pro property „{name}“ je zastaralá.",
        "deprecatedPropertyGetter": "Metoda getter pro property „{name}“ je zastaralá.",
        "deprecatedPropertySetter": "Metoda setter pro property „{name}“ je zastaralá.",
        "deprecatedType": "Tento typ je zastaralý jako Python {version}; místo toho použijte {replacement}",
        "dictExpandIllegalInComprehension": "Rozšíření slovníku není v porozumění povoleno",
        "dictInAnnotation": "Výraz slovníku není ve výrazu typu povolený.",
        "dictKeyValuePairs": "Položky slovníku musí obsahovat páry klíč/hodnota",
        "dictUnpackIsNotMapping": "Očekávalo se mapování pro operátor rozbalení slovníku",
        "dunderAllSymbolNotPresent": "{name} je zadáno v __all__, ale v modulu se nenachází",
        "duplicateArgsParam": "Je povolený jenom jeden parametr *",
        "duplicateBaseClass": "Duplicitní základní třída není povolena",
        "duplicateCapturePatternTarget": "Cíl zachytávání {name} se v rámci stejného vzoru nemůže vyskytovat více než jednou",
        "duplicateCatchAll": "Je povolena pouze jedna klauzule catch-all except",
        "duplicateEnumMember": "Člen Enum {name} je už deklarovaný.",
        "duplicateGenericAndProtocolBase": "Je povolena pouze jedna základní třída Generic[...] nebo Protocol[...].",
        "duplicateImport": "Import {importName} je importován více než jednou",
        "duplicateKeywordOnly": "Je povolený jenom jeden oddělovač *",
        "duplicateKwargsParam": "Je povolený jenom jeden parametr **",
        "duplicateParam": "duplicitní parametr {name}",
        "duplicatePositionOnly": "Je povolený jenom jeden parametr „/“",
        "duplicateStarPattern": "V sekvenci vzorů je povolený jenom jeden vzor „*“",
        "duplicateStarStarPattern": "Je povolena pouze jedna položka „**“",
        "duplicateUnpack": "V seznamu (list) je povolena pouze jedna operace rozbalení.",
        "ellipsisAfterUnpacked": "„…“ nelze použít s rozbalenou kolekcí TypeVarTuple nebo tuple.",
        "ellipsisContext": "„...“ se v tomto kontextu nepovoluje",
        "ellipsisSecondArg": "„...“ je povoleno pouze jako druhý ze dvou argumentů",
        "enumClassOverride": "Třída Enum {name} je final a nemůže být podtřídou.",
        "enumMemberDelete": "Člen Enum {name} se nedá odstranit.",
        "enumMemberSet": "Člen Enum {name} se nedá přiřadit.",
        "enumMemberTypeAnnotation": "Poznámky typu nejsou pro členy enum povolené.",
        "exceptGroupMismatch": "Příkaz Try nemůže obsahovat jak except, tak i except*.",
        "exceptGroupRequiresType": "Syntaxe skupiny výjimek (\"except*\") vyžaduje typ výjimky.",
        "exceptionGroupIncompatible": "Syntaxe skupiny výjimek (\"except*\") vyžaduje Python 3.11 nebo novější",
        "exceptionGroupTypeIncorrect": "Typ výjimky v except* se nedá odvodit z BaseGroupException.",
        "exceptionTypeIncorrect": "„{type}“ se neodvozuje od BaseException",
        "exceptionTypeNotClass": "{type} není platná třída výjimky",
        "exceptionTypeNotInstantiable": "Konstruktor pro výjimku typu {type} vyžaduje jeden nebo více argumentů",
        "expectedAfterDecorator": "Očekávaná deklarace funkce nebo třídy po dekoratéru",
        "expectedArrow": "Byl očekáván znak -> následovaný anotací návratového typu",
        "expectedAsAfterException": "Za typem výjimky byl očekáván znak „as“",
        "expectedAssignRightHandExpr": "Byl očekáván výraz napravo od znaku =",
        "expectedBinaryRightHandExpr": "Očekával se výraz napravo od operátoru",
        "expectedBoolLiteral": "Očekávala se hodnota True nebo False",
        "expectedCase": "Očekával se příkaz case",
        "expectedClassName": "Očekával se název třídy",
        "expectedCloseBrace": "{ nebyla uzavřena",
        "expectedCloseBracket": "[ nebyla uzavřena",
        "expectedCloseParen": "( nebyla uzavřena",
        "expectedColon": "Očekával se znak :",
        "expectedComplexNumberLiteral": "Očekával se komplexní číselný literál pro porovnávání vzorů",
        "expectedDecoratorExpr": "Forma výrazu není podporována pro dekorátor před verzí Python 3.9",
        "expectedDecoratorName": "Očekával se název dekoratéru",
        "expectedDecoratorNewline": "Na konci dekoratéru byl očekáván nový řádek",
        "expectedDelExpr": "Za del se očekával výraz",
        "expectedElse": "Očekávalo se else",
        "expectedEquals": "Očekával se znak =",
        "expectedExceptionClass": "Neplatná třída nebo objekt výjimky",
        "expectedExceptionObj": "Byl očekáván objekt výjimky, třída výjimky nebo None",
        "expectedExpr": "Očekávaný výraz",
        "expectedFunctionAfterAsync": "Očekávaná definice funkce po „async“",
        "expectedFunctionName": "Za def se očekával název funkce",
        "expectedIdentifier": "Očekávaný identifikátor",
        "expectedImport": "Očekával se import",
        "expectedImportAlias": "Za as byl očekáván symbol",
        "expectedImportSymbols": "Po možnosti import se očekával jeden nebo více názvů symbolů.",
        "expectedIn": "Očekávalo se in",
        "expectedInExpr": "Za in byl očekáván výraz",
        "expectedIndentedBlock": "Očekával se odsazený blok",
        "expectedMemberName": "Za tečkou (.) byl očekáván název atributu.",
        "expectedModuleName": "Očekávaný název modulu",
        "expectedNameAfterAs": "Za „as“ se očekával název symbolu",
        "expectedNamedParameter": "Parametr klíčového slova musí následovat za znakem *",
        "expectedNewline": "Očekával se nový řádek",
        "expectedNewlineOrSemicolon": "Příkazy musí být oddělené novými řádky nebo středníky",
        "expectedOpenParen": "Očekával se znak „(“",
        "expectedParamName": "Očekával se název parametru",
        "expectedPatternExpr": "Očekávaný výraz vzoru",
        "expectedPatternSubjectExpr": "Očekávaný výraz předmětu vzoru",
        "expectedPatternValue": "Očekávaný výraz hodnoty vzoru ve formátu a.b",
        "expectedReturnExpr": "Za return se očekával výraz",
        "expectedSliceIndex": "Očekávaný výraz indexu nebo řezu",
        "expectedTypeNotString": "Očekával se typ, ale přijal se řetězcový literál",
        "expectedTypeParameterName": "Očekávaný název parametru typu",
        "expectedYieldExpr": "Očekávaný výraz v příkazu yield",
        "finalClassIsAbstract": "Třída „{type}“ je označena jako final a musí implementovat všechny abstraktní symboly.",
        "finalContext": "Final se v tomto kontextu nepovoluje",
        "finalInLoop": "Proměnnou Final nelze přiřadit ve smyčce.",
        "finalMethodOverride": "Metoda {name} nemůže přepsat metodu final definovanou ve třídě {className}.",
        "finalNonMethod": "Funkci „{name}“ nelze označit @final, protože se nejedná o metodu.",
        "finalReassigned": "„{name}“ se deklaruje jako Final a nedá se znovu přiřadit",
        "finalRedeclaration": "{name} se dříve deklarovalo jako Final",
        "finalRedeclarationBySubclass": "{name} se nedá deklarovat znovu, protože nadřazená třída {className} ji deklaruje jako Final.",
        "finalTooManyArgs": "Za Final byl očekáván jeden argument typu",
        "finalUnassigned": "{name} se deklaruje jako Final, ale hodnota není přiřazená.",
        "finallyBreak": "K ukončení bloku „finally“ nelze použít „break“.",
        "finallyContinue": "K ukončení bloku „finally“ nelze použít „continue“.",
        "finallyReturn": "K ukončení bloku „finally“ nelze použít „return“.",
        "formatStringBrace": "Jednoduchá pravá složená závorka není v literálu f-string povolena. použijte dvojitou pravou složenou závorku",
        "formatStringBytes": "Formátovací řetězcové literály (f-strings) nemůžou být binární",
        "formatStringDebuggingIllegal": "Specifikátor ladění F-string „=“ vyžaduje Python 3.8 nebo novější",
        "formatStringEscape": "Řídicí sekvence (zpětné lomítko) není povolená v části výrazu f-string před Python 3.12",
        "formatStringExpectedConversion": "V řetězci f-string byl za znakem ! očekáván specifikátor převodu",
        "formatStringIllegal": "Formátovací řetězcové literály (f-string) vyžadují Python 3.6 nebo novější",
        "formatStringInPattern": "Formátovací řetězec není ve vzoru povolený",
        "formatStringNestedFormatSpecifier": "Příliš hluboko vnořené výrazy v rámci specifikátoru formátovacího řetězce",
        "formatStringNestedQuote": "Řetězce vnořené v řetězci f-string nemůžou používat stejný znak uvozovek jako řetězec f-string před Python 3.12",
        "formatStringUnicode": "Formátovací řetězcové literály (f-strings) nemůžou být unicode",
        "formatStringUnterminated": "Neukončený výraz v f-string; očekává se „}“",
        "functionDecoratorTypeUnknown": "Dekorátor netypové funkce překrývá typ funkce; ignoruje se dekoratér",
        "functionInConditionalExpression": "Podmíněný výraz odkazuje na funkci, která se vždy vyhodnotí jako True",
        "functionTypeParametersIllegal": "Syntaxe parametru typu funkce vyžaduje Python 3.12 nebo novější",
        "futureImportLocationNotAllowed": "Importy z __future__ musí být na začátku souboru",
        "generatorAsyncReturnType": "Návratový typ funkce asynchronního generátoru musí být kompatibilní s typem AsyncGenerator[{yieldType}, Any]",
        "generatorNotParenthesized": "Výrazy generátoru musí být v závorkách, pokud nejsou jediným argumentem",
        "generatorSyncReturnType": "Návratový typ funkce generátoru musí být kompatibilní s Generator[{yieldType}, Any, Any]",
        "genericBaseClassNotAllowed": "Základní třídu „Generic“ nejde použít se syntaxí parametru typu",
        "genericClassAssigned": "Obecný typ třídy není možné přiřadit",
        "genericClassDeleted": "Obecný typ třídy nelze odstranit",
        "genericInstanceVariableAccess": "Přístup k obecné proměnné instance prostřednictvím třídy je nejednoznačný.",
        "genericNotAllowed": "Generic není v tomto kontextu platný",
        "genericTypeAliasBoundTypeVar": "Alias obecného typu v rámci třídy nemůže používat proměnné vázaného typu {names}",
        "genericTypeArgMissing": "Generic vyžaduje alespoň jeden argument typu",
        "genericTypeArgTypeVar": "Argument typu pro Generic musí být proměnná typu",
        "genericTypeArgUnique": "Argumenty typu pro Generic musí být jedinečné",
        "globalReassignment": "{name} je přiřazen před deklarací global.",
        "globalRedefinition": "Název {name} už je deklarován jako global.",
        "implicitStringConcat": "Implicitní zřetězení řetězců není povolené",
        "importCycleDetected": "V řetězci importu byl zjištěn cyklus",
        "importDepthExceeded": "Hloubka řetězu importu překročila {depth}",
        "importResolveFailure": "Import {importName} se nepovedlo vyřešit",
        "importSourceResolveFailure": "Import {importName} se nepovedlo přeložit ze zdroje",
        "importSymbolUnknown": "{name} je neznámý symbol importu",
        "incompatibleMethodOverride": "Metoda {name} přepisuje třídu {className} nekompatibilním způsobem",
        "inconsistentIndent": "Množství zrušeného odsazení neodpovídá předchozímu odsazení",
        "inconsistentTabs": "Nekonzistentní použití tabulátorů a mezer v odsazení",
        "initMethodSelfParamTypeVar": "Anotace typu pro parametr self metody __init__ nemůže obsahovat proměnné typu s oborem třídy.",
        "initMustReturnNone": "Návratový typ __init__ musí být None",
        "initSubclassCallFailed": "Nesprávné argumenty klíčového slova pro metodu __init_subclass__",
        "initSubclassClsParam": "Přepsání __init_subclass__ by mělo mít parametr cls",
        "initVarNotAllowed": "InitVar se v tomto kontextu nepovoluje.",
        "instanceMethodSelfParam": "Metody instance by měly mít parametr self",
        "instanceVarOverridesClassVar": "Proměnná instance „{name}“ přepíše proměnnou třídy se stejným názvem ve třídě „{className}“",
        "instantiateAbstract": "Nelze vytvořit instanci abstraktní třídy „{type}“",
        "instantiateProtocol": "Nelze vytvořit instanci třídy Protocol „{type}“.",
        "internalBindError": "Při vytváření vazby souboru {file} došlo k vnitřní chybě: {message}",
        "internalParseError": "Při analýze souboru {file} došlo k vnitřní chybě: {message}",
        "internalTypeCheckingError": "Při kontrole typu souboru {file} došlo k vnitřní chybě: {message}",
        "invalidIdentifierChar": "Neplatný znak v identifikátoru",
        "invalidStubStatement": "Příkaz je v souboru zástupné procedury (stub) typu bezvýznamný.",
        "invalidTokenChars": "Neplatný znak „{text}“ v tokenu",
        "isInstanceInvalidType": "Druhý argument pro „isinstance“ musí být třída nebo řazená kolekce členů (tuple) tříd.",
        "isSubclassInvalidType": "Druhý argument pro issubclass musí být třída nebo řazená kolekce členů (tuple) tříd.",
        "keyValueInSet": "Páry klíč-hodnota nejsou v rámci sady (set) povoleny.",
        "keywordArgInTypeArgument": "Argumenty klíčových slov nelze použít v seznamech argumentů typu",
        "keywordArgShortcutIllegal": "Zástupce argumentu klíčového slova vyžaduje Python 3.14 nebo novější.",
        "keywordOnlyAfterArgs": "Oddělovač argumentů jen pro klíčová slova není povolený za parametrem *",
        "keywordParameterMissing": "Jeden nebo více parametrů klíčového slova musí následovat za parametrem „*“",
        "keywordSubscriptIllegal": "Argumenty klíčových slov v dolních indexech nejsou podporovány",
        "lambdaReturnTypePartiallyUnknown": "Návratový typ lambda {returnType} je částečně neznámý",
        "lambdaReturnTypeUnknown": "Návratový typ výrazu lambda je neznámý",
        "listAssignmentMismatch": "Výraz s typem {type} se nedá přiřadit k cílovému seznamu",
        "listInAnnotation": "Výraz List není ve výrazu typu povolený.",
        "literalEmptyArgs": "Za literálem (Literal) se očekával jeden nebo více argumentů typu.",
        "literalNamedUnicodeEscape": "Pojmenované řídicí sekvence Unicode nejsou v poznámkách řetězců Literal podporovány.",
        "literalNotAllowed": "„Literal“ nejde v tomto kontextu použít bez argumentu typu.",
        "literalNotCallable": "Není možné vytvořit instanci typu Literal.",
        "literalUnsupportedType": "Argumenty typu pro Literal musí být None, hodnota literálu (int, bool, str nebo bytes) nebo hodnota enum.",
        "matchIncompatible": "Příkazy match vyžadují Python 3.10 nebo novější",
        "matchIsNotExhaustive": "Případy v rámci příkazu match nezpracovávají kompletně všechny hodnoty",
        "maxParseDepthExceeded": "Byla překročena maximální hloubka analýzy; rozdělte výraz na dílčí výrazy",
        "memberAccess": "Nelze získat přístup k atributu {name} pro třídu {type}.",
        "memberDelete": "Nelze odstranit atribut {name} pro třídu {type}.",
        "memberSet": "Nelze přiřadit k atributu {name} pro třídu {type}.",
        "metaclassConflict": "Metatřída odvozené třídy musí být podtřídou metatříd všech jejích základních tříd",
        "metaclassDuplicate": "Je možné zadat pouze jednu metatřídu",
        "metaclassIsGeneric": "Metatřída nemůže být obecná",
        "methodNotDefined": "Metoda {name} není definována",
        "methodNotDefinedOnType": "Metoda {name} není u typu {type} definována",
        "methodOrdering": "Není možné vytvořit konzistentní řazení metod",
        "methodOverridden": "„{name}“ přepisuje metodu se stejným názvem ve třídě „{className}“ s nekompatibilním typem {type}",
        "methodReturnsNonObject": "Metoda {name} nevrací objekt",
        "missingSuperCall": "Metoda {methodName} nevolá metodu se stejným názvem v nadřazené třídě",
        "mixingBytesAndStr": "Hodnoty bytes a str nelze zřetězit.",
        "moduleAsType": "Modul nejde použít jako typ",
        "moduleNotCallable": "Modul není volatelný",
        "moduleUnknownMember": "{memberName} není známý atribut modulu {moduleName}.",
        "namedExceptAfterCatchAll": "Za klauzulí catch-all except se nemůže objevit pojmenovaná klauzule except",
        "namedParamAfterParamSpecArgs": "Parametr klíčového slova {name} se nemůže objevit v signatuře za parametrem ParamSpec args.",
        "namedTupleEmptyName": "Názvy v pojmenované řazené kolekci členů (tuple) nemůžou být prázdné.",
        "namedTupleEntryRedeclared": "{name} nejde přepsat, protože nadřazená třída {className} je pojmenovaná řazená kolekce členů (tuple).",
        "namedTupleFieldUnderscore": "Názvy polí pojmenované řazené kolekce členů (Named tuple) nemůžou začínat podtržítkem.",
        "namedTupleFirstArg": "Jako první argument byl očekáván název pojmenované třídy řazené kolekce členů (tuple).",
        "namedTupleMultipleInheritance": "Vícenásobná dědičnost s NamedTuple se nepodporuje",
        "namedTupleNameKeyword": "Názvy polí nemůžou být klíčové slovo.",
        "namedTupleNameType": "Očekávala se řazená kolekce členů (tuple) se dvěma položkami určující název a typ položky.",
        "namedTupleNameUnique": "Názvy v pojmenované řazené kolekci členů (tuple) musí být jedinečné.",
        "namedTupleNoTypes": "namedtuple neposkytuje žádné typy pro položky tuple; místo toho použijte NamedTuple",
        "namedTupleSecondArg": "Jako druhý argument byl očekáván pojmenovaný seznam (list) řazené kolekce členů (tuple).",
        "newClsParam": "Přepsání __new__ by mělo mít parametr cls",
        "newTypeAnyOrUnknown": "Druhý argument pro NewType musí být známá třída, nikoli Any nebo Unknown.",
        "newTypeBadName": "Prvním argumentem pro NewType musí být řetězcový literál",
        "newTypeLiteral": "Typ NewType není možné použít s typem Literal",
        "newTypeNameMismatch": "Typ NewType musí být přiřazen proměnné se stejným názvem.",
        "newTypeNotAClass": "Očekávaná třída jako druhý argument pro NewType",
        "newTypeParamCount": "NewType vyžaduje dva poziční argumenty",
        "newTypeProtocolClass": "NewType nelze použít se strukturálním typem (třída Protocol nebo TypedDict).",
        "noOverload": "Zadaným argumentům neodpovídají žádná přetížení pro {name}",
        "noReturnContainsReturn": "Funkce s deklarovaným návratovým typem return type NoReturn nemůže obsahovat příkaz return.",
        "noReturnContainsYield": "Funkce s deklarovaným návratovým typem NoReturn nemůže obsahovat příkaz yield",
        "noReturnReturnsNone": "Funkce s deklarovaným návratovým typem „NoReturn“ nemůže vrátit „None“.",
        "nonDefaultAfterDefault": "Nevýchozí argument následuje za výchozím argumentem",
        "nonLocalInModule": "Deklarace Nonlocal není povolená na úrovni modulu.",
        "nonLocalNoBinding": "Nenašla se žádná vazba pro nonlocal {name}.",
        "nonLocalReassignment": "{name} je přiřazeno před deklarací nonlocal.",
        "nonLocalRedefinition": "{name} již bylo deklarováno jako nonlocal.",
        "noneNotCallable": "Objekt typu „None“ nelze volat.",
        "noneNotIterable": "Objekt typu None není možné použít jako iterovatelnou hodnotu",
        "noneNotSubscriptable": "Objekt typu “None“ nelze zadat jako dolní index",
        "noneNotUsableWith": "Object of type \"None\" cannot be used with \"with\"",
        "noneNotUsableWithAsync": "Objekt typu None není možné použít s typem async with.",
        "noneOperator": "Operátor {operator} se pro None nepodporuje",
        "noneUnknownMember": "{name} není známý atribut None.",
        "nonlocalTypeParam": "Pro parametr typu {name} není povolená vazba nonlocal.",
        "notRequiredArgCount": "Za NotRequired byl očekáván jeden argument typu",
        "notRequiredNotInTypedDict": "NotRequired není v tomto kontextu povolené",
        "objectNotCallable": "Objekt typu {type} není možné volat",
        "obscuredClassDeclaration": "Deklarace třídy {name} je zakrytá deklarací stejného jména",
        "obscuredFunctionDeclaration": "Deklarace funkce {name} je zakrytá deklarací stejného názvu",
        "obscuredMethodDeclaration": "Deklarace metody {name} je zakrytá deklarací stejného názvu",
        "obscuredParameterDeclaration": "Deklarace parametru {name} je zakrytá deklarací stejného názvu",
        "obscuredTypeAliasDeclaration": "Deklarace aliasu typu {name} je zakrytá deklarací stejného názvu",
        "obscuredVariableDeclaration": "Deklarace {name} je zakrytá deklarací stejného názvu",
        "operatorLessOrGreaterDeprecated": "Operátor <> se v Pythonu 3 nepodporuje; místo toho použijte !=",
        "optionalExtraArgs": "Za nepovinnou hodnotou (Optional) se očekával jeden argument typu.",
        "orPatternIrrefutable": "Nevratný vzor je povolený jenom jako poslední dílčí vzorec ve vzorci „or“",
        "orPatternMissingName": "Všechny dílčí vzory v rámci vzoru or musí cílit na stejné názvy",
        "overlappingKeywordArgs": "Slovník silného typu se překrývá s parametrem klíčového slova: {names}",
        "overlappingOverload": "Přetížení {obscured} pro {name} se nikdy nepoužije, protože jeho parametry se překrývají s přetížením {obscuredBy}",
        "overloadAbstractImplMismatch": "Přetížení musí odpovídat abstraktnímu stavu implementace.",
        "overloadAbstractMismatch": "Buď musí být všechna přetížení abstraktní, nebo naopak nesmí být žádné z nich abstraktní.",
        "overloadClassMethodInconsistent": "Přetížení pro {name} používají @classmethod nekonzistentně.",
        "overloadFinalImpl": "dekoratér @final by se měl používat jenom pro implementaci.",
        "overloadFinalNoImpl": "Pouze první přetížení by mělo být označeno @final",
        "overloadImplementationMismatch": "Přetížená implementace není konzistentní se signaturou přetížení {index}",
        "overloadOverrideImpl": "dekoratér @override by se měl používat jenom pro implementaci.",
        "overloadOverrideNoImpl": "Pouze první přetížení by mělo být označeno @override",
        "overloadReturnTypeMismatch": "Přetížení {prevIndex} pro {name} se překrývá s přetížením {newIndex} a vrací nekompatibilní typ",
        "overloadStaticMethodInconsistent": "Přetížení pro {name} používají @staticmethod nekonzistentně.",
        "overloadWithoutImplementation": "„{name}“ je označené jako přetížení (overload), ale není zadaná žádná implementace.",
        "overriddenMethodNotFound": "Metoda „{name}“ je označená jako přepsání (override), ale neexistuje žádná základní metoda se stejným názvem.",
        "overrideDecoratorMissing": "Metoda „{name}“ není označená jako přepsání (override), ale přepisuje metodu ve třídě „{className}“.",
        "paramAfterKwargsParam": "Parametr nemůže následovat za parametrem „**“",
        "paramAlreadyAssigned": "Parametr {name} je už přiřazený",
        "paramAnnotationMissing": "Chybí poznámka typu pro parametr „{name}“",
        "paramAssignmentMismatch": "Výraz typu „{sourceType}“ nelze přiřadit k parametru typu „{paramType}“",
        "paramNameMissing": "Žádný parametr s názvem {name}",
        "paramSpecArgsKwargsDuplicate": "Argumenty pro ParamSpec {type} již byly zadány.",
        "paramSpecArgsKwargsUsage": "Atributy args a kwargs ParamSpec se musí vyskytovat v signatuře funkce.",
        "paramSpecArgsMissing": "Chybí argumenty pro parametr ParamSpec {type}",
        "paramSpecArgsUsage": "Atribut args ParamSpec je platný jenom v případě, že se používá s parametrem *args.",
        "paramSpecAssignedName": "Parametr ParamSpec musí být přiřazen proměnné s názvem {name}",
        "paramSpecContext": "ParamSpec se v tomto kontextu nepovoluje",
        "paramSpecDefaultNotTuple": "Očekávaly se tři tečky, výraz řazené kolekce členů (tuple) nebo ParamSpec pro výchozí hodnotu ParamSpec.",
        "paramSpecFirstArg": "Očekával se název parametru ParamSpec jako první argument",
        "paramSpecKwargsUsage": "Atribut kwargs ParamSpec je platný jenom v případě, že se používá s parametrem **kwargs.",
        "paramSpecNotUsedByOuterScope": "Parametr ParamSpec {name} nemá v tomto kontextu žádný význam",
        "paramSpecUnknownArg": "Parametr ParamSpec nepodporuje více než jeden argument",
        "paramSpecUnknownMember": "{name} není známý atribut ParamSpec.",
        "paramSpecUnknownParam": "„{name}“ je neznámý parametr parametru ParamSpec",
        "paramTypeCovariant": "Proměnnou kovariantní typu není možné použít v typu parametru",
        "paramTypePartiallyUnknown": "Typ parametru {paramName} je částečně neznámý",
        "paramTypeUnknown": "Typ parametru {paramName} je neznámý",
        "parenthesizedContextManagerIllegal": "Parentheses within \"with\" statement requires Python 3.9 or newer",
        "patternNeverMatches": "Vzor se nikdy nebude shodovat s typem předmětu {type}",
        "positionArgAfterNamedArg": "Poziční argument se nemůže objevit za argumenty klíčového slova",
        "positionArgAfterUnpackedDictArg": "Poziční argument se nemůže objevit po rozbalení argumentu klíčového slova.",
        "positionOnlyAfterArgs": "Oddělovač parametrů jen pro pozici není povolený za parametrem *.",
        "positionOnlyAfterKeywordOnly": "Parametr / se musí zobrazit před parametrem *",
        "positionOnlyAfterNon": "Parametr jen pro pozici není povolený za parametrem, který není jen pro pozici.",
        "positionOnlyFirstParam": "Oddělovač parametrů jen pro pozici není povolený jako první parametr.",
        "positionOnlyIncompatible": "Oddělovač parametrů jen pro pozici vyžaduje Python 3.8 nebo novější.",
        "privateImportFromPyTypedModule": "{name} se neexportuje z modulu {module}",
        "privateUsedOutsideOfClass": "{name} je privátní a používá se mimo třídu, ve které je deklarovaná",
        "privateUsedOutsideOfModule": "{name} je privátní a používá se mimo modul, ve kterém je deklarován",
        "propertyOverridden": "„{name}“ nesprávně přepíše vlastnost (property) se stejným názvem ve třídě „{className}“.",
        "propertyStaticMethod": "Statické metody nejsou povoleny pro metodu getter, setter nebo deleter vlastnosti (property).",
        "protectedUsedOutsideOfClass": "„{name}“ je chráněn(ý/o/é) a používá se mimo třídu, ve které je deklarovaná",
        "protocolBaseClass": "Třída Protocol {classType} se nemůže odvozovat od třídy, která není třídou Protocol {baseType}.",
        "protocolBaseClassWithTypeArgs": "Argumenty typu nejsou u třídy Protocol povoleny při použití syntaxe parametru typu",
        "protocolIllegal": "Použití třídy Protocol vyžaduje Python 3.7 nebo novější.",
        "protocolNotAllowed": "„Protocol“ nejde v tomto kontextu použít.",
        "protocolTypeArgMustBeTypeParam": "Argument typu pro „Protocol“ musí být parametr typu.",
        "protocolUnsafeOverlap": "Třída se nebezpečně překrývá s názvem „{name}“ a může vytvořit shodu při spuštění.",
        "protocolVarianceContravariant": "Proměnná typu {variable} použitá v obecné třídě Protocol {class} by měla být kontravariantní.",
        "protocolVarianceCovariant": "Proměnná typu {variable} použitá v obecné třídě Protocol {class} by měla být kovariantní.",
        "protocolVarianceInvariant": "Proměnná typu {variable} použitá v obecné třídě Protocol {class} by měla být invariantní.",
        "pyrightCommentInvalidDiagnosticBoolValue": "Za direktivou komentářů Pyright musí následovat znak =a hodnota true nebo false",
        "pyrightCommentInvalidDiagnosticSeverityValue": "Za direktivou komentářů Pyright musí následovat = a hodnota true, false, error, warning, information nebo none",
        "pyrightCommentMissingDirective": "Za komentářem Pyright musí následovat direktiva (basic nebo strict) nebo diagnostické pravidlo.",
        "pyrightCommentNotOnOwnLine": "Komentáře Pyright používané k řízení nastavení na úrovni souborů se musí zobrazovat na vlastním řádku",
        "pyrightCommentUnknownDiagnosticRule": "{rule} je neznámé diagnostické pravidlo pro komentář pyright",
        "pyrightCommentUnknownDiagnosticSeverityValue": "{value} je neplatná hodnota pro komentář pyright; očekávalo se true, false, error, warning, information nebo none",
        "pyrightCommentUnknownDirective": "Direktiva {directive} je neznámá direktiva pro komentář pyright; očekávalo se strict nebo basic",
        "readOnlyArgCount": "Za „ReadOnly“ se očekával jeden argument typu",
        "readOnlyNotInTypedDict": "ReadOnly není v tomto kontextu povolené",
        "recursiveDefinition": "Typ „{name}“ nelze určit, protože odkazuje sám na sebe",
        "relativeImportNotAllowed": "Relativní importy se nedají použít s formulářem „import .a“; místo toho použijte „from . import a“.",
        "requiredArgCount": "Za povinným argumentem (Required) se očekával jeden argument typu.",
        "requiredNotInTypedDict": "Required není v tomto kontextu povoleno",
        "returnInAsyncGenerator": "Příkaz Return s hodnotou není v asynchronním generátoru povolený",
        "returnInExceptionGroup": "V bloku except* není povolená možnost return.",
        "returnMissing": "Funkce s deklarovaným návratovým typem „{returnType}“ musí vracet hodnotu na všech cestách kódu",
        "returnOutsideFunction": "„return“ se dá použít jenom v rámci funkce",
        "returnTypeContravariant": "Kontravariantní proměnnou typu nejde použít v návratovém typu",
        "returnTypeMismatch": "Typ {exprType} se nedá přiřadit k návratovému typu {returnType}.",
        "returnTypePartiallyUnknown": "Návratový typ {returnType} je částečně neznámý",
        "returnTypeUnknown": "Návratový typ je neznámý",
        "revealLocalsArgs": "Pro volání reveal_locals se neočekávaly žádné argumenty",
        "revealLocalsNone": "V tomto oboru nejsou žádné místní hodnoty (locals).",
        "revealTypeArgs": "Pro volání reveal_type byl očekáván jeden poziční argument",
        "revealTypeExpectedTextArg": "Argument „expected_text“ pro funkci „reveal_type“ musí být hodnota literálu str",
        "revealTypeExpectedTextMismatch": "Neshoda typu textu; očekávaný počet: {expected}, počet, který byl přijat: {received}",
        "revealTypeExpectedTypeMismatch": "Neshoda typů; Očekával(o/y) se „{expected}“, ale přijal(o/y) se „{received}“",
        "selfTypeContext": "Self není v tomto kontextu platné",
        "selfTypeMetaclass": "„Self“ nelze použít v rámci metatřídy (podtřídy „type“).",
        "selfTypeWithTypedSelfOrCls": "Self není možné použít ve funkci s parametrem self nebo cls, která má jinou poznámku typu než Self",
        "setterGetterTypeMismatch": "Typ hodnoty metody setter vlastnosti (property) není možné přiřadit návratovému typu getter.",
        "singleOverload": "{name} je označené jako přetížení, ale chybí další přetížení",
        "slotsAttributeError": "„{name}“ není zadaný v __slots__",
        "slotsClassVarConflict": "{name} je v konfliktu s proměnnou instance deklarovanou v __slots__",
        "starPatternInAsPattern": "Vzor hvězdy se nedá použít s cílem as",
        "starPatternInOrPattern": "Vzor hvězdy nemůže být ORed v jiných vzorech",
        "starStarWildcardNotAllowed": "** není možné použít se zástupným znakem _",
        "staticClsSelfParam": "Statické metody by neměly přijímat parametr self nebo cls",
        "stdlibModuleOverridden": "„{path}“ přepisuje modul stdlib „{name}“",
        "stringNonAsciiBytes": "Znak jiný než ASCII není povolený v bajtech řetězcového literálu",
        "stringNotSubscriptable": "Řetězcový výraz není možné ve výrazu typu zadat jako dolní index. Uzavřete celý výraz do uvozovek.",
        "stringUnsupportedEscape": "Nepodporovaná řídicí sekvence v řetězcovém literálu",
        "stringUnterminated": "Řetězcový literál je neukončený",
        "stubFileMissing": "Soubor zástupné procedury (stub) pro „{importName}“ se nenašel.",
        "stubUsesGetAttr": "Soubor zástupné procedury (stub) typu je neúplný; __getattr__ zakrývá typové chyby pro modul.",
        "sublistParamsIncompatible": "Parametry sublist nejsou v Pythonu 3.x podporované.",
        "superCallArgCount": "Pro volání „super“ se očekávaly maximálně dva argumenty",
        "superCallFirstArg": "Jako první argument pro volání super se očekával typ třídy, ale přijal se {type}",
        "superCallSecondArg": "Druhý argument volání super musí být objekt nebo třída odvozená z typu {type}",
        "superCallZeroArgForm": "Forma nulového argumentu „super“ volání je platná pouze v rámci metody.",
        "superCallZeroArgFormStaticMethod": "Forma nulového argumentu „super“ volání není platná v rámci statické metody.",
        "symbolIsPossiblyUnbound": "{name} je pravděpodobně nevázané",
        "symbolIsUnbound": "Název {name} je nevázaný",
        "symbolIsUndefined": "{name} není definované",
        "symbolOverridden": "{name} přepíše symbol stejného názvu ve třídě {className}",
        "ternaryNotAllowed": "Výraz ternary není ve výrazu typu povolený.",
        "totalOrderingMissingMethod": "Třída musí definovat jednu z __lt__, __le__, __gt__ nebo __ge__, aby bylo možné používat total_ordering",
        "trailingCommaInFromImport": "Koncová čárka není povolena bez okolních závorek",
        "tryWithoutExcept": "Příkaz Try musí mít alespoň jednu klauzuli except nebo finally",
        "tupleAssignmentMismatch": "Výraz s typem „{type}“ se nedá přiřadit cílové řazené kolekci členů (tuple).",
        "tupleInAnnotation": "Výraz řazené kolekce členů (tuple) není ve výrazu typu povolený.",
        "tupleIndexOutOfRange": "Index {index} je pro typ {type} mimo rozsah",
        "typeAliasIllegalExpressionForm": "Neplatný formulář výrazu pro definici aliasu typu",
        "typeAliasIsRecursiveDirect": "Alias typu „{name}“ nemůže ve své definici používat sám sebe",
        "typeAliasNotInModuleOrClass": "Typ TypeAlias je možné definovat pouze v rámci oboru modulu nebo třídy",
        "typeAliasRedeclared": "„{name}“ se deklaruje jako TypeAlias a dá se přiřadit jenom jednou.",
        "typeAliasStatementBadScope": "Příkaz type se dá použít jenom v rámci oboru modulu nebo třídy.",
        "typeAliasStatementIllegal": "Příkaz alias typu vyžaduje Python 3.12 nebo novější",
        "typeAliasTypeBadScope": "Alias typu se dá definovat jenom v rámci oboru modulu nebo třídy",
        "typeAliasTypeBaseClass": "Alias typu definovaný v příkazu \"type\" nejde použít jako základní třídu.",
        "typeAliasTypeMustBeAssigned": "Typ TypeAliasType musí být přiřazen proměnné se stejným názvem jako alias typu",
        "typeAliasTypeNameArg": "První argument TypeAliasType musí být řetězcový literál představující název aliasu typu.",
        "typeAliasTypeNameMismatch": "Název aliasu typu se musí shodovat s názvem proměnné, ke které je přiřazená",
        "typeAliasTypeParamInvalid": "Seznam parametrů typu musí být řazená kolekce členů (tuple) obsahující pouze TypeVar, TypeVarTuple nebo ParamSpec.",
        "typeAnnotationCall": "Výraz volání není ve výrazu typu povolený",
        "typeAnnotationVariable": "Proměnná není ve výrazu typu povolená",
        "typeAnnotationWithCallable": "Argument typu pro „type“ musí být třída; volatelné objekty se nepodporují.",
        "typeArgListExpected": "Očekával se parametr ParamSpec, tři tečky nebo seznam (list) typů.",
        "typeArgListNotAllowed": "Výraz seznamu (list) není pro tento argument typu povolený.",
        "typeArgsExpectingNone": "Pro třídu {name} se neočekávaly žádné argumenty typu",
        "typeArgsMismatchOne": "Očekával se jeden argument typu, ale bylo přijato {received}",
        "typeArgsMissingForAlias": "Pro alias obecného typu {name} se očekávaly argumenty typu",
        "typeArgsMissingForClass": "Očekávané argumenty typu pro obecnou třídu „{name}“",
        "typeArgsTooFew": "Pro {name} se zadalo příliš málo argumentů typu. Očekávalo se {expected}, ale přijalo se {received}",
        "typeArgsTooMany": "Pro „{name}“ se zadalo příliš mnoho argumentů typu. Očekával(o/y) se {expected}, ale přijal(o/y) se {received}",
        "typeAssignmentMismatch": "Typ {sourceType} se nedá přiřadit k deklarovanému typu {destType}.",
        "typeAssignmentMismatchWildcard": "Symbol importu {name} má typ {sourceType}, který se nedá přiřadit k deklarovanému typu {destType}.",
        "typeCallNotAllowed": "Volání type() by se nemělo používat ve výrazu typu.",
        "typeCheckOnly": "Název {name} je označený jako @type_check_only a dá se použít jenom v poznámkách typu",
        "typeCommentDeprecated": "Použití komentářů type je zastaralé místo toho použít anotaci type.",
        "typeExpectedClass": "Očekávala se třída, ale byl přijat typ {type}.",
        "typeFormArgs": "TypeForm přijímá jeden poziční argument.",
        "typeGuardArgCount": "Za TypeGuard nebo TypeIs byl očekáván jeden argument typu.",
        "typeGuardParamCount": "Funkce a metody ochrany typů definované uživatelem musí mít alespoň jeden vstupní parametr",
        "typeIsReturnType": "Návratový typ TypeIs ({returnType}) není konzistentní s typem parametru hodnoty ({type}).",
        "typeNotAwaitable": "„{type}“ není awaitable.",
        "typeNotIntantiable": "Není možné vytvořit instanci {type}",
        "typeNotIterable": "{type} není možné iterovat",
        "typeNotSpecializable": "Nepovedlo se specializovat typ „{type}“",
        "typeNotSubscriptable": "Objekt typu {type} není možné zadat jako dolní index",
        "typeNotSupportBinaryOperator": "Operátor „{operator}“ se pro typy „{leftType}“ a „{rightType}“ nepodporuje",
        "typeNotSupportBinaryOperatorBidirectional": "Operátor {operator} není podporován pro typy „{leftType}“ a „{rightType}“, pokud se očekává typ „{expectedType}“",
        "typeNotSupportUnaryOperator": "Operátor {operator} se pro typ {type} nepodporuje",
        "typeNotSupportUnaryOperatorBidirectional": "Operátor {operator} není podporován pro typ {type}, když očekávaný typ je {expectedType}",
        "typeNotUsableWith": "Objekt typu {type} není možné použít s typem with, protože neimplementuje správně metodu {method}.",
        "typeNotUsableWithAsync": "Objekt typu {type} není možné použít s typem async with, protože neimplementuje správně metodu {method}.",
        "typeParameterBoundNotAllowed": "Vazbu nebo omezení nelze použít s parametrem variadického typu ani s parametrem ParamSpec",
        "typeParameterConstraintTuple": "Omezení parametru typu musí být řazená kolekce členů dvou nebo více typů",
        "typeParameterExistingTypeParameter": "Parametr typu {name} se už používá",
        "typeParameterNotDeclared": "Parametr typu {name} není zahrnutý v seznamu parametrů typu pro kontejner {container}",
        "typeParametersMissing": "Musí být zadán alespoň jeden parametr typu",
        "typePartiallyUnknown": "Typ {name} je částečně neznámý",
        "typeUnknown": "Typ {name} je neznámý",
        "typeVarAssignedName": "Typ TypeVar musí být přiřazen proměnné s názvem {name}",
        "typeVarAssignmentMismatch": "Typ „{type}“ se nedá přiřadit proměnné typu „{name}“",
        "typeVarBoundAndConstrained": "TypeVar nemůže být současně vázaný i omezený",
        "typeVarBoundGeneric": "Vázaný typ TypeVar nemůže být obecný",
        "typeVarConstraintGeneric": "Typ omezení TypeVar nemůže být obecný",
        "typeVarDefaultBoundMismatch": "Výchozí typ TypeVar musí být podtyp vázaného typu",
        "typeVarDefaultConstraintMismatch": "Výchozí typ TypeVar musí být jeden z omezených typů",
        "typeVarDefaultIllegal": "Výchozí typy proměnných typů vyžadují Python 3.13 nebo novější",
        "typeVarDefaultInvalidTypeVar": "Parametr typu {name} má výchozí typ, který odkazuje na jednu nebo více proměnných typu, které jsou mimo obor",
        "typeVarFirstArg": "Očekával se název TypeVar jako první argument",
        "typeVarInvalidForMemberVariable": "Typ atributu nemůže používat proměnnou typu {name} vymezenou na místní metodu.",
        "typeVarNoMember": "TypeVar {type} nemá žádný atribut {name}.",
        "typeVarNotSubscriptable": "TypeVar {type} není možné zadat jako dolní index",
        "typeVarNotUsedByOuterScope": "Proměnná typu {name} nemá v tomto kontextu žádný význam",
        "typeVarPossiblyUnsolvable": "Proměnná typu „{name}“ může být nevyřešená, pokud volající nezadá žádný argument pro parametr „{param}“",
        "typeVarSingleConstraint": "TypeVar musí mít alespoň dva omezené typy",
        "typeVarTupleConstraints": "TypeVarTuple nemůže mít omezení hodnoty",
        "typeVarTupleContext": "TypeVarTuple se v tomto kontextu nepovoluje",
        "typeVarTupleDefaultNotUnpacked": "Výchozí typ TypeVarTuple musí být rozbalená řazená kolekce členů (tuple) nebo TypeVarTuple.",
        "typeVarTupleMustBeUnpacked": "Pro hodnotu TypeVarTuple se vyžaduje operátor rozbalení",
        "typeVarTupleUnknownParam": "{name} je neznámý parametr pro TypeVarTuple",
        "typeVarUnknownParam": "„{name}“ je neznámý parametr pro TypeVar",
        "typeVarUsedByOuterScope": "TypeVar „{name}“ se už používá ve vnějším oboru",
        "typeVarUsedOnlyOnce": "TypeVar {name} se v signatuře obecné funkce zobrazuje jenom jednou",
        "typeVarVariance": "TypeVar nemůže být kovariantní i kontravariantní",
        "typeVarWithDefaultFollowsVariadic": "TypeVar {typeVarName} má výchozí hodnotu a nemůže následovat po TypeVarTuple {variadicName}.",
        "typeVarWithoutDefault": "„{name}“ se v seznamu parametrů typu nemůže zobrazit za „{other}“ , protože nemá žádný výchozí typ",
        "typeVarsNotInGenericOrProtocol": "Generic[] nebo Protocol[] musí obsahovat všechny proměnné typu",
        "typedDictAccess": "Nepovedlo se získat přístup k položce v TypedDict",
        "typedDictAssignedName": "TypedDict se musí přiřadit proměnné s názvem „{name}“.",
        "typedDictBadVar": "Třídy TypedDict můžou obsahovat jenom poznámky typu",
        "typedDictBaseClass": "Všechny základní třídy pro třídy TypedDict musí být také třídami TypedDict",
        "typedDictBoolParam": "Očekávalo se, že parametr {name} bude mít hodnotu True nebo False",
        "typedDictClosedExtras": "Základní \"{name}\" třídy je TypedDict, který omezuje typ dalších položek na typ \"{type}\"",
        "typedDictClosedNoExtras": "Základní třída {name} je closed TypedDict; položky navíc nejsou povolené.",
        "typedDictDelete": "Nepovedlo se odstranit položku v TypedDict",
        "typedDictEmptyName": "Názvy v rámci TypedDict nemůžou být prázdné",
        "typedDictEntryName": "Očekával se řetězcový literál pro název položky slovníku",
        "typedDictEntryUnique": "Názvy ve slovníku musí být jedinečné",
        "typedDictExtraArgs": "Nadbytečné argumenty TypedDict nejsou podporovány",
        "typedDictExtraItemsClosed": "TypedDict může používat buď \"closed\", nebo \"extra_items\", ale ne obojí.",
        "typedDictFieldNotRequiredRedefinition": "Položka TypedDict {name} nejde předefinovat jako NotRequired.",
        "typedDictFieldReadOnlyRedefinition": "Položka TypedDict {name} nejde předefinovat jako ReadOnly.",
        "typedDictFieldRequiredRedefinition": "Položka TypedDict {name} nejde předefinovat jako Required.",
        "typedDictFirstArg": "Jako první argument byl očekáván název třídy TypedDict",
        "typedDictInClassPattern": "Třída TypedDict není ve vzoru třídy povolena.",
        "typedDictInitsubclassParameter": "TypedDict nepodporuje parametr __init_subclass__ „{name}“.",
        "typedDictNotAllowed": "„TypedDict“ se v tomto kontextu nedá použít.",
        "typedDictSecondArgDict": "Jako druhý parametr se očekával parametr dict nebo keyword.",
        "typedDictSecondArgDictEntry": "Očekávaná jednoduchá položka slovníku",
        "typedDictSet": "Nelze přiřadit položku v TypedDict",
        "unaccessedClass": "Třída „{name}“ není zpřístupněna",
        "unaccessedFunction": "Funkce {name} není zpřístupněn",
        "unaccessedImport": "Import {name} není zpřístupněn",
        "unaccessedSymbol": "{name} není zpřístupněn",
        "unaccessedVariable": "Proměnná {name} není zpřístupněná",
        "unannotatedFunctionSkipped": "Analýza funkce „{name}“ se přeskočila, protože není označená",
        "unaryOperationNotAllowed": "Ve výrazu typu není povolený unární operátor.",
        "unexpectedAsyncToken": "Očekávalo se, že za async bude následovat def, with nebo for",
        "unexpectedExprToken": "Neočekávaný token na konci výrazu",
        "unexpectedIndent": "Neočekávané odsazení",
        "unexpectedUnindent": "Neočekává se unindent",
        "unhashableDictKey": "Klíč slovníku musí být hashovatelný",
        "unhashableSetEntry": "Položka set musí být hashovatelná.",
        "uninitializedAbstractVariables": "Proměnné definované v abstraktní základní třídě nejsou inicializovány ve třídě final {classType}.",
        "uninitializedInstanceVariable": "Proměnná instance {name} není inicializována v těle třídy nebo v metodě __init__",
        "unionForwardReferenceNotAllowed": "Syntaxi Union není možné použít s operandem řetězce; použijte uvozovky kolem celého výrazu.",
        "unionSyntaxIllegal": "Alternativní syntaxe pro sjednocení vyžaduje Python 3.10 nebo novější",
        "unionTypeArgCount": "Union vyžaduje dva nebo více argumentů typu.",
        "unionUnpackedTuple": "Union nemůže obsahovat rozbalenou řazenou kolekci členů (tuple).",
        "unionUnpackedTypeVarTuple": "Union nemůže obsahovat rozbalený typ TypeVarTuple.",
        "unnecessaryCast": "Nepotřebné volání „cast“; typ už je „{type}“.",
        "unnecessaryIsInstanceAlways": "Zbytečné volání isinstance; {testType} je vždy instancí třídy {classType}",
        "unnecessaryIsInstanceNever": "Zbytečné volání isinstance; {testType} není nikdy instancí třídy {classType}",
        "unnecessaryIsSubclassAlways": "Nepotřebné volání issubclass; „{testType}“ je vždy podtřídou třídy „{classType}“",
        "unnecessaryIsSubclassNever": "Zbytečné volání issubclass; {testType} není nikdy podtřídou třídy {classType}",
        "unnecessaryPyrightIgnore": "Nepotřebný komentář „# pyright: ignore“",
        "unnecessaryPyrightIgnoreRule": "Nepotřebné pravidlo # pyright: ignore: {name}",
        "unnecessaryTypeIgnore": "Nepotřebný komentář „# type: ignore“",
        "unpackArgCount": "Po rozbalení „Unpack“ se očekával jeden argument typu",
        "unpackExpectedTypeVarTuple": "Jako argument typu pro Unpack byl očekáván typ TypeVarTuple nebo tuple.",
        "unpackExpectedTypedDict": "Byl očekáván argument typu TypedDict pro rozbalení Unpack",
        "unpackIllegalInComprehension": "Operace rozbalení není v porozumění povolená",
        "unpackInAnnotation": "Ve výrazu typu není povolený operátor rozbalení.",
        "unpackInDict": "Operace rozbalení není ve slovnících povolena",
        "unpackInSet": "Operátor rozbalení není v sadě (set) povolený.",
        "unpackNotAllowed": "Unpack se v tomto kontextu nepovoluje.",
        "unpackOperatorNotAllowed": "Operace rozbalení není v tomto kontextu povolená",
        "unpackTuplesIllegal": "Operace rozbalení není povolená v řazených kolekcích členů před Pythonem 3.8",
        "unpackedArgInTypeArgument": "V tomto kontextu nelze použít rozbalené argumenty.",
        "unpackedArgWithVariadicParam": "Pro parametr TypeVarTuple nejde použít rozbalený argument",
        "unpackedDictArgumentNotMapping": "Výraz argumentu za ** musí být mapování s typem klíče str",
        "unpackedDictSubscriptIllegal": "Operátor rozbalení slovníku v dolním indexu není povolený",
        "unpackedSubscriptIllegal": "Operátor rozbalení v dolním indexu vyžaduje Python 3.11 nebo novější",
        "unpackedTypeVarTupleExpected": "Byl očekáván rozbalený typ TypeVarTuple; použijte Unpack[{name1}] nebo *{name2}",
        "unpackedTypedDictArgument": "Nepovedlo se spárovat nebalený argument TypedDict s parametry",
        "unreachableCode": "Kód je nedostupný",
        "unreachableCodeType": "Analýza typů indikuje, že kód není dostupný.",
        "unreachableExcept": "Klauzule Except je nedosažitelná, protože výjimka je již zpracována",
        "unsupportedDunderAllOperation": "Operace s __all__ se nepodporuje, takže exportovaný seznam symbolů nemusí být správný",
        "unusedCallResult": "Výsledek výrazu volání je typu „{type}“ a nepoužívá se. přiřadit proměnné „_“, pokud je to záměrné",
        "unusedCoroutine": "Výsledek volání asynchronní funkce se nepoužívá; použijte operátor await nebo přiřaďte výsledek proměnné",
        "unusedExpression": "Hodnota výrazu se nepoužívá",
        "varAnnotationIllegal": "Poznámky type pro proměnné vyžadují Python 3.6 nebo novější; pro kompatibilitu s předchozími verzemi použijte komentáře type.",
        "variableFinalOverride": "Proměnná {name} je označená jako Final a přepíše proměnnou non-Final se stejným názvem ve třídě {className}.",
        "variadicTypeArgsTooMany": "Seznam argumentů typů může mít maximálně jeden rozbalený typ TypeVarTuple nebo tuple.",
        "variadicTypeParamTooManyAlias": "Alias typu může mít maximálně jeden parametr typu TypeVarTuple, ale přijal několik ({names})",
        "variadicTypeParamTooManyClass": "Obecná třída může mít maximálně jeden parametr typu TypeVarTuple, ale přijala více ({names})",
        "walrusIllegal": "Operátor := vyžaduje Python 3.8 nebo novější",
        "walrusNotAllowed": "Operátor := není v tomto kontextu povolen bez okolních závorek",
        "wildcardInFunction": "V rámci třídy nebo funkce není povolen import se zástupnými znaky.",
        "wildcardLibraryImport": "Není povolený import se zástupnými znaky z knihovny.",
        "wildcardPatternTypePartiallyUnknown": "Typ zachycený vzorem se zástupnými znaky je částečně neznámý",
        "wildcardPatternTypeUnknown": "Typ zachycený vzorem se zástupnými znaky je neznámý",
        "yieldFromIllegal": "Použití příkazu yield from vyžaduje Python 3.3 nebo novější",
        "yieldFromOutsideAsync": "yield from není v asynchronní funkci povoleno",
        "yieldOutsideFunction": "„yield“ není povoleno mimo funkci nebo lambdu",
        "yieldWithinComprehension": "„yield“ není povolené uvnitř porozumění",
        "zeroCaseStatementsFound": "Výraz shody (match) obsahovat alespoň jeden výraz velikosti písmen (case).",
        "zeroLengthTupleNotAllowed": "Řazená kolekce členů (tuple) s nulovou délkou není v tomto kontextu povolená."
    },
    "DiagnosticAddendum": {
        "annotatedNotAllowed": "Speciální formulář Annotated nejde použít s kontrolami instancí a tříd.",
        "argParam": "Argument odpovídá parametru {paramName}",
        "argParamFunction": "Argument odpovídá parametru {paramName} ve funkci {functionName}",
        "argsParamMissing": "Parametr „*{paramName}“ nemá žádný odpovídající parametr",
        "argsPositionOnly": "Neshoda parametrů pouze s pozicí; Očekával(o/y) se {expected}, ale přijal(o/y) se {received}",
        "argumentType": "Typ argumentu je {type}",
        "argumentTypes": "Typy argumentů: ({types})",
        "assignToNone": "Typ se nedá přiřadit k None.",
        "asyncHelp": "Měli jste na mysli „async with“?",
        "baseClassIncompatible": "Základní třída {baseClass} není kompatibilní s typem {type}",
        "baseClassIncompatibleSubclass": "Základní třída {baseClass} je odvozená od třídy {subclass}, která není kompatibilní s typem {type}",
        "baseClassOverriddenType": "Základní třída {baseClass} poskytuje typ {type}, který je přepsán",
        "baseClassOverridesType": "Základní třída „{baseClass}“ přepisuje typ „{type}“",
        "bytesTypePromotions": "Pokud chcete povolit chování povýšení typu pro „bytearray“ a „memoryview“, nastavte disableBytesTypePromotions na false",
        "conditionalRequiresBool": "Metoda __bool__ pro typ {operandType} vrací typ {boolReturnType} místo bool",
        "dataClassFieldLocation": "Deklarace pole",
        "dataClassFrozen": "{name} je zablokované",
        "dataProtocolUnsupported": "„{name}“ je datový protokol.",
        "descriptorAccessBindingFailed": "Nepovedlo se vytvořit vazbu metody {name} pro třídu popisovače {className}.",
        "descriptorAccessCallFailed": "Nepovedlo se volat metodu {name} pro třídu popisovače {className}.",
        "finalMethod": "Metoda Final",
        "functionParamDefaultMissing": "V parametru „{name}“ chybí výchozí argument",
        "functionParamName": "Neshoda názvu parametru: {destName} a {srcName}",
        "functionParamPositionOnly": "Neshoda parametrů pouze s pozicí; Parametr „{name}“ není jen pro pozici.",
        "functionReturnTypeMismatch": "Návratový typ funkce „{sourceType}“ není kompatibilní s typem „{destType}“",
        "functionTooFewParams": "Funkce přijímá příliš málo pozičních parametrů; očekávaný počet: {expected}, počet, který byl přijat: {received}",
        "functionTooManyParams": "Funkce přijímá příliš mnoho pozičních parametrů; očekávaný počet: {expected}, počet, který byl přijat: {received}",
        "genericClassNotAllowed": "Obecný typ s argumenty obecného typu se pro kontroly instancí nebo tříd nepovoluje.",
        "incompatibleDeleter": "Metoda deleter vlastnosti (property) je nekompatibilní.",
        "incompatibleGetter": "Metoda getter vlastnosti (property) je nekompatibilní.",
        "incompatibleSetter": "Metoda setter vlastnosti (property) je nekompatibilní.",
        "initMethodLocation": "Metoda __init__ je definována ve třídě {type}",
        "initMethodSignature": "Podpis __init__ je {type}",
        "initSubclassLocation": "Metoda __init_subclass__ je definována ve třídě {name}.",
        "invariantSuggestionDict": "Zvažte přepnutí z možnosti „dict“ na možnost „Mapping“, která je v typu hodnoty kovariantní.",
        "invariantSuggestionList": "Zvažte přepnutí z možnosti „list“ na možnost „Sequence“, která je kovariantní.",
        "invariantSuggestionSet": "Zvažte přepnutí z možnosti „set“ na možnost „Container“, která je kovariantní.",
        "isinstanceClassNotSupported": "{type} se pro kontroly instancí a tříd nepodporuje.",
        "keyNotRequired": "„{name}! není v typu „{type}“ povinný klíč, takže přístup může vést k výjimce modulu runtime",
        "keyReadOnly": "{name} je klíč jen pro čtení v {type}",
        "keyRequiredDeleted": "{name} je povinný klíč a nedá se odstranit",
        "keyUndefined": "{name} není definovaný klíč v typu {type}",
        "kwargsParamMissing": "Parametr „**{paramName}“ nemá žádný odpovídající parametr",
        "listAssignmentMismatch": "Typ {type} není kompatibilní s cílovým seznamem",
        "literalAssignmentMismatch": "{sourceType} se nedá přiřadit k typu {destType}.",
        "literalNotAllowed": "Speciální formulář Literal nejde použít s kontrolami instancí a tříd.",
        "matchIsNotExhaustiveHint": "Pokud není zamýšleno vyčerpávající zpracování, přidejte case _: pass",
        "matchIsNotExhaustiveType": "Nezpracovaný typ: {type}",
        "memberAssignment": "Výraz typu {type} nelze přiřadit k atributu {name} třídy {classType}.",
        "memberIsAbstract": "„{type}.{name}“ není implementováno.",
        "memberIsAbstractMore": "a tento počet dalších: {count}...",
        "memberIsClassVarInProtocol": "„{name}“ je v protokolu definován jako ClassVar.",
        "memberIsInitVar": "{name} je pole init-only.",
        "memberIsInvariant": "{name} je invariantní, protože je proměnlivé",
        "memberIsNotClassVarInClass": "„{name}“ musí být definováno jako ClassVar, aby bylo kompatibilní s protokolem.",
        "memberIsNotClassVarInProtocol": "„{name}“ není v protokolu definován jako ClassVar.",
        "memberIsNotReadOnlyInProtocol": "{name} není v protokolu jen pro čtení.",
        "memberIsReadOnlyInProtocol": "{name} je v protokolu jen pro čtení.",
        "memberIsWritableInProtocol": "{name} se dá zapisovat do protokolu.",
        "memberSetClassVar": "Atribut {name} nelze přiřadit prostřednictvím instance třídy, protože jde o ClassVar.",
        "memberTypeMismatch": "{name} je nekompatibilní typ",
        "memberUnknown": "Atribut {name} je neznámý.",
        "metaclassConflict": "Metatřída {metaclass1} je v konfliktu s metatřídou {metaclass2}.",
        "missingDeleter": "Chybí metoda deleter vlastnosti (property).",
        "missingGetter": "Chybí metoda getter vlastnosti (property).",
        "missingSetter": "Chybí metoda setter vlastnosti (property).",
        "namedParamMissingInDest": "Další parametr „{name}“",
        "namedParamMissingInSource": "Chybí parametr klíčového slova „{name}“.",
        "namedParamTypeMismatch": "Parametr klíčového slova {name} typu {sourceType} není kompatibilní s typem {destType}.",
        "namedTupleNotAllowed": "NamedTuple se nedá použít pro kontroly instancí nebo tříd.",
        "newMethodLocation": "Metoda __new__ je definována ve třídě {type}",
        "newMethodSignature": "Podpis __new__ je {type}",
        "newTypeClassNotAllowed": "Třídu vytvořenou pomocí NewType nelze použít s kontrolami instancí a tříd.",
        "noOverloadAssignable": "Typ {type} neodpovídá žádné přetížené funkci",
        "noneNotAllowed": "Možnost None se nedá použít pro kontroly instancí nebo tříd.",
        "orPatternMissingName": "Chybějící názvy: {name}",
        "overloadIndex": "Přetížení {index} je nejbližší shoda.",
        "overloadNotAssignable": "Nejméně jedno přetížení {name} není možné přiřadit",
        "overloadSignature": "Tady je definován podpis přetížení",
        "overriddenMethod": "Přepsaná metoda",
        "overriddenSymbol": "Přepsaný symbol",
        "overrideInvariantMismatch": "Typ přepsání „{overrideType}“není stejný jako základní typ „{baseType}“",
        "overrideIsInvariant": "Proměnná je proměnlivá, takže její typ je invariantní",
        "overrideNoOverloadMatches": "Signatura přetížení v přepsání není kompatibilní se základní metodou",
        "overrideNotClassMethod": "Základní metoda je deklarována jako metoda classmethod, ale přepsání není",
        "overrideNotInstanceMethod": "Základní metoda je deklarována jako instanční metoda, ale přepsání není",
        "overrideNotStaticMethod": "Základní metoda je deklarována jako staticmethod, ale přepsání není",
        "overrideOverloadNoMatch": "Přepsání nezahrnuje všechna přetížení metody základní třídy",
        "overrideOverloadOrder": "Přetížení přepisované metody musí být ve stejném pořadí jako základní metoda",
        "overrideParamKeywordNoDefault": "Neshoda parametru klíčového slova „{name}“: základní parametr má výchozí hodnotu argumentu, parametr pro přepsání ne",
        "overrideParamKeywordType": "Neshoda typu parametru klíčového slova „{name}“: základní parametr je typu „{baseType}“, parametr přepsání je typu „{overrideType}“",
        "overrideParamName": "Neshoda názvu parametru {index}: základní parametr má název „{baseName}“, parametr přepsání má název „{overrideName}“",
        "overrideParamNameExtra": "V základu chybí parametr {name}",
        "overrideParamNameMissing": "V přepsání chybí parametr „{name}“",
        "overrideParamNamePositionOnly": "Neshoda parametru {index}: základní parametr {baseName} je parametr klíčového slova, přepisující parametr je pouze pozice",
        "overrideParamNoDefault": "Neshoda parametru {index}: Základní parametr má výchozí hodnotu argumentu, parametr přepsání se neshoduje.",
        "overrideParamType": "Neshoda typu parametru {index}: Základní parametr je typu „{baseType}“, parametr přepsání je typu „{overrideType}“.",
        "overridePositionalParamCount": "Neshoda počtu pozičních parametrů; Základní metoda má „{baseCount}“, ale přepsání má {overrideCount}",
        "overrideReturnType": "Neshoda návratového typu: Základní metoda vrací typ {baseType}, přepsání vrací typ {overrideType}",
        "overrideType": "Základní třída definuje typ jako {type}",
        "paramAssignment": "Parametr {index}: typ {sourceType} není kompatibilní s typem {destType}.",
        "paramSpecMissingInOverride": "V metodě přepsání chybí parametry ParamSpec",
        "paramType": "Typ parametru je {paramType}",
        "privateImportFromPyTypedSource": "Místo toho importovat z modulu {module}",
        "propertyAccessFromProtocolClass": "Vlastnost definovaná v rámci třídy protokolu není přístupná jako proměnná třídy",
        "propertyMethodIncompatible": "Metoda vlastnosti (property) {name} není kompatibilní.",
        "propertyMethodMissing": "V přepsání (override) chybí metoda vlastnosti (property) „{name}“.",
        "propertyMissingDeleter": "Vlastnost (property) {name} nemá definovanou metodu deleter.",
        "propertyMissingSetter": "Vlastnost (property) {name} nemá definovanou metodu setter.",
        "protocolIncompatible": "{sourceType} není kompatibilní s protokolem {destType}",
        "protocolMemberMissing": "{name} není k dispozici",
        "protocolRequiresRuntimeCheckable": "Třída Protocol musí být @runtime_checkable, aby se použila při kontrolách instancí a tříd.",
        "protocolSourceIsNotConcrete": "„{sourceType}“ není konkrétní typ třídy a nedá se přiřadit k typu „{destType}“",
        "protocolUnsafeOverlap": "Atributy „{name}“ mají stejné názvy jako protokol.",
        "pyrightCommentIgnoreTip": "Pokud chcete potlačit diagnostiku pro jeden řádek, použijte # pyright: ignore[<diagnostic rules>]",
        "readOnlyAttribute": "Atribut {name} je jen pro čtení",
        "seeClassDeclaration": "Viz deklarace třídy",
        "seeDeclaration": "Viz deklarace",
        "seeFunctionDeclaration": "Viz deklarace funkce",
        "seeMethodDeclaration": "Viz deklarace metody",
        "seeParameterDeclaration": "Viz deklarace parametru",
        "seeTypeAliasDeclaration": "Zobrazit deklaraci aliasu typu",
        "seeVariableDeclaration": "Zobrazit deklaraci proměnné",
        "tupleAssignmentMismatch": "Typ „{type}“ není kompatibilní s cílovou řazenou kolekcí členů (tuple).",
        "tupleEntryTypeMismatch": "Položka řazené kolekce členů (tuple) {entry} je nesprávného typu.",
        "tupleSizeIndeterminateSrc": "Neshoda velikosti řazené kolekce členů (tuple); očekávalo se {expected}, ale přijalo se neurčité.",
        "tupleSizeIndeterminateSrcDest": "Neshoda velikosti řazené kolekce členů (tuple); očekávalo se min. {expected}, ale přijalo se neurčité.",
        "tupleSizeMismatch": "Neshoda velikosti řazené kolekce členů (tuple); očekávalo se {expected}, ale přijalo se {received}.",
        "tupleSizeMismatchIndeterminateDest": "Neshoda velikosti řazené kolekce členů (tuple); Očekávalo se {expected}, ale přijalo se {received}.",
        "typeAliasInstanceCheck": "Alias typu vytvořený pomocí příkazu „type“ se nedá použít s kontrolami instancí a tříd.",
        "typeAssignmentMismatch": "Typ {sourceType} se nedá přiřadit k typu {destType}.",
        "typeBound": "Typ {sourceType} se nedá přiřadit k horní hranici {destType} pro proměnnou typu {name}.",
        "typeConstrainedTypeVar": "Typ {type} se nedá přiřadit k proměnné omezeného typu {name}.",
        "typeIncompatible": "{sourceType} se nedá přiřadit k {destType}.",
        "typeNotClass": "{type} není třída",
        "typeNotStringLiteral": "„{type}“ není řetězcový literál",
        "typeOfSymbol": "Typ „{name}“ je „{type}“",
        "typeParamSpec": "Typ {type} není kompatibilní s parametrem ParamSpec {name}",
        "typeUnsupported": "Typ {type} není podporován",
        "typeVarDefaultOutOfScope": "Proměnná typu {name} není v oboru",
        "typeVarIsContravariant": "Parametr typu „{name}“ je kontravariantní, ale „{sourceType}“ není nadtyp „{destType}“.",
        "typeVarIsCovariant": "Parametr typu „{name}“ je kovariantní, ale „{sourceType}“ není podtyp „{destType}“.",
        "typeVarIsInvariant": "Parametr typu „{name}“ je invariantní, ale „{sourceType}“ není stejný jako „{destType}“.",
        "typeVarNotAllowed": "TypeVar se pro kontroly instancí nebo tříd nepovoluje.",
        "typeVarTupleRequiresKnownLength": "Typ TypeVarTuple nemůže být vázaný na řazenou kolekci členů (tuple) neznámé délky.",
        "typeVarUnnecessarySuggestion": "Místo toho použijte {type}.",
        "typeVarUnsolvableRemedy": "Zadejte přetížení, které určuje návratový typ, pokud argument není zadán",
        "typeVarsMissing": "Chybějící proměnné typu: {names}",
        "typedDictBaseClass": "Třída „{type}“ není TypedDict.",
        "typedDictClassNotAllowed": "Třída TypedDict není povolená pro kontroly instancí nebo tříd.",
        "typedDictClosedExtraNotAllowed": "Do {name} nejde přidat položku.",
        "typedDictClosedExtraTypeMismatch": "Nelze přidat položku {name} s typem {type}.",
        "typedDictClosedFieldNotRequired": "Nelze přidat položku {name}, protože musí být NotRequired.",
        "typedDictExtraFieldNotAllowed": "{name} není k dispozici v {type}",
        "typedDictExtraFieldTypeMismatch": "Typ {name} není kompatibilní s typem „extra_items“ v typu {type}.",
        "typedDictFieldMissing": "V {type} chybí {name}",
        "typedDictFieldNotReadOnly": "{name} není v {type} jen pro čtení",
        "typedDictFieldNotRequired": "{name} se v typu {type} nevyžaduje",
        "typedDictFieldRequired": "{name} se vyžaduje v {type}",
        "typedDictFieldTypeMismatch": "Typ {type} se nedá přiřadit k položce {name}",
        "typedDictFieldUndefined": "{name} je nedefinovaná položka v typu {type}",
        "typedDictKeyAccess": "Použít [\"{name}\"] k odkazování na položku v TypedDict",
        "typedDictNotAllowed": "TypedDict se nedá použít pro kontroly instancí nebo tříd.",
        "unhashableType": "Typ „{type}“ nejde zatřiďovat",
        "uninitializedAbstractVariable": "Proměnná instance {name} je definovaná v abstraktní základní třídě {classType}, ale neinicializovala se",
        "unreachableExcept": "{exceptionType} je podtřídou {parentType}",
        "useDictInstead": "Označte typ slovníku pomocí dict[T1, T2]",
        "useListInstead": "Použijte list[T] k označení typu seznamu (list) nebo T1 | T2 k označení typu sjednocení (union).",
        "useTupleInstead": "Použijte tuple[T1, ..., Tn] k označení typu řazené kolekce členů (tuple) nebo T1 | T2 k označení typu sjednocení (union).",
        "useTypeInstead": "Místo toho použít type[T]",
        "varianceMismatchForClass": "Odchylka argumentu typu „{typeVarName}“ není kompatibilní se základní třídou „{className}“",
        "varianceMismatchForTypeAlias": "Rozptyl argumentu typu „{typeVarName}“ není kompatibilní s typem „{typeAliasParam}“"
    },
    "Service": {
        "longOperation": "Výčet zdrojových souborů pracovního prostoru trvá dlouho. Zvažte raději otevření podsložky. [Další informace](https://aka.ms/workspace-too-many-files)"
    }
}
