{
    "CodeAction": {
        "createTypeStub": "Vytvořit zástupná procedura typu",
        "createTypeStubFor": "Vytvořit zástupnou proceduru typu pro modul {moduleName}",
        "executingCommand": "Spouští se příkaz",
        "filesToAnalyzeCount": "Počet souborů k analýze: {count}",
        "filesToAnalyzeOne": "1 soubor k analýze",
        "findingReferences": "Hledají se odkazy",
        "organizeImports": "Uspořádat direktivy Import",
        "renameShadowedFile": "Přejmenovat „{oldFile}“ na „{newFile}“"
    },
    "Completion": {
        "autoImportDetail": "Automatický import",
        "indexValueDetail": "Hodnota indexu"
    },
    "Diagnostic": {
        "abstractMethodInvocation": "Metodu „{method}“ nelze volat, protože je abstraktní a neimplementovaná.",
        "annotatedParamCountMismatch": "Počet poznámek parametrů se neshoduje: očekával(o/y) se {expected}, ale přijal(o/y) se {received}.",
        "annotatedTypeArgMissing": "Byl očekáván jeden argument typu a jedna nebo více poznámek pro Annotated",
        "annotationFormatString": "Poznámky typu nemůžou používat formátovací řetězcové literály (f-strings)",
        "annotationNotSupported": "Poznámka typu není pro tento příkaz podporována",
        "annotationSpansStrings": "Poznámky typu nemůžou zahrnovat více řetězcových literálů",
        "annotationStringEscape": "Poznámky typu nemůžou obsahovat řídicí znaky",
        "argAssignment": "Argument typu {argType} není možné přiřadit k parametru typu {paramType}",
        "argAssignmentFunction": "Argument typu {argType} není možné přiřadit k parametru typu {paramType} ve funkci {functionName}",
        "argAssignmentParam": "Argument typu {argType} není možné přiřadit k parametru {paramName} typu {paramType}",
        "argAssignmentParamFunction": "Argument typu {argType} není možné přiřadit k parametru {paramName} typu {paramType} ve funkci {functionName}",
        "argMissingForParam": "Chybí argument pro parametr {name}",
        "argMissingForParams": "Chybí argumenty pro parametry {names}",
        "argMorePositionalExpectedCount": "Očekával se tento počet dalších pozičních argumentů: {expected}",
        "argMorePositionalExpectedOne": "Očekával se 1 další poziční argument",
        "argPositional": "Očekávaný poziční argument",
        "argPositionalExpectedCount": "Očekávaný počet pozičních argumentů: {expected}",
        "argPositionalExpectedOne": "Očekával se 1 poziční argument",
        "argTypePartiallyUnknown": "Typ argumentu je částečně neznámý",
        "argTypeUnknown": "Typ argumentu je neznámý",
        "assertAlwaysTrue": "Výraz Assert se vždy vyhodnotí jako true",
        "assertTypeArgs": "assert_type očekává dva poziční argumenty",
        "assertTypeTypeMismatch": "Neshoda assert_type: očekávalo se {expected}, ale přijalo se {received}",
        "assignmentExprComprehension": "Cíl výrazu přiřazení „{name}“ nemůže používat stejný název jako porozumění cíli",
        "assignmentExprContext": "Výraz přiřazení musí být uvnitř modulu, funkce nebo výrazu lambda",
        "assignmentExprInSubscript": "Výrazy přiřazení v dolním indexu se podporují jenom v Pythonu 3.10 a novějším",
        "assignmentInProtocol": "Proměnné instance nebo třídy v rámci třídy Protocol musí být explicitně deklarovány v těle třídy",
        "assignmentTargetExpr": "Výraz nemůže být cílem přiřazení",
        "asyncNotInAsyncFunction": "Použití „async“ není povolené mimo funkci async",
        "awaitIllegal": "Použití operátoru await vyžaduje Python 3.5 nebo novější",
        "awaitNotAllowed": "Poznámky typu nemůžou používat „await“.",
        "awaitNotInAsync": "Operátor await je povolený jenom v rámci asynchronní funkce",
        "backticksIllegal": "V Pythonu 3.x nejsou podporovány výrazy obklopené zpětnými tečkami; místo toho použijte repr",
        "baseClassCircular": "Třída se nemůže odvozovat od sebe sama",
        "baseClassFinal": "Základní třída {type} je označená jako final a nemůže být podtřídou",
        "baseClassIncompatible": "Základní třídy typu {type} jsou vzájemně nekompatibilní",
        "baseClassInvalid": "Argument třídy musí být základní třída",
        "baseClassMethodTypeIncompatible": "Základní třídy pro třídu {classType} definují metodu {name} nekompatibilním způsobem",
        "baseClassUnknown": "Typ základní třídy je neznámý, co zakrývá typ odvozené třídy",
        "baseClassVariableTypeIncompatible": "Základní třídy pro třídu {classType} definují proměnnou {name} nekompatibilním způsobem",
        "binaryOperationNotAllowed": "Binární operátor není v poznámce typu povolený",
        "bindTypeMismatch": "Nepovedlo se vytvořit vazbu metody „{methodName}“, protože „{type}“ nejde přiřadit k parametru „{paramName}“",
        "breakOutsideLoop": "„break“ se dá použít jenom ve smyčce",
        "callableExtraArgs": "Pro Callable se očekávaly pouze dva argumenty typu",
        "callableFirstArg": "Očekával se seznam typů parametrů nebo ...",
        "callableNotInstantiable": "Není možné vytvořit instanci typu {type}",
        "callableSecondArg": "Očekával se návratový typ jako druhý argument typu pro Callable",
        "casePatternIsIrrefutable": "Nevyvratitelný vzorec je povolený jenom pro poslední výraz velikosti písmen",
        "classAlreadySpecialized": "Typ {type} je už specializovaný",
        "classDecoratorTypeUnknown": "Dekoratér netypové třídy překrývá typ třídy. dekoratér se ignoruje",
        "classDefinitionCycle": "Definice třídy pro „{name}“ závisí sama na sobě",
        "classGetItemClsParam": "Přepsání __class_getitem__ by mělo mít parametr cls",
        "classMethodClsParam": "Metody třídy by měly mít parametr „cls“",
        "classNotRuntimeSubscriptable": "Dolní index pro třídu {name} vygeneruje výjimku modulu runtime; anotaci typu uzavřete do uvozovek",
        "classPatternBuiltInArgPositional": "Vzor třídy přijímá pouze poziční dílčí vzor",
        "classPatternPositionalArgCount": "Příliš mnoho pozičních vzorů pro třídu \"{type}\"; očekávalo se {expected}, ale přijalo se {received}",
        "classPatternTypeAlias": "Typ „{type}“ nelze použít ve vzorci třídy, protože se jedná o specializovaný alias typu",
        "classPropertyDeprecated": "Vlastnosti třídy jsou v Pythonu 3.11 zastaralé a v Pythonu 3.13 se nebudou podporovat.",
        "classTypeParametersIllegal": "Syntaxe parametru typu třídy vyžaduje Python 312 nebo novější",
        "classVarFirstArgMissing": "Za ClassVar byl očekáván argument typu",
        "classVarNotAllowed": "ClassVar se v tomto kontextu nepovoluje",
        "classVarOverridesInstanceVar": "Proměnná třídy {name} přepíše proměnnou instance se stejným názvem ve třídě {className}",
        "classVarTooManyArgs": "Za „ClassVar“ byl očekáván pouze jeden argument typu",
        "classVarWithTypeVar": "Typ ClassVar nemůže obsahovat proměnné typu",
        "clsSelfParamTypeMismatch": "Typ parametru „{name}“ musí být nadtyp třídy „{classType}“",
        "codeTooComplexToAnalyze": "Kód je příliš složitý na analýzu; snižte složitost refaktorizací do podprogramů nebo redukcí podmíněných cest kódu",
        "collectionAliasInstantiation": "Nelze vytvořit instanci typu „{type}“. Použijte místo toho „{alias}“",
        "comparisonAlwaysFalse": "Podmínka se vždy vyhodnotí jako False, protože typy {leftType} a {rightType} se nepřekrývají",
        "comparisonAlwaysTrue": "Podmínka se vždy vyhodnotí jako True, protože typy {leftType} a {rightType} se nepřekrývají",
        "comprehensionInDict": "Porozumění není možné použít s jinými položkami slovníku",
        "comprehensionInSet": "Porozumění nelze použít s jinými položkami sady",
        "concatenateContext": "Možnost „Concatenate“ není v tomto kontextu povolená.",
        "concatenateParamSpecMissing": "Poslední argument typu pro „Concatenate“ musí být „ParamSpec“ nebo „...“",
        "concatenateTypeArgsMissing": "Možnost „Concatenate“ vyžaduje alespoň dva argumenty typu",
        "conditionalOperandInvalid": "Neplatný podmíněný operand typu {type}",
        "constantRedefinition": "„{name}“ je konstanta (protože je velkými písmeny) a nedá se předefinovat",
        "constructorNoArgs": "Pro konstruktor {type} nebyly očekávány žádné argumenty",
        "constructorParametersMismatch": "Neshoda mezi signaturou __new__ a __init__ ve třídě“ {classType}“",
        "containmentAlwaysFalse": "Výraz se vždy vyhodnotí jako False, protože typy „{leftType}“ a „{rightType}“ se nepřekrývají",
        "containmentAlwaysTrue": "Výraz se vždy vyhodnotí jako True, protože typy „{leftType}“ a „{rightType}“ se nepřekrývají.",
        "continueInFinally": "continue není možné použít v klauzuli finally",
        "continueOutsideLoop": "continue se dá použít jenom ve smyčce",
        "coroutineInConditionalExpression": "Podmíněný výraz odkazuje na korutinu, která se vždy vyhodnotí jako True.",
        "dataClassBaseClassFrozen": "Nezablokovaná třída nemůže dědit z zmrazené třídy",
        "dataClassBaseClassNotFrozen": "Zablokovaná třída nemůže dědit z třídy, která není zablokovaná",
        "dataClassConverterFunction": "Argument typu {argType} není platný převaděč pro pole {fieldName} typu {fieldType}",
        "dataClassConverterOverloads": "Žádná přetížení {funcName} nejsou platné převaděče pro pole {fieldName} typu {fieldType}",
        "dataClassFieldWithDefault": "Pole bez výchozích hodnot se nemůžou zobrazit po polích s výchozími hodnotami",
        "dataClassFieldWithPrivateName": "Pole datové třídy nemůže používat privátní název",
        "dataClassFieldWithoutAnnotation": "Pole dataclass bez poznámky typu způsobí výjimku modulu runtime",
        "dataClassPostInitParamCount": "Datová třída __post_init__ má nesprávný počet parametrů; počet polí InitVar je {expected}",
        "dataClassPostInitType": "Neshoda typu parametru metody __post_init__ datové třídy pro pole {fieldName}",
        "dataClassSlotsOverwrite": "__slots__ je už ve třídě definovaný",
        "dataClassTransformExpectedBoolLiteral": "Očekával se výraz, který se staticky vyhodnotí jako True nebo False",
        "dataClassTransformFieldSpecifier": "Očekávala se řazená kolekce členů tříd nebo funkcí, ale přijatý typ „{type}“",
        "dataClassTransformPositionalParam": "Všechny argumenty dataclass_transform musí být argumenty klíčových slov",
        "dataClassTransformUnknownArgument": "Argument {name} není v dataclass_transform podporován",
        "dataProtocolInSubclassCheck": "Datové protokoly (které zahrnují atributy bez metody) nejsou ve voláních issubclass povolené.",
        "declaredReturnTypePartiallyUnknown": "Deklarovaný návratový typ {returnType} je částečně neznámý",
        "declaredReturnTypeUnknown": "Deklarovaný návratový typ je neznámý",
        "defaultValueContainsCall": "Volání funkcí a měnitelné objekty nejsou povoleny ve výrazu výchozí hodnoty parametru",
        "defaultValueNotAllowed": "Parametr s * nebo ** nemůže mít výchozí hodnotu",
        "delTargetExpr": "Výraz se nedá odstranit",
        "deprecatedClass": "Třída {name} je zastaralá",
        "deprecatedConstructor": "Konstruktor pro třídu {name} je zastaralý",
        "deprecatedDescriptorDeleter": "Metoda „__delete__“ pro popisovač „{name}“ je zastaralá",
        "deprecatedDescriptorGetter": "Metoda „__get__“ pro popisovač „{name}“ je zastaralá",
        "deprecatedDescriptorSetter": "Metoda „__set__“ pro popisovač „{name}“ je zastaralá",
        "deprecatedFunction": "Funkce {name} je zastaralá.",
        "deprecatedMethod": "Metoda {name} ve třídě {className} je zastaralá.",
        "deprecatedPropertyDeleter": "Odstraňovač pro vlastnost „{name}“ je zastaralý",
        "deprecatedPropertyGetter": "Metoda getter pro vlastnost „{name}“ je zastaralá",
        "deprecatedPropertySetter": "Metoda setter pro vlastnost „{name}“ je zastaralá",
        "deprecatedType": "Tento typ je zastaralý jako Python {version}; místo toho použijte {replacement}",
        "dictExpandIllegalInComprehension": "Rozšíření slovníku není v porozumění povoleno",
        "dictInAnnotation": "Výraz slovníku není v poznámce typu povolený",
        "dictKeyValuePairs": "Položky slovníku musí obsahovat páry klíč/hodnota",
        "dictUnpackIsNotMapping": "Očekávalo se mapování pro operátor rozbalení slovníku",
        "dunderAllSymbolNotPresent": "{name} je zadáno v __all__, ale v modulu se nenachází",
        "duplicateArgsParam": "Je povolený jenom jeden parametr *",
        "duplicateBaseClass": "Duplicitní základní třída není povolena",
        "duplicateCapturePatternTarget": "Cíl zachytávání {name} se v rámci stejného vzoru nemůže vyskytovat více než jednou",
        "duplicateCatchAll": "Je povolena pouze jedna klauzule catch-all except",
        "duplicateEnumMember": "Člen výčtu {name} je už deklarovaný",
        "duplicateGenericAndProtocolBase": "Je povolena pouze jedna základní třída Generic nebo Protocol**",
        "duplicateImport": "Import {importName} je importován více než jednou",
        "duplicateKeywordOnly": "Je povolený jenom jeden oddělovač *",
        "duplicateKwargsParam": "Je povolený jenom jeden parametr **",
        "duplicateParam": "duplicitní parametr {name}",
        "duplicatePositionOnly": "Je povolený jenom jeden parametr „/“",
        "duplicateStarPattern": "V sekvenci vzorů je povolený jenom jeden vzor „*“",
        "duplicateStarStarPattern": "Je povolena pouze jedna položka „**“",
        "duplicateUnpack": "V seznamu je povolena pouze jedna operace rozbalení",
        "ellipsisAfterUnpacked": "„…“ nelze použít s rozbalenou kolekcí TypeVarTuple nebo řazenou kolekcí členů.",
        "ellipsisContext": "„...“ se v tomto kontextu nepovoluje",
        "ellipsisSecondArg": "„...“ je povoleno pouze jako druhý ze dvou argumentů",
        "enumClassOverride": "Třída výčtu {name} je konečná a nemůže být podtřídou",
        "exceptionGroupIncompatible": "Syntaxe skupiny výjimek (except*) vyžaduje Python 3.11 nebo novější",
        "exceptionTypeIncorrect": "„{type}“ se neodvozuje od BaseException",
        "exceptionTypeNotClass": "{type} není platná třída výjimky",
        "exceptionTypeNotInstantiable": "Konstruktor pro výjimku typu {type} vyžaduje jeden nebo více argumentů",
        "expectedAfterDecorator": "Očekávaná deklarace funkce nebo třídy po dekoratéru",
        "expectedArrow": "Byl očekáván znak -> následovaný anotací návratového typu",
        "expectedAsAfterException": "Za typem výjimky byl očekáván znak „as“",
        "expectedAssignRightHandExpr": "Byl očekáván výraz napravo od znaku =",
        "expectedBinaryRightHandExpr": "Očekával se výraz napravo od operátoru",
        "expectedBoolLiteral": "Očekávala se hodnota True nebo False",
        "expectedCase": "Očekával se příkaz case",
        "expectedClassName": "Očekával se název třídy",
        "expectedCloseBrace": "{ nebyla uzavřena",
        "expectedCloseBracket": "[ nebyla uzavřena",
        "expectedCloseParen": "( nebyla uzavřena",
        "expectedColon": "Očekával se znak :",
        "expectedComplexNumberLiteral": "Očekával se komplexní číselný literál pro porovnávání vzorů",
        "expectedDecoratorExpr": "Forma výrazu není podporována pro dekorátor před verzí Python 3.9",
        "expectedDecoratorName": "Očekával se název dekoratéru",
        "expectedDecoratorNewline": "Na konci dekoratéru byl očekáván nový řádek",
        "expectedDelExpr": "Za del se očekával výraz",
        "expectedElse": "Očekávalo se else",
        "expectedEquals": "Očekával se znak =",
        "expectedExceptionClass": "Neplatná třída nebo objekt výjimky",
        "expectedExceptionObj": "Byl očekáván objekt výjimky, třída výjimky nebo None",
        "expectedExpr": "Očekávaný výraz",
        "expectedFunctionAfterAsync": "Očekávaná definice funkce po „async“",
        "expectedFunctionName": "Za def se očekával název funkce",
        "expectedIdentifier": "Očekávaný identifikátor",
        "expectedImport": "Očekával se import",
        "expectedImportAlias": "Za as byl očekáván symbol",
        "expectedImportSymbols": "Po importu se očekával jeden nebo více názvů symbolů",
        "expectedIn": "Očekávalo se in",
        "expectedInExpr": "Za in byl očekáván výraz",
        "expectedIndentedBlock": "Očekával se odsazený blok",
        "expectedMemberName": "Za znakem . byl očekáván název člena",
        "expectedModuleName": "Očekávaný název modulu",
        "expectedNameAfterAs": "Za „as“ se očekával název symbolu",
        "expectedNamedParameter": "Parametr klíčového slova musí následovat za znakem *",
        "expectedNewline": "Očekával se nový řádek",
        "expectedNewlineOrSemicolon": "Příkazy musí být oddělené novými řádky nebo středníky",
        "expectedOpenParen": "Očekával se znak „(“",
        "expectedParamName": "Očekával se název parametru",
        "expectedPatternExpr": "Očekávaný výraz vzoru",
        "expectedPatternSubjectExpr": "Očekávaný výraz předmětu vzoru",
        "expectedPatternValue": "Očekávaný výraz hodnoty vzoru ve formátu a.b",
        "expectedReturnExpr": "Za return se očekával výraz",
        "expectedSliceIndex": "Očekávaný výraz indexu nebo řezu",
        "expectedTypeNotString": "Očekával se typ, ale přijal se řetězcový literál",
        "expectedTypeParameterName": "Očekávaný název parametru typu",
        "expectedYieldExpr": "Očekávaný výraz v příkazu yield",
        "finalClassIsAbstract": "Třída „{type}“ je označená jako konečná a musí implementovat všechny abstraktní symboly",
        "finalContext": "Final se v tomto kontextu nepovoluje",
        "finalMethodOverride": "Metoda {name} nemůže přepsat konečnou metodu definovanou ve třídě {className}",
        "finalNonMethod": "Funkci „{name}“ nelze označit @final, protože se nejedná o metodu.",
        "finalReassigned": "„{name}“ se deklaruje jako Final a nedá se znovu přiřadit",
        "finalRedeclaration": "{name} se dříve deklarovalo jako Final",
        "finalRedeclarationBySubclass": "{name} se nedá deklarovat znovu, protože nadřazená třída {className} ji deklaruje jako final",
        "finalTooManyArgs": "Za Final byl očekáván jeden argument typu",
        "finalUnassigned": "{name} se deklaruje jako final, ale hodnota není přiřazená",
        "formatStringBrace": "Jednoduchá pravá složená závorka není v literálu f-string povolena. použijte dvojitou pravou složenou závorku",
        "formatStringBytes": "Formátovací řetězcové literály (f-strings) nemůžou být binární",
        "formatStringDebuggingIllegal": "Specifikátor ladění F-string „=“ vyžaduje Python 3.8 nebo novější",
        "formatStringEscape": "Řídicí sekvence (zpětné lomítko) není povolená v části výrazu f-string před Python 3.12",
        "formatStringExpectedConversion": "V řetězci f-string byl za znakem ! očekáván specifikátor převodu",
        "formatStringIllegal": "Formátovací řetězcové literály (f-string) vyžadují Python 3.6 nebo novější",
        "formatStringInPattern": "Formátovací řetězec není ve vzoru povolený",
        "formatStringNestedFormatSpecifier": "Příliš hluboko vnořené výrazy v rámci specifikátoru formátovacího řetězce",
        "formatStringNestedQuote": "Řetězce vnořené v řetězci f-string nemůžou používat stejný znak uvozovek jako řetězec f-string před Python 3.12",
        "formatStringUnicode": "Formátovací řetězcové literály (f-strings) nemůžou být unicode",
        "formatStringUnterminated": "Neukončený výraz v f-string; očekává se „}“",
        "functionDecoratorTypeUnknown": "Dekorátor netypové funkce překrývá typ funkce; ignoruje se dekoratér",
        "functionInConditionalExpression": "Podmíněný výraz odkazuje na funkci, která se vždy vyhodnotí jako True",
        "functionTypeParametersIllegal": "Syntaxe parametru typu funkce vyžaduje Python 3.12 nebo novější",
        "futureImportLocationNotAllowed": "Importy z __future__ musí být na začátku souboru",
        "generatorAsyncReturnType": "Návratový typ funkce asynchronního generátoru musí být kompatibilní s typem AsyncGenerator[{yieldType}, Any]",
        "generatorNotParenthesized": "Výrazy generátoru musí být v závorkách, pokud nejsou jediným argumentem",
        "generatorSyncReturnType": "Návratový typ funkce generátoru musí být kompatibilní s Generator[{yieldType}, Any, Any]",
        "genericBaseClassNotAllowed": "Základní třídu „Generic“ nejde použít se syntaxí parametru typu",
        "genericClassAssigned": "Obecný typ třídy není možné přiřadit",
        "genericClassDeleted": "Obecný typ třídy nelze odstranit",
        "genericInstanceVariableAccess": "Přístup k obecné proměnné instance prostřednictvím třídy je nejednoznačný.",
        "genericNotAllowed": "Generic není v tomto kontextu platný",
        "genericTypeAliasBoundTypeVar": "Alias obecného typu v rámci třídy nemůže používat proměnné vázaného typu {names}",
        "genericTypeArgMissing": "Generic vyžaduje alespoň jeden argument typu",
        "genericTypeArgTypeVar": "Argument typu pro Generic musí být proměnná typu",
        "genericTypeArgUnique": "Argumenty typu pro Generic musí být jedinečné",
        "globalReassignment": "{name} je přiřazen před globální deklarací",
        "globalRedefinition": "Název {name} už je deklarován jako globální",
        "implicitStringConcat": "Implicitní zřetězení řetězců není povolené",
        "importCycleDetected": "V řetězci importu byl zjištěn cyklus",
        "importDepthExceeded": "Hloubka řetězu importu překročila {depth}",
        "importResolveFailure": "Import {importName} se nepovedlo vyřešit",
        "importSourceResolveFailure": "Import {importName} se nepovedlo přeložit ze zdroje",
        "importSymbolUnknown": "{name} je neznámý symbol importu",
        "incompatibleMethodOverride": "Metoda {name} přepisuje třídu {className} nekompatibilním způsobem",
        "inconsistentIndent": "Množství zrušeného odsazení neodpovídá předchozímu odsazení",
        "inconsistentTabs": "Nekonzistentní použití tabulátorů a mezer v odsazení",
        "initMustReturnNone": "Návratový typ __init__ musí být None",
        "initSubclassCallFailed": "Nesprávné argumenty klíčového slova pro metodu __init_subclass__",
        "initSubclassClsParam": "Přepsání __init_subclass__ by mělo mít parametr cls",
        "initVarNotAllowed": "InitVar se v tomto kontextu nepovoluje.",
        "instanceMethodSelfParam": "Metody instance by měly mít parametr self",
        "instanceVarOverridesClassVar": "Proměnná instance „{name}“ přepíše proměnnou třídy se stejným názvem ve třídě „{className}“",
        "instantiateAbstract": "Nelze vytvořit instanci abstraktní třídy „{type}“",
        "instantiateProtocol": "Nelze vytvořit instanci třídy protokolu „{type}“",
        "internalBindError": "Při vytváření vazby souboru {file} došlo k vnitřní chybě: {message}",
        "internalParseError": "Při analýze souboru {file} došlo k vnitřní chybě: {message}",
        "internalTypeCheckingError": "Při kontrole typu souboru {file} došlo k vnitřní chybě: {message}",
        "invalidIdentifierChar": "Neplatný znak v identifikátoru",
        "invalidStubStatement": "Příkaz je v souboru zástupné procedury typu bezvýznamný",
        "invalidTokenChars": "Neplatný znak „{text}“ v tokenu",
        "isInstanceInvalidType": "Druhý argument pro „isinstance“ musí být třída nebo řazená kolekce členů tříd",
        "isSubclassInvalidType": "Druhý argument pro issubclass musí být třída nebo řazená kolekce členů tříd",
        "keyValueInSet": "Páry klíč-hodnota nejsou v rámci sady povoleny",
        "keywordArgInTypeArgument": "Argumenty klíčových slov nelze použít v seznamech argumentů typu",
        "keywordOnlyAfterArgs": "Oddělovač argumentů jen pro klíčová slova není povolený za parametrem *",
        "keywordParameterMissing": "Jeden nebo více parametrů klíčového slova musí následovat za parametrem „*“",
        "keywordSubscriptIllegal": "Argumenty klíčových slov v dolních indexech nejsou podporovány",
        "lambdaReturnTypePartiallyUnknown": "Návratový typ lambda {returnType} je částečně neznámý",
        "lambdaReturnTypeUnknown": "Návratový typ výrazu lambda je neznámý",
        "listAssignmentMismatch": "Výraz s typem {type} se nedá přiřadit k cílovému seznamu",
        "listInAnnotation": "Výraz seznamu není v poznámce typu povolený",
        "literalEmptyArgs": "Za literálem se očekával jeden nebo více argumentů typu",
        "literalNotAllowed": "„Literal“ nejde v tomto kontextu použít bez argumentu typu.",
        "literalNotCallable": "Není možné vytvořit instanci typu literálu",
        "literalUnsupportedType": "Argumenty typu pro Literal musí být None, hodnota literálu (int, bool, str nebo bytes) nebo hodnota výčtu",
        "matchIncompatible": "Příkazy match vyžadují Python 3.10 nebo novější",
        "matchIsNotExhaustive": "Případy v rámci příkazu match nezpracovávají kompletně všechny hodnoty",
        "maxParseDepthExceeded": "Byla překročena maximální hloubka analýzy; rozdělte výraz na dílčí výrazy",
        "memberAccess": "Není možné získat přístup ke členu {name} pro typ {type}",
        "memberDelete": "Není možné odstranit člena {name} pro typ {type}",
        "memberSet": "Nelze přiřadit člena „{name}“ pro typ „{type}“",
        "metaclassConflict": "Metatřída odvozené třídy musí být podtřídou metatříd všech jejích základních tříd",
        "metaclassDuplicate": "Je možné zadat pouze jednu metatřídu",
        "metaclassIsGeneric": "Metatřída nemůže být obecná",
        "methodNotDefined": "Metoda {name} není definována",
        "methodNotDefinedOnType": "Metoda {name} není u typu {type} definována",
        "methodOrdering": "Není možné vytvořit konzistentní řazení metod",
        "methodOverridden": "„{name}“ přepisuje metodu se stejným názvem ve třídě „{className}“ s nekompatibilním typem {type}",
        "methodReturnsNonObject": "Metoda {name} nevrací objekt",
        "missingSuperCall": "Metoda {methodName} nevolá metodu se stejným názvem v nadřazené třídě",
        "moduleAsType": "Modul nejde použít jako typ",
        "moduleNotCallable": "Modul není volatelný",
        "moduleUnknownMember": "Člen „{memberName}“ není známým členem modulu „{moduleName}“",
        "namedExceptAfterCatchAll": "Za klauzulí catch-all except se nemůže objevit pojmenovaná klauzule except",
        "namedParamAfterParamSpecArgs": "Parametr klíčového slova {name} se nemůže objevit v signatuře za parametrem argumentů ParamSpec",
        "namedTupleEmptyName": "Názvy v pojmenované řazené kolekci členů nemůžou být prázdné.",
        "namedTupleEntryRedeclared": "{name} nejde přepsat, protože nadřazená třída {className} je pojmenovaná řazená kolekce členů.",
        "namedTupleFirstArg": "Jako první argument byl očekáván název pojmenované třídy řazené kolekce členů",
        "namedTupleMultipleInheritance": "Vícenásobná dědičnost s NamedTuple se nepodporuje",
        "namedTupleNameKeyword": "Názvy polí nemůžou být klíčové slovo.",
        "namedTupleNameType": "Očekávala se řazená kolekce členů se dvěma položkami určující název a typ položky",
        "namedTupleNameUnique": "Názvy v pojmenované řazené kolekci členů musí být jedinečné",
        "namedTupleNoTypes": "namedtuple neposkytuje žádné typy pro položky řazené kolekce členů; místo toho použijte NamedTuple",
        "namedTupleSecondArg": "Jako druhý argument byl očekáván pojmenovaný seznam řazené kolekce členů",
        "newClsParam": "Přepsání __new__ by mělo mít parametr cls",
        "newTypeAnyOrUnknown": "Druhý argument pro NewType musí být známá třída, nikoli Any nebo Unknown.",
        "newTypeBadName": "Prvním argumentem pro NewType musí být řetězcový literál",
        "newTypeLiteral": "Typ NewType není možné použít s typem Literal",
        "newTypeNameMismatch": "Typ NewType musí být přiřazen proměnné se stejným názvem.",
        "newTypeNotAClass": "Očekávaná třída jako druhý argument pro NewType",
        "newTypeParamCount": "NewType vyžaduje dva poziční argumenty",
        "newTypeProtocolClass": "NewType nelze použít se strukturálním typem (protokol nebo třída TypedDict).",
        "noOverload": "Zadaným argumentům neodpovídají žádná přetížení pro {name}",
        "noReturnContainsReturn": "Funkce s deklarovaným návratovým typem NoReturn nemůže obsahovat příkaz return",
        "noReturnContainsYield": "Funkce s deklarovaným návratovým typem NoReturn nemůže obsahovat příkaz yield",
        "noReturnReturnsNone": "Funkce s deklarovaným návratovým typem „NoReturn“ nemůže vrátit „None“.",
        "nonDefaultAfterDefault": "Nevýchozí argument následuje za výchozím argumentem",
        "nonLocalInModule": "Nemístní deklarace není povolená na úrovni modulu",
        "nonLocalNoBinding": "Nenašla se žádná vazba pro nemístní {name}",
        "nonLocalReassignment": "{name} je přiřazeno před nemístní deklarací",
        "nonLocalRedefinition": "{name} již bylo deklarováno jako nemístní",
        "noneNotCallable": "Objekt typu „None“ nelze volat.",
        "noneNotIterable": "Objekt typu None není možné použít jako iterovatelnou hodnotu",
        "noneNotSubscriptable": "Objekt typu “None“ nelze zadat jako dolní index",
        "noneNotUsableWith": "Objekt typu None není možné použít s with",
        "noneOperator": "Operátor {operator} se pro None nepodporuje",
        "noneUnknownMember": "{name} není známým členem None",
        "notRequiredArgCount": "Za NotRequired byl očekáván jeden argument typu",
        "notRequiredNotInTypedDict": "NotRequired není v tomto kontextu povolené",
        "objectNotCallable": "Objekt typu {type} není možné volat",
        "obscuredClassDeclaration": "Deklarace třídy {name} je zakrytá deklarací stejného jména",
        "obscuredFunctionDeclaration": "Deklarace funkce {name} je zakrytá deklarací stejného názvu",
        "obscuredMethodDeclaration": "Deklarace metody {name} je zakrytá deklarací stejného názvu",
        "obscuredParameterDeclaration": "Deklarace parametru {name} je zakrytá deklarací stejného názvu",
        "obscuredTypeAliasDeclaration": "Deklarace aliasu typu {name} je zakrytá deklarací stejného názvu",
        "obscuredVariableDeclaration": "Deklarace {name} je zakrytá deklarací stejného názvu",
        "operatorLessOrGreaterDeprecated": "Operátor <> se v Pythonu 3 nepodporuje; místo toho použijte !=",
        "optionalExtraArgs": "Za nepovinnou hodnotou se očekával jeden argument typu",
        "orPatternIrrefutable": "Nevratný vzor je povolený jenom jako poslední dílčí vzorec ve vzorci „or“",
        "orPatternMissingName": "Všechny dílčí vzory v rámci vzoru or musí cílit na stejné názvy",
        "overlappingKeywordArgs": "Slovník silného typu se překrývá s parametrem klíčového slova: {names}",
        "overlappingOverload": "Přetížení {obscured} pro {name} se nikdy nepoužije, protože jeho parametry se překrývají s přetížením {obscuredBy}",
        "overloadAbstractMismatch": "Přetížené metody musí být všechny abstraktní nebo ne",
        "overloadClassMethodInconsistent": "Přetížení pro {name} používají @classmethod nekonzistentně.",
        "overloadFinalInconsistencyImpl": "Přetížení pro „{name}“ je označené @final ale implementace není",
        "overloadFinalInconsistencyNoImpl": "Přetížení {index} pro „{name}“ je označené @final ale přetížení 1 není",
        "overloadImplementationMismatch": "Přetížená implementace není konzistentní se signaturou přetížení {index}",
        "overloadReturnTypeMismatch": "Přetížení {prevIndex} pro {name} se překrývá s přetížením {newIndex} a vrací nekompatibilní typ",
        "overloadStaticMethodInconsistent": "Přetížení pro {name} používají @staticmethod nekonzistentně.",
        "overloadWithoutImplementation": "„{name}“ je označen(é/o) jako přetížení, ale není zadaná žádná implementace",
        "overriddenMethodNotFound": "Metoda „{name}“ je označená jako přepsání, ale neexistuje žádná základní metoda se stejným názvem",
        "overrideDecoratorMissing": "Metoda „{name}“ není označená jako přepsání, ale přepisuje metodu ve třídě „{className}“",
        "paramAfterKwargsParam": "Parametr nemůže následovat za parametrem „**“",
        "paramAlreadyAssigned": "Parametr {name} je už přiřazený",
        "paramAnnotationMissing": "Chybí poznámka typu pro parametr „{name}“",
        "paramAssignmentMismatch": "Výraz typu „{sourceType}“ nelze přiřadit k parametru typu „{paramType}“",
        "paramNameMissing": "Žádný parametr s názvem {name}",
        "paramSpecArgsKwargsUsage": "Členy argumentů args a kwargs parametru ParamSpec se musí vyskytovat v signatuře funkce",
        "paramSpecArgsMissing": "Chybí argumenty pro parametr ParamSpec {type}",
        "paramSpecArgsUsage": "Člen „args“ parametru ParamSpec je platný jenom v případě, že se používá s parametrem *args",
        "paramSpecAssignedName": "Parametr ParamSpec musí být přiřazen proměnné s názvem {name}",
        "paramSpecContext": "ParamSpec se v tomto kontextu nepovoluje",
        "paramSpecDefaultNotTuple": "Očekávaly se tři tečky, výraz řazené kolekce členů nebo Parametr ParamSpec pro výchozí hodnotu ParamSpec",
        "paramSpecFirstArg": "Očekával se název parametru ParamSpec jako první argument",
        "paramSpecKwargsUsage": "Člen kwargs parametru ParamSpec je platný jenom v případě, že se používá s parametrem **kwargs",
        "paramSpecNotUsedByOuterScope": "Parametr ParamSpec {name} nemá v tomto kontextu žádný význam",
        "paramSpecScopedToReturnType": "Parametr ParamSpec {name} je vymezený na volatelnou proměnnou v rámci návratového typu a nedá se na něj odkazovat v těle funkce jazyka",
        "paramSpecUnknownArg": "Parametr ParamSpec nepodporuje více než jeden argument",
        "paramSpecUnknownMember": "{name} není známý člen ParamSpec",
        "paramSpecUnknownParam": "„{name}“ je neznámý parametr parametru ParamSpec",
        "paramTypeCovariant": "Proměnnou kovariantní typu není možné použít v typu parametru",
        "paramTypePartiallyUnknown": "Typ parametru {paramName} je částečně neznámý",
        "paramTypeUnknown": "Typ parametru {paramName} je neznámý",
        "parenthesizedContextManagerIllegal": "Závorky v příkazu with vyžadují Python 3.9 nebo novější",
        "patternNeverMatches": "Vzor se nikdy nebude shodovat s typem předmětu {type}",
        "positionArgAfterNamedArg": "Poziční argument se nemůže objevit za argumenty klíčového slova",
        "positionOnlyAfterArgs": "Oddělovač parametrů jen pro pozici není povolený za parametrem *.",
        "positionOnlyAfterKeywordOnly": "Parametr / se musí zobrazit před parametrem *",
        "positionOnlyAfterNon": "Parametr jen pro pozici není povolený za parametrem, který není jen pro pozici.",
        "positionOnlyFirstParam": "Oddělovač parametrů jen pro pozici není povolený jako první parametr.",
        "positionOnlyIncompatible": "Oddělovač parametrů jen pro pozici vyžaduje Python 3.8 nebo novější.",
        "privateImportFromPyTypedModule": "{name} se neexportuje z modulu {module}",
        "privateUsedOutsideOfClass": "{name} je privátní a používá se mimo třídu, ve které je deklarovaná",
        "privateUsedOutsideOfModule": "{name} je privátní a používá se mimo modul, ve kterém je deklarován",
        "propertyOverridden": "„{name}“ nesprávně přepíše vlastnost se stejným názvem ve třídě {className}",
        "propertyStaticMethod": "Statické metody nejsou povoleny pro metodu getter, setter nebo deleter vlastnosti",
        "protectedUsedOutsideOfClass": "„{name}“ je chráněn(ý/o/é) a používá se mimo třídu, ve které je deklarovaná",
        "protocolBaseClass": "Třída protokolu „{classType}“ se nemůže odvozovat od třídy,která není protokolem „{baseType}“",
        "protocolBaseClassWithTypeArgs": "Argumenty typu nejsou u třídy Protocol povoleny při použití syntaxe parametru typu",
        "protocolIllegal": "Použití protokolu vyžaduje Python 3.7 nebo novější",
        "protocolNotAllowed": "„Protocol“ nejde v tomto kontextu použít.",
        "protocolUnsafeOverlap": "Třída se nebezpečně překrývá s názvem „{name}“ a může vytvořit shodu při spuštění.",
        "protocolVarianceContravariant": "Proměnná typu „{variable}“ použitá v obecném protokolu „{class}“ by měla být kontravariantní",
        "protocolVarianceCovariant": "Proměnná typu „{variable}“ použitá v obecném protokolu „{class}“ by měla být kovariantní",
        "protocolVarianceInvariant": "Proměnná typu „{variable}“ použitá v obecném protokolu „{class}“ by měla být invariantní",
        "pyrightCommentInvalidDiagnosticBoolValue": "Za direktivou komentářů Pyright musí následovat znak =a hodnota true nebo false",
        "pyrightCommentInvalidDiagnosticSeverityValue": "Za direktivou komentářů Pyright musí následovat = a hodnota true, false, error, warning, information nebo none",
        "pyrightCommentMissingDirective": "Za komentářem Pyright musí následovat direktiva (základní nebo striktní) nebo diagnostické pravidlo",
        "pyrightCommentNotOnOwnLine": "Komentáře Pyright používané k řízení nastavení na úrovni souborů se musí zobrazovat na vlastním řádku",
        "pyrightCommentUnknownDiagnosticRule": "{rule} je neznámé diagnostické pravidlo pro komentář pyright",
        "pyrightCommentUnknownDiagnosticSeverityValue": "{value} je neplatná hodnota pro komentář pyright; očekávalo se true, false, error, warning, information nebo none",
        "pyrightCommentUnknownDirective": "Direktiva {directive} je neznámá direktiva pro komentář pyright; očekávalo se strict nebo basic",
        "readOnlyArgCount": "Za „ReadOnly“ se očekával jeden argument typu",
        "readOnlyNotInTypedDict": "ReadOnly není v tomto kontextu povolené",
        "recursiveDefinition": "Typ „{name}“ nelze určit, protože odkazuje sám na sebe",
        "relativeImportNotAllowed": "Relativní importy se nedají použít s formulářem importu .a; místo toho použijte from . import a",
        "requiredArgCount": "Za povinným argumentem se očekával jeden argument typu",
        "requiredNotInTypedDict": "Required není v tomto kontextu povoleno",
        "returnInAsyncGenerator": "Příkaz Return s hodnotou není v asynchronním generátoru povolený",
        "returnMissing": "Funkce s deklarovaným návratovým typem „{returnType}“ musí vracet hodnotu na všech cestách kódu",
        "returnOutsideFunction": "„return“ se dá použít jenom v rámci funkce",
        "returnTypeContravariant": "Kontravariantní proměnnou typu nejde použít v návratovém typu",
        "returnTypeMismatch": "Výraz typu {exprType} není možné přiřadit k návratového typu {returnType}",
        "returnTypePartiallyUnknown": "Návratový typ {returnType} je částečně neznámý",
        "returnTypeUnknown": "Návratový typ je neznámý",
        "revealLocalsArgs": "Pro volání reveal_locals se neočekávaly žádné argumenty",
        "revealLocalsNone": "V tomto oboru nejsou žádné místní hodnoty",
        "revealTypeArgs": "Pro volání reveal_type byl očekáván jeden poziční argument",
        "revealTypeExpectedTextArg": "Argument „expected_text“ pro funkci „reveal_type“ musí být hodnota literálu str",
        "revealTypeExpectedTextMismatch": "Neshoda typu textu; očekávaný počet: {expected}, počet, který byl přijat: {received}",
        "revealTypeExpectedTypeMismatch": "Neshoda typů; Očekával(o/y) se „{expected}“, ale přijal(o/y) se „{received}“",
        "selfTypeContext": "Self není v tomto kontextu platné",
        "selfTypeMetaclass": "„Self“ nelze použít v rámci metatřídy (podtřídy „type“).",
        "selfTypeWithTypedSelfOrCls": "Self není možné použít ve funkci s parametrem self nebo cls, která má jinou poznámku typu než Self",
        "setterGetterTypeMismatch": "Typ hodnoty metody setter vlastnosti není možné přiřadit návratového typu getter",
        "singleOverload": "{name} je označené jako přetížení, ale chybí další přetížení",
        "slotsAttributeError": "„{name}“ není zadaný v __slots__",
        "slotsClassVarConflict": "{name} je v konfliktu s proměnnou instance deklarovanou v __slots__",
        "starPatternInAsPattern": "Vzor hvězdy se nedá použít s cílem as",
        "starPatternInOrPattern": "Vzor hvězdy nemůže být ORed v jiných vzorech",
        "starStarWildcardNotAllowed": "** není možné použít se zástupným znakem _",
        "staticClsSelfParam": "Statické metody by neměly přijímat parametr self nebo cls",
        "stdlibModuleOverridden": "„{path}“ přepisuje modul stdlib „{name}“",
        "stringNonAsciiBytes": "Znak jiný než ASCII není povolený v bajtech řetězcového literálu",
        "stringNotSubscriptable": "Řetězcový výraz není možné v poznámce typu zadat jako dolní index uzavření celé poznámky do uvozovek",
        "stringUnsupportedEscape": "Nepodporovaná řídicí sekvence v řetězcovém literálu",
        "stringUnterminated": "Řetězcový literál je neukončený",
        "stubFileMissing": "Soubor zástupné procedury pro {importName} se nenašel",
        "stubUsesGetAttr": "Soubor zástupné procedury typu je neúplný; __getattr__ zakrývá typové chyby pro modul",
        "sublistParamsIncompatible": "Parametry podsestavy nejsou v Python 3.x podporované",
        "superCallArgCount": "Pro volání „super“ se očekávaly maximálně dva argumenty",
        "superCallFirstArg": "Jako první argument pro volání super se očekával typ třídy, ale přijal se {type}",
        "superCallSecondArg": "Druhý argument volání super musí být objekt nebo třída odvozená z typu {type}",
        "superCallZeroArgForm": "Forma nulového argumentu „super“ volání je platná pouze v rámci metody.",
        "superCallZeroArgFormStaticMethod": "Forma nulového argumentu „super“ volání není platná v rámci statické metody.",
        "symbolIsPossiblyUnbound": "{name} je pravděpodobně nevázané",
        "symbolIsUnbound": "Název {name} je nevázaný",
        "symbolIsUndefined": "{name} není definované",
        "symbolOverridden": "{name} přepíše symbol stejného názvu ve třídě {className}",
        "ternaryNotAllowed": "Výraz ternary není v poznámce typu povolený.",
        "totalOrderingMissingMethod": "Třída musí definovat jednu z __lt__, __le__, __gt__ nebo __ge__, aby bylo možné používat total_ordering",
        "trailingCommaInFromImport": "Koncová čárka není povolena bez okolních závorek",
        "tryWithoutExcept": "Příkaz Try musí mít alespoň jednu klauzuli except nebo finally",
        "tupleAssignmentMismatch": "Výraz s typem „{type}“ se nedá přiřadit cílové řazené kolekci členů",
        "tupleInAnnotation": "Výraz řazené kolekce členů není v poznámce typu povolený",
        "tupleIndexOutOfRange": "Index {index} je pro typ {type} mimo rozsah",
        "typeAliasIllegalExpressionForm": "Neplatný formulář výrazu pro definici aliasu typu",
        "typeAliasIsRecursiveDirect": "Alias typu „{name}“ nemůže ve své definici používat sám sebe",
        "typeAliasNotInModuleOrClass": "Typ TypeAlias je možné definovat pouze v rámci oboru modulu nebo třídy",
        "typeAliasRedeclared": "{name} se deklaruje jako TypAlias a dá se přiřadit jenom jednou",
        "typeAliasStatementBadScope": "Příkaz type se dá použít jenom v rámci oboru modulu nebo třídy.",
        "typeAliasStatementIllegal": "Příkaz alias typu vyžaduje Python 3.12 nebo novější",
        "typeAliasTypeBaseClass": "Alias typu definovaný v příkazu „typ“ nejde použít jako základní třídu",
        "typeAliasTypeMustBeAssigned": "Typ TypeAliasType musí být přiřazen proměnné se stejným názvem jako alias typu",
        "typeAliasTypeNameArg": "První argument typeAliasType musí být řetězcový literál představující název aliasu typu",
        "typeAliasTypeNameMismatch": "Název aliasu typu se musí shodovat s názvem proměnné, ke které je přiřazená",
        "typeAliasTypeParamInvalid": "Seznam parametrů typu musí být řazená kolekce členů obsahující pouze typeVar, TypeVarTuple nebo ParamSpec",
        "typeAnnotationCall": "Výraz volání není ve výrazu typu povolený",
        "typeAnnotationVariable": "Proměnná není ve výrazu typu povolená",
        "typeAnnotationWithCallable": "Argument typu pro „type“ musí být třída; volatelné objekty se nepodporují.",
        "typeArgListExpected": "Očekával se parametr ParamSpec, tři tečky nebo seznam typů",
        "typeArgListNotAllowed": "Výraz seznamu není pro tento argument typu povolený",
        "typeArgsExpectingNone": "Pro třídu {name} se neočekávaly žádné argumenty typu",
        "typeArgsMismatchOne": "Očekával se jeden argument typu, ale bylo přijato {received}",
        "typeArgsMissingForAlias": "Pro alias obecného typu {name} se očekávaly argumenty typu",
        "typeArgsMissingForClass": "Očekávané argumenty typu pro obecnou třídu „{name}“",
        "typeArgsTooFew": "Pro {name} se zadalo příliš málo argumentů typu. Očekávalo se {expected}, ale přijalo se {received}",
        "typeArgsTooMany": "Pro „{name}“ se zadalo příliš mnoho argumentů typu. Očekával(o/y) se {expected}, ale přijal(o/y) se {received}",
        "typeAssignmentMismatch": "Výraz typu {sourceType} není možné přiřadit deklarovanému typu {destType}",
        "typeAssignmentMismatchWildcard": "Symbol importu {name} má typ {sourceType}, který nejde přiřadit deklarovanému typu {destType}.",
        "typeCallNotAllowed": "Volání type() by se nemělo používat v poznámce typu",
        "typeCheckOnly": "Název {name} je označený jako @type_check_only a dá se použít jenom v poznámkách typu",
        "typeCommentDeprecated": "Použití komentářů typu je zastaralé místo toho použít anotaci typu",
        "typeExpectedClass": "Očekával se výraz typu, ale přijal se {type}",
        "typeGuardArgCount": "Za TypeGuard nebo TypeIs byl očekáván jeden argument typu.",
        "typeGuardParamCount": "Funkce a metody ochrany typů definované uživatelem musí mít alespoň jeden vstupní parametr",
        "typeIsReturnType": "Návratový typ TypeIs ({returnType}) není konzistentní s typem parametru hodnoty ({type}).",
        "typeNotAwaitable": "„{type}“ se nedá očekávat.",
        "typeNotIntantiable": "Není možné vytvořit instanci {type}",
        "typeNotIterable": "{type} není možné iterovat",
        "typeNotSpecializable": "Nepovedlo se specializovat typ „{type}“",
        "typeNotSubscriptable": "Objekt typu {type} není možné zadat jako dolní index",
        "typeNotSupportBinaryOperator": "Operátor „{operator}“ se pro typy „{leftType}“ a „{rightType}“ nepodporuje",
        "typeNotSupportBinaryOperatorBidirectional": "Operátor {operator} není podporován pro typy „{leftType}“ a „{rightType}“, pokud se očekává typ „{expectedType}“",
        "typeNotSupportUnaryOperator": "Operátor {operator} se pro typ {type} nepodporuje",
        "typeNotSupportUnaryOperatorBidirectional": "Operátor {operator} není podporován pro typ {type}, když očekávaný typ je {expectedType}",
        "typeNotUsableWith": "Objekt typu {type} není možné použít s typem with, protože neimplementuje metodu {method}",
        "typeParameterBoundNotAllowed": "Vazbu nebo omezení nelze použít s parametrem variadického typu ani s parametrem ParamSpec",
        "typeParameterConstraintTuple": "Omezení parametru typu musí být řazená kolekce členů dvou nebo více typů",
        "typeParameterExistingTypeParameter": "Parametr typu {name} se už používá",
        "typeParameterNotDeclared": "Parametr typu {name} není zahrnutý v seznamu parametrů typu pro kontejner {container}",
        "typeParametersMissing": "Musí být zadán alespoň jeden parametr typu",
        "typePartiallyUnknown": "Typ {name} je částečně neznámý",
        "typeUnknown": "Typ {name} je neznámý",
        "typeVarAssignedName": "Typ TypeVar musí být přiřazen proměnné s názvem {name}",
        "typeVarAssignmentMismatch": "Typ „{type}“ se nedá přiřadit proměnné typu „{name}“",
        "typeVarBoundAndConstrained": "TypeVar nemůže být současně vázaný i omezený",
        "typeVarBoundGeneric": "Vázaný typ TypeVar nemůže být obecný",
        "typeVarConstraintGeneric": "Typ omezení TypeVar nemůže být obecný",
        "typeVarDefaultBoundMismatch": "Výchozí typ TypeVar musí být podtyp vázaného typu",
        "typeVarDefaultConstraintMismatch": "Výchozí typ TypeVar musí být jeden z omezených typů",
        "typeVarDefaultIllegal": "Výchozí typy proměnných typů vyžadují Python 3.13 nebo novější",
        "typeVarDefaultInvalidTypeVar": "Parametr typu {name} má výchozí typ, který odkazuje na jednu nebo více proměnných typu, které jsou mimo obor",
        "typeVarFirstArg": "Očekával se název TypeVar jako první argument",
        "typeVarNoMember": "TypeVar {type} nemá žádného člena {name}",
        "typeVarNotSubscriptable": "TypeVar {type} není možné zadat jako dolní index",
        "typeVarNotUsedByOuterScope": "Proměnná typu {name} nemá v tomto kontextu žádný význam",
        "typeVarPossiblyUnsolvable": "Proměnná typu „{name}“ může být nevyřešená, pokud volající nezadá žádný argument pro parametr „{param}“",
        "typeVarScopedToReturnType": "Proměnná typu „{name}“ je vymezená na volatelnou proměnnou v rámci návratového typu a nedá se na to odkazovat v těle funkce",
        "typeVarSingleConstraint": "TypeVar musí mít alespoň dva omezené typy",
        "typeVarTupleConstraints": "TypeVarTuple nemůže mít omezení hodnoty",
        "typeVarTupleContext": "TypeVarTuple se v tomto kontextu nepovoluje",
        "typeVarTupleDefaultNotUnpacked": "Výchozí typ TypeVarTuple musí být rozbalený řazená kolekce členů nebo TypeVarTuple",
        "typeVarTupleMustBeUnpacked": "Pro hodnotu TypeVarTuple se vyžaduje operátor rozbalení",
        "typeVarTupleUnknownParam": "{name} je neznámý parametr pro TypeVarTuple",
        "typeVarUnknownParam": "„{name}“ je neznámý parametr pro TypeVar",
        "typeVarUsedByOuterScope": "TypeVar „{name}“ se už používá ve vnějším oboru",
        "typeVarUsedOnlyOnce": "TypeVar {name} se v signatuře obecné funkce zobrazuje jenom jednou",
        "typeVarVariance": "TypeVar nemůže být kovariantní i kontravariantní",
        "typeVarWithDefaultFollowsVariadic": "TypeVar {typeVarName} má výchozí hodnotu a nemůže následovat po typeVarTuple {variadicName}.",
        "typeVarWithoutDefault": "„{name}“ se v seznamu parametrů typu nemůže zobrazit za „{other}“ , protože nemá žádný výchozí typ",
        "typeVarsNotInGenericOrProtocol": "Generic[] nebo Protocol[] musí obsahovat všechny proměnné typu",
        "typedDictAccess": "Nepovedlo se získat přístup k položce v TypedDict",
        "typedDictAssignedName": "TypedDict se musí přiřadit proměnné s názvem „{name}“.",
        "typedDictBadVar": "Třídy TypedDict můžou obsahovat jenom poznámky typu",
        "typedDictBaseClass": "Všechny základní třídy pro třídy TypedDict musí být také třídami TypedDict",
        "typedDictBoolParam": "Očekávalo se, že parametr {name} bude mít hodnotu True nebo False",
        "typedDictClosedExtras": "Základní třída {name} je uzavřená třída TypedDict; Další položky musí být typu {type}.",
        "typedDictClosedNoExtras": "Základní třída {name} je uzavřená hodnota TypedDict; Položky navíc nejsou povolené.",
        "typedDictDelete": "Nepovedlo se odstranit položku v TypedDict",
        "typedDictEmptyName": "Názvy v rámci TypedDict nemůžou být prázdné",
        "typedDictEntryName": "Očekával se řetězcový literál pro název položky slovníku",
        "typedDictEntryUnique": "Názvy ve slovníku musí být jedinečné",
        "typedDictExtraArgs": "Nadbytečné argumenty TypedDict nejsou podporovány",
        "typedDictFieldNotRequiredRedefinition": "Položka TypedDict {name} nejde předefinovat jako NotRequired.",
        "typedDictFieldReadOnlyRedefinition": "Položka TypedDict {name} nejde předefinovat jako ReadOnly.",
        "typedDictFieldRequiredRedefinition": "Položka TypedDict {name} nejde předefinovat jako Required.",
        "typedDictFirstArg": "Jako první argument byl očekáván název třídy TypedDict",
        "typedDictInitsubclassParameter": "TypedDict nepodporuje parametr __init_subclass__ „{name}“.",
        "typedDictNotAllowed": "„TypedDict“ se v tomto kontextu nedá použít.",
        "typedDictSecondArgDict": "Jako druhý parametr se očekával parametr diktování nebo klíčového slova",
        "typedDictSecondArgDictEntry": "Očekávaná jednoduchá položka slovníku",
        "typedDictSet": "Nelze přiřadit položku v TypedDict",
        "unaccessedClass": "Třída „{name}“ není přístupná",
        "unaccessedFunction": "Funkce {name} není přístupná",
        "unaccessedImport": "Import {name} není přístupný",
        "unaccessedSymbol": "{name} není přístupné",
        "unaccessedVariable": "Proměnná {name} není přístupná",
        "unannotatedFunctionSkipped": "Analýza funkce „{name}“ se přeskočila, protože není označená",
        "unaryOperationNotAllowed": "Unární operátor není v poznámce typu povolený.",
        "unexpectedAsyncToken": "Očekávalo se, že za async bude následovat def, with nebo for",
        "unexpectedExprToken": "Neočekávaný token na konci výrazu",
        "unexpectedIndent": "Neočekávané odsazení",
        "unexpectedUnindent": "Neočekává se unindent",
        "unhashableDictKey": "Klíč slovníku musí být hashovatelný",
        "unhashableSetEntry": "Položka sady musí být hashovatelná",
        "uninitializedAbstractVariables": "Proměnné definované v abstraktní základní třídě nejsou inicializovány v konečné třídě {classType}",
        "uninitializedInstanceVariable": "Proměnná instance {name} není inicializována v těle třídy nebo v metodě __init__",
        "unionForwardReferenceNotAllowed": "Syntaxi sjednocení není možné použít s operandem řetězce; použijte uvozovky kolem celého výrazu",
        "unionSyntaxIllegal": "Alternativní syntaxe pro sjednocení vyžaduje Python 3.10 nebo novější",
        "unionTypeArgCount": "Sjednocení vyžaduje dva nebo více argumentů typu",
        "unionUnpackedTuple": "Sjednocení nemůže obsahovat rozbalenou řazenou kolekci členů.",
        "unionUnpackedTypeVarTuple": "Sjednocení nemůže obsahovat rozbalený typ TypeVarTuple.",
        "unnecessaryCast": "Nepotřebné volání„přetypování“; Typ už je „{type}“.",
        "unnecessaryIsInstanceAlways": "Zbytečné volání isinstance; {testType} je vždy instancí třídy {classType}",
        "unnecessaryIsSubclassAlways": "Nepotřebné volání issubclass; „{testType}“ je vždy podtřídou třídy „{classType}“",
        "unnecessaryPyrightIgnore": "Nepotřebný komentář „# pyright: ignore“",
        "unnecessaryPyrightIgnoreRule": "Nepotřebné pravidlo # pyright: ignore: {name}",
        "unnecessaryTypeIgnore": "Nepotřebný komentář „# type: ignore“",
        "unpackArgCount": "Po rozbalení „Unpack“ se očekával jeden argument typu",
        "unpackExpectedTypeVarTuple": "Jako argument typu pro rozbalení byl očekáván typ TypeVarTuple nebo řazená kolekce členů",
        "unpackExpectedTypedDict": "Byl očekáván argument typu TypedDict pro rozbalení Unpack",
        "unpackIllegalInComprehension": "Operace rozbalení není v porozumění povolená",
        "unpackInAnnotation": "V poznámce typu není povolený operátor rozbalení",
        "unpackInDict": "Operace rozbalení není ve slovnících povolena",
        "unpackInSet": "Operátor rozbalení není v sadě povolený",
        "unpackNotAllowed": "Rozbalení se v tomto kontextu nepovoluje",
        "unpackOperatorNotAllowed": "Operace rozbalení není v tomto kontextu povolená",
        "unpackTuplesIllegal": "Operace rozbalení není povolená v řazených kolekcích členů před Pythonem 3.8",
        "unpackedArgInTypeArgument": "Rozbalené argumenty není možné použít v seznamech argumentů typu",
        "unpackedArgWithVariadicParam": "Pro parametr TypeVarTuple nejde použít rozbalený argument",
        "unpackedDictArgumentNotMapping": "Výraz argumentu za ** musí být mapování s typem klíče str",
        "unpackedDictSubscriptIllegal": "Operátor rozbalení slovníku v dolním indexu není povolený",
        "unpackedSubscriptIllegal": "Operátor rozbalení v dolním indexu vyžaduje Python 3.11 nebo novější",
        "unpackedTypeVarTupleExpected": "Byl očekáván rozbalený typ TypeVarTuple; použijte Unpack[{name1}] nebo *{name2}",
        "unpackedTypedDictArgument": "Nepovedlo se spárovat nebalený argument TypedDict s parametry",
        "unreachableCode": "Kód je nedostupný",
        "unreachableExcept": "Klauzule Except je nedosažitelná, protože výjimka je již zpracována",
        "unsupportedDunderAllOperation": "Operace s __all__ se nepodporuje, takže exportovaný seznam symbolů nemusí být správný",
        "unusedCallResult": "Výsledek výrazu volání je typu „{type}“ a nepoužívá se. přiřadit proměnné „_“, pokud je to záměrné",
        "unusedCoroutine": "Výsledek volání asynchronní funkce se nepoužívá; použijte operátor await nebo přiřaďte výsledek proměnné",
        "unusedExpression": "Hodnota výrazu se nepoužívá",
        "varAnnotationIllegal": "Poznámky typu pro proměnné vyžadují Python 3.6 nebo novější; pro kompatibilitu s předchozími verzemi použijte komentáře typu",
        "variableFinalOverride": "Proměnná {name} je označená jako final a přepíše proměnnou non-Final se stejným názvem ve třídě {className}",
        "variadicTypeArgsTooMany": "Seznam argumentů typů může mít maximálně jeden rozbalený typ TypeVarTuple nebo řazenou kolekci členů",
        "variadicTypeParamTooManyAlias": "Alias typu může mít maximálně jeden parametr typu TypeVarTuple, ale přijal několik ({names})",
        "variadicTypeParamTooManyClass": "Obecná třída může mít maximálně jeden parametr typu TypeVarTuple, ale přijala více ({names})",
        "walrusIllegal": "Operátor := vyžaduje Python 3.8 nebo novější",
        "walrusNotAllowed": "Operátor := není v tomto kontextu povolen bez okolních závorek",
        "wildcardInFunction": "Import se zástupnými znaky není v rámci třídy nebo funkce povolen",
        "wildcardLibraryImport": "Import se zástupnými znaky z knihovny není povolený",
        "wildcardPatternTypePartiallyUnknown": "Typ zachycený vzorem se zástupnými znaky je částečně neznámý",
        "wildcardPatternTypeUnknown": "Typ zachycený vzorem se zástupnými znaky je neznámý",
        "yieldFromIllegal": "Použití příkazu yield from vyžaduje Python 3.3 nebo novější",
        "yieldFromOutsideAsync": "yield from není v asynchronní funkci povoleno",
        "yieldOutsideFunction": "„yield“ není povoleno mimo funkci nebo lambdu",
        "yieldWithinListCompr": "yield není povolen uvnitř seznamu porozumění",
        "zeroCaseStatementsFound": "Výraz shody obsahovat alespoň jeden výraz velikosti písmen",
        "zeroLengthTupleNotAllowed": "Řazená kolekce členů s nulovou délkou není v tomto kontextu povolená"
    },
    "DiagnosticAddendum": {
        "annotatedNotAllowed": "Speciální formulář s poznámkami nejde použít s kontrolami instancí a tříd.",
        "argParam": "Argument odpovídá parametru {paramName}",
        "argParamFunction": "Argument odpovídá parametru {paramName} ve funkci {functionName}",
        "argsParamMissing": "Parametr „*{paramName}“ nemá žádný odpovídající parametr",
        "argsPositionOnly": "Neshoda parametrů pouze s pozicí; Očekával(o/y) se {expected}, ale přijal(o/y) se {received}",
        "argumentType": "Typ argumentu je {type}",
        "argumentTypes": "Typy argumentů: ({types})",
        "assignToNone": "Typ není možné přiřadit typu None",
        "asyncHelp": "Měli jste na mysli „async s“?",
        "baseClassIncompatible": "Základní třída {baseClass} není kompatibilní s typem {type}",
        "baseClassIncompatibleSubclass": "Základní třída {baseClass} je odvozená od třídy {subclass}, která není kompatibilní s typem {type}",
        "baseClassOverriddenType": "Základní třída {baseClass} poskytuje typ {type}, který je přepsán",
        "baseClassOverridesType": "Základní třída „{baseClass}“ přepisuje typ „{type}“",
        "bytesTypePromotions": "Pokud chcete povolit chování povýšení typu pro „bytearray“ a „memoryview“, nastavte disableBytesTypePromotions na false",
        "conditionalRequiresBool": "Metoda __bool__ pro typ {operandType} vrací typ {boolReturnType} místo bool",
        "dataClassFieldLocation": "Deklarace pole",
        "dataClassFrozen": "{name} je zablokované",
        "dataProtocolUnsupported": "„{name}“ je datový protokol.",
        "descriptorAccessBindingFailed": "Nepovedlo se vytvořit vazbu metody {name} pro třídu popisovače {className}.",
        "descriptorAccessCallFailed": "Nepovedlo se volat metodu {name} pro třídu popisovače {className}.",
        "finalMethod": "Konečná metoda",
        "functionParamDefaultMissing": "V parametru „{name}“ chybí výchozí argument",
        "functionParamName": "Neshoda názvu parametru: {destName} a {srcName}",
        "functionParamPositionOnly": "Neshoda parametrů pouze s pozicí; Parametr „{name}“ není jen pro pozici.",
        "functionReturnTypeMismatch": "Návratový typ funkce „{sourceType}“ není kompatibilní s typem „{destType}“",
        "functionTooFewParams": "Funkce přijímá příliš málo pozičních parametrů; očekávaný počet: {expected}, počet, který byl přijat: {received}",
        "functionTooManyParams": "Funkce přijímá příliš mnoho pozičních parametrů; očekávaný počet: {expected}, počet, který byl přijat: {received}",
        "genericClassNotAllowed": "Obecný typ s argumenty obecného typu se pro kontroly instancí nebo tříd nepovoluje.",
        "incompatibleDeleter": "Metoda odstranění vlastnosti je nekompatibilní",
        "incompatibleGetter": "Metoda getter vlastnosti je nekompatibilní",
        "incompatibleSetter": "Metoda setter vlastnosti je nekompatibilní",
        "initMethodLocation": "Metoda __init__ je definována ve třídě {type}",
        "initMethodSignature": "Podpis __init__ je {type}",
        "initSubclassLocation": "Metoda __init_subclass__ je definována ve třídě {name}.",
        "invariantSuggestionDict": "Zvažte přepnutí z „diktování“ na „mapování“, které je v typu hodnoty kovariantní",
        "invariantSuggestionList": "Zvažte přepnutí ze „seznamu“ na „sekvenci“, která je kovavariantní",
        "invariantSuggestionSet": "Zvažte přepnutí ze „seznamu“ na „sekvenci“, která je kovavariantní",
        "keyNotRequired": "„{name}! není v typu „{type}“ povinný klíč, takže přístup může vést k výjimce modulu runtime",
        "keyReadOnly": "{name} je klíč jen pro čtení v {type}",
        "keyRequiredDeleted": "{name} je povinný klíč a nedá se odstranit",
        "keyUndefined": "{name} není definovaný klíč v typu {type}",
        "kwargsParamMissing": "Parametr „**{paramName}“ nemá žádný odpovídající parametr",
        "listAssignmentMismatch": "Typ {type} není kompatibilní s cílovým seznamem",
        "literalAssignmentMismatch": "{sourceType} se nedá přiřadit k typu {destType}",
        "matchIsNotExhaustiveHint": "Pokud není zamýšleno vyčerpávající zpracování, přidejte case _: pass",
        "matchIsNotExhaustiveType": "Nezpracovaný typ: {type}",
        "memberAssignment": "Výraz typu „{type}“ nelze přiřadit členu „{name}“ třídy „{classType}“",
        "memberIsAbstract": "„{type}.{name}“ není implementováno.",
        "memberIsAbstractMore": "a tento počet dalších: {count}...",
        "memberIsClassVarInProtocol": "„{name}“ je v protokolu definován jako ClassVar.",
        "memberIsFinalInProtocol": "{name} je v protokolu označený jako Final",
        "memberIsInitVar": "Člen {name} je pole jen pro inicializaci",
        "memberIsInvariant": "{name} je invariantní, protože je proměnlivé",
        "memberIsNotClassVarInClass": "„{name}“ musí být definováno jako ClassVar, aby bylo kompatibilní s protokolem.",
        "memberIsNotClassVarInProtocol": "„{name}“ není v protokolu definován jako ClassVar.",
        "memberIsNotFinalInProtocol": "„{name}“ není v protokolu označeno jako Final",
        "memberIsWritableInProtocol": "{name} se dá zapisovat do protokolu.",
        "memberSetClassVar": "Člen „{name}“ nelze přiřadit prostřednictvím instance třídy, protože se jedná o třídu ClassVar",
        "memberTypeMismatch": "{name} je nekompatibilní typ",
        "memberUnknown": "Člen {name} je neznámý",
        "metaclassConflict": "Metatřída {metaclass1} je v konfliktu s metatřídou {metaclass2}.",
        "missingDeleter": "Chybí metoda odstranění vlastnosti",
        "missingGetter": "Chybí metoda getter vlastnosti",
        "missingSetter": "Chybí metoda nastavovacího kódu vlastnosti",
        "namedParamMissingInDest": "V cíli chybí parametr klíčového slova {name}",
        "namedParamMissingInSource": "Ve zdroji chybí parametr klíčového slova „{name}“",
        "namedParamTypeMismatch": "Parametr klíčového slova {name} typu {sourceType} není možné přiřadit typu {destType}",
        "namedTupleNotAllowed": "NamedTuple se nedá použít pro kontroly instancí nebo tříd.",
        "newMethodLocation": "Metoda __new__ je definována ve třídě {type}",
        "newMethodSignature": "Podpis __new__ je {type}",
        "newTypeClassNotAllowed": "Třídu vytvořenou pomocí newType nelze použít s kontrolami instancí a tříd.",
        "noOverloadAssignable": "Typ {type} neodpovídá žádné přetížené funkci",
        "noneNotAllowed": "Žádné se nedají použít pro kontroly instancí nebo tříd.",
        "orPatternMissingName": "Chybějící názvy: {name}",
        "overloadIndex": "Přetížení {index} je nejbližší shoda.",
        "overloadNotAssignable": "Nejméně jedno přetížení {name} není možné přiřadit",
        "overloadSignature": "Tady je definován podpis přetížení",
        "overriddenMethod": "Přepsaná metoda",
        "overriddenSymbol": "Přepsaný symbol",
        "overrideInvariantMismatch": "Typ přepsání „{overrideType}“není stejný jako základní typ „{baseType}“",
        "overrideIsInvariant": "Proměnná je proměnlivá, takže její typ je invariantní",
        "overrideNoOverloadMatches": "Signatura přetížení v přepsání není kompatibilní se základní metodou",
        "overrideNotClassMethod": "Základní metoda je deklarována jako metoda classmethod, ale přepsání není",
        "overrideNotInstanceMethod": "Základní metoda je deklarována jako instanční metoda, ale přepsání není",
        "overrideNotStaticMethod": "Základní metoda je deklarována jako staticmethod, ale přepsání není",
        "overrideOverloadNoMatch": "Přepsání nezahrnuje všechna přetížení metody základní třídy",
        "overrideOverloadOrder": "Přetížení přepisované metody musí být ve stejném pořadí jako základní metoda",
        "overrideParamKeywordNoDefault": "Neshoda parametru klíčového slova „{name}“: základní parametr má výchozí hodnotu argumentu, parametr pro přepsání ne",
        "overrideParamKeywordType": "Neshoda typu parametru klíčového slova „{name}“: základní parametr je typu „{baseType}“, parametr přepsání je typu „{overrideType}“",
        "overrideParamName": "Neshoda názvu parametru {index}: základní parametr má název „{baseName}“, parametr přepsání má název „{overrideName}“",
        "overrideParamNameExtra": "V základu chybí parametr {name}",
        "overrideParamNameMissing": "V přepsání chybí parametr „{name}“",
        "overrideParamNamePositionOnly": "Neshoda parametru {index}: základní parametr {baseName} je parametr klíčového slova, přepisující parametr je pouze pozice",
        "overrideParamNoDefault": "Neshoda parametru {index}: Základní parametr má výchozí hodnotu argumentu, parametr přepsání se neshoduje.",
        "overrideParamType": "Neshoda typu parametru {index}: Základní parametr je typu „{baseType}“, parametr přepsání je typu „{overrideType}“.",
        "overridePositionalParamCount": "Neshoda počtu pozičních parametrů; Základní metoda má „{baseCount}“, ale přepsání má {overrideCount}",
        "overrideReturnType": "Neshoda návratového typu: Základní metoda vrací typ {baseType}, přepsání vrací typ {overrideType}",
        "overrideType": "Základní třída definuje typ jako {type}",
        "paramAssignment": "Parametr {index}: Typ {sourceType} není možné přiřadit typu {destType}",
        "paramSpecMissingInOverride": "V metodě přepsání chybí parametry ParamSpec",
        "paramType": "Typ parametru je {paramType}",
        "privateImportFromPyTypedSource": "Místo toho importovat z modulu {module}",
        "propertyAccessFromProtocolClass": "Vlastnost definovaná v rámci třídy protokolu není přístupná jako proměnná třídy",
        "propertyMethodIncompatible": "Metoda vlastnosti {name} není kompatibilní",
        "propertyMethodMissing": "V přepsání chybí metoda vlastnosti „{name}“",
        "propertyMissingDeleter": "Vlastnost {name} nemá definovaný odstraňovač",
        "propertyMissingSetter": "Vlastnost {name} nemá definovanou metodu setter",
        "protocolIncompatible": "{sourceType} není kompatibilní s protokolem {destType}",
        "protocolMemberMissing": "{name} není k dispozici",
        "protocolRequiresRuntimeCheckable": "Třída protokolu musí být @runtime_checkable, aby se použila při kontrolách instancí a tříd.",
        "protocolSourceIsNotConcrete": "„{sourceType}“ není konkrétní typ třídy a nedá se přiřadit k typu „{destType}“",
        "protocolUnsafeOverlap": "Atributy „{name}“ mají stejné názvy jako protokol.",
        "pyrightCommentIgnoreTip": "Pokud chcete potlačit diagnostiku pro jeden řádek, použijte # pyright: ignore[<diagnostic rules>]",
        "readOnlyAttribute": "Atribut {name} je jen pro čtení",
        "seeClassDeclaration": "Viz deklarace třídy",
        "seeDeclaration": "Viz deklarace",
        "seeFunctionDeclaration": "Viz deklarace funkce",
        "seeMethodDeclaration": "Viz deklarace metody",
        "seeParameterDeclaration": "Viz deklarace parametru",
        "seeTypeAliasDeclaration": "Zobrazit deklaraci aliasu typu",
        "seeVariableDeclaration": "Zobrazit deklaraci proměnné",
        "tupleAssignmentMismatch": "Typ „{type}“ není kompatibilní s cílovou řazenou kolekcí členů",
        "tupleEntryTypeMismatch": "Položka řazené kolekce členů {entry} je nesprávného typu",
        "tupleSizeIndeterminateSrc": "Neshoda velikosti řazené kolekce členů; Očekávalo se {expected}, ale přijalo se neurčité.",
        "tupleSizeIndeterminateSrcDest": "Neshoda velikosti řazené kolekce členů; Očekávalo se min. {expected}, ale přijalo se neurčité.",
        "tupleSizeMismatch": "Neshoda velikosti řazené kolekce členů; Očekávalo se {expected}, ale přijalo se {received}.",
        "tupleSizeMismatchIndeterminateDest": "Neshoda velikosti řazené kolekce členů; Očekávalo se min. {expected}, ale přijalo se {received}.",
        "typeAliasInstanceCheck": "Alias typu vytvořený pomocí příkazu „typ“ se nedá použít s kontrolami instancí a tříd",
        "typeAssignmentMismatch": "Typ {sourceType} se nedá přiřadit k typu {destType}",
        "typeBound": "Typ {sourceType} je nekompatibilní s vázaným typem {destType} pro proměnnou typu {name}",
        "typeConstrainedTypeVar": "Typ {type} není kompatibilní s proměnnou omezeného typu {name}",
        "typeIncompatible": "{sourceType} není kompatibilní s typem {destType}",
        "typeNotClass": "{type} není třída",
        "typeNotStringLiteral": "„{type}“ není řetězcový literál",
        "typeOfSymbol": "Typ „{name}“ je „{type}“",
        "typeParamSpec": "Typ {type} není kompatibilní s parametrem ParamSpec {name}",
        "typeUnsupported": "Typ {type} není podporován",
        "typeVarDefaultOutOfScope": "Proměnná typu {name} není v oboru",
        "typeVarIsContravariant": "Parametr typu „{name}“ je kontravariantní, ale „{sourceType}“ není nadtyp „{destType}“.",
        "typeVarIsCovariant": "Parametr typu „{name}“ je kovariantní, ale „{sourceType}“ není podtyp „{destType}“.",
        "typeVarIsInvariant": "Parametr typu „{name}“ je invariantní, ale „{sourceType}“ není stejný jako „{destType}“.",
        "typeVarNotAllowed": "TypeVar se pro kontroly instancí nebo tříd nepovoluje.",
        "typeVarTupleRequiresKnownLength": "Typ TypeVarTuple nemůže být vázaný na řazenou kolekci členů neznámé délky",
        "typeVarUnnecessarySuggestion": "Místo toho použijte {type}.",
        "typeVarUnsolvableRemedy": "Zadejte přetížení, které určuje návratový typ, pokud argument není zadán",
        "typeVarsMissing": "Chybějící proměnné typu: {names}",
        "typedDictBaseClass": "Třída „{type}“ není TypedDict.",
        "typedDictClassNotAllowed": "Třída TypedDict není povolená pro kontroly instancí nebo tříd.",
        "typedDictClosedExtraNotAllowed": "Do {name} nejde přidat položku.",
        "typedDictClosedExtraTypeMismatch": "Nelze přidat položku {name} s typem {type}.",
        "typedDictClosedFieldNotRequired": "Nelze přidat položku {name}, protože musí být NotRequired.",
        "typedDictExtraFieldNotAllowed": "{name} není k dispozici v {type}",
        "typedDictExtraFieldTypeMismatch": "Typ {name} není kompatibilní s typem __extra_items__ v typu {type}.",
        "typedDictFieldMissing": "V {type} chybí {name}",
        "typedDictFieldNotReadOnly": "{name} není v {type} jen pro čtení",
        "typedDictFieldNotRequired": "{name} se v typu {type} nevyžaduje",
        "typedDictFieldRequired": "{name} se vyžaduje v {type}",
        "typedDictFieldTypeMismatch": "Typ {type} se nedá přiřadit k položce {name}",
        "typedDictFieldUndefined": "{name} je nedefinovaná položka v typu {type}",
        "typedDictFinalMismatch": "{sourceType} není kompatibilní s {destType} z důvodu neshody @final",
        "typedDictNotAllowed": "TypedDict se nedá použít pro kontroly instancí nebo tříd.",
        "unhashableType": "Typ „{type}“ nejde zatřiďovat",
        "uninitializedAbstractVariable": "Proměnná instance {name} je definovaná v abstraktní základní třídě {classType}, ale neinicializovala se",
        "unreachableExcept": "{exceptionType} je podtřídou {parentType}",
        "useDictInstead": "Označte typ slovníku pomocí Dict[T1, T2]",
        "useListInstead": "Použijte List[T] k označení typu seznamu nebo Union[T1, T2] k označení typu sjednocení",
        "useTupleInstead": "Použijte tuple[T1, ..., Tn] k označení typu řazené kolekce členů nebo Union[T1, T2] k označení typu sjednocení",
        "useTypeInstead": "Místo toho použít Type[T]",
        "varianceMismatchForClass": "Odchylka argumentu typu „{typeVarName}“ není kompatibilní se základní třídou „{className}“",
        "varianceMismatchForTypeAlias": "Rozptyl argumentu typu „{typeVarName}“ není kompatibilní s typem „{typeAliasParam}“"
    }
}
