{
    "CodeAction": {
        "createTypeStub": "Utwórz typ zastępczy",
        "createTypeStubFor": "Utwórz typ zastępczy dla „{moduleName}”",
        "executingCommand": "Wykonywanie polecenia",
        "filesToAnalyzeCount": "Pliki do przeanalizowania: {count}",
        "filesToAnalyzeOne": "1 plik do analizy",
        "findingReferences": "Znajdowanie odwołań",
        "organizeImports": "Organizuj dyrektywy Import",
        "renameShadowedFile": "Zmień nazwę „{oldFile}” na „{newFile}”"
    },
    "Completion": {
        "autoImportDetail": "Automatyczne importowanie",
        "indexValueDetail": "Wartość indeksu"
    },
    "Diagnostic": {
        "abstractMethodInvocation": "Nie można wywołać metody „{method}”, ponieważ jest abstrakcyjna i niezaimplementowana",
        "annotatedParamCountMismatch": "Niezgodność liczby adnotacji parametru; oczekiwano {expected}, a uzyskano {received}",
        "annotatedTypeArgMissing": "Oczekiwano jednego argumentu typu i co najmniej jednej adnotacji dla wartości „Annotated”",
        "annotationBytesString": "Adnotacje typu nie mogą używać literałów ciągu bajtów",
        "annotationFormatString": "Adnotacje typu nie mogą używać literałów ciągów formatu (f-strings)",
        "annotationNotSupported": "Adnotacja typu nie jest obsługiwana dla tej instrukcji",
        "annotationRawString": "Adnotacje typu nie mogą używać nieprzetworzonych literałów ciągów",
        "annotationSpansStrings": "Adnotacje typu nie mogą obejmować wielu literałów ciągów",
        "annotationStringEscape": "Adnotacje typu nie mogą zawierać znaków ucieczki",
        "argAssignment": "Argumentu typu „{argType}” nie można przypisać do parametru typu „{paramType}”",
        "argAssignmentFunction": "Argumentu typu „{argType}” nie można przypisać do parametru typu „{paramType}” w funkcji „{functionName}”",
        "argAssignmentParam": "Argumentu typu „{argType}” nie można przypisać do parametru „{paramName}” typu „{paramType}”",
        "argAssignmentParamFunction": "Argumentu typu „{argType}” nie można przypisać do parametru „{paramName}” typu „{paramType}” w funkcji „{functionName}”",
        "argMissingForParam": "Brak argumentu dla parametru {name}",
        "argMissingForParams": "Brak argumentów dla parametrów {names}",
        "argMorePositionalExpectedCount": "Oczekiwano większej liczby argumentów pozycyjnych: {expected}",
        "argMorePositionalExpectedOne": "Oczekiwano jeszcze 1 argumentu pozycyjnego",
        "argPositional": "Oczekiwano argumentu pozycyjnego",
        "argPositionalExpectedCount": "Oczekiwano liczby argumentów pozycyjnych: {expected}",
        "argPositionalExpectedOne": "Oczekiwano 1 argumentu pozycyjnego",
        "argTypePartiallyUnknown": "Typ argumentu jest częściowo nieznany",
        "argTypeUnknown": "Typ argumentu jest nieznany",
        "assertAlwaysTrue": "Wyrażenie Assert zawsze ma wartość Prawda",
        "assertTypeArgs": "Typ „assert_type” oczekuje dwóch argumentów pozycyjnych",
        "assertTypeTypeMismatch": "Niezgodność „assert_type”; oczekiwano „{expected}”, ale otrzymano „{received}”",
        "assignmentExprComprehension": "Element docelowy wyrażenia przypisania „{name}” nie może używać tej samej nazwy co zrozumienie dla elementu docelowego",
        "assignmentExprContext": "Wyrażenie przypisania musi należeć do modułu, funkcji lub wyrażenia lambda",
        "assignmentExprInSubscript": "Wyrażenia przypisania w indeksie dolnym są obsługiwane tylko w języku Python w wersji 3.10 i nowszej",
        "assignmentInProtocol": "Zmienne wystąpienia lub klasy w klasie protokołu muszą być jawnie zadeklarowane w treści klasy",
        "assignmentTargetExpr": "Wyrażenie nie może być elementem docelowym przypisania",
        "asyncNotInAsyncFunction": "Użycie wartość „async” jest niedozwolone poza funkcją asynchroniczną",
        "awaitIllegal": "Użycie „oczekiwania” wymaga języka Python w wersji 3.5 lub nowszej",
        "awaitNotAllowed": "Adnotacje typu nie mogą używać elementu „await”",
        "awaitNotInAsync": "Wartość „await” jest dozwolona tylko w ramach funkcji asynchronicznej",
        "backticksIllegal": "Wyrażenia otoczone znakami wstecznymi nie są obsługiwane w języku Python w wersji 3.x; zamiast tego użyj wyrażenia repr",
        "baseClassCircular": "Klasa nie może pochodzić od samej siebie",
        "baseClassFinal": "Klasa bazowa „{type}” jest oznaczona jako końcowa i nie można jej podzielić na podklasy",
        "baseClassIncompatible": "Klasy bazowe typu {type} są wzajemnie niezgodne",
        "baseClassInvalid": "Argument klasy musi być klasą bazową",
        "baseClassMethodTypeIncompatible": "Klasy bazowe dla klasy „{classType}” definiują metodę „{name}” w niezgodny sposób",
        "baseClassUnknown": "Typ klasy bazowej jest nieznany, zasłaniając typ klasy pochodnej",
        "baseClassVariableTypeIncompatible": "Klasy bazowe dla klasy „{classType}” definiują zmienną „{name}” w niezgodny sposób",
        "binaryOperationNotAllowed": "Operator binarny nie jest dozwolony w adnotacji typu",
        "bindTypeMismatch": "Nie można powiązać metody „{methodName}”, ponieważ nie można przypisać typu „{type}” do parametru „{paramName}”",
        "breakOutsideLoop": "Wartość „break” może być używana tylko w pętli",
        "callableExtraArgs": "Oczekiwano tylko dwóch argumentów typu „Callable”",
        "callableFirstArg": "Oczekiwano listy typów parametrów lub znaków „...”",
        "callableNotInstantiable": "Nie można utworzyć wystąpienia typu „{type}”",
        "callableSecondArg": "Oczekiwano zwracanego typu jako drugiego argumentu typu dla elementu „Callable”",
        "casePatternIsIrrefutable": "Niepodważalny wzorzec jest dozwolony tylko dla ostatniej instrukcji dotyczącej wielkości liter",
        "classAlreadySpecialized": "Typ „{type}” jest już wyspecjalizowany",
        "classDecoratorTypeUnknown": "Dekorator klasy bez typu przesłania typ klasy; ignorowanie dekoratora",
        "classDefinitionCycle": "Definicja klasy dla „{name}” zależy od niej samej",
        "classGetItemClsParam": "Przesłonięcie __class_getitem__ powinno przyjmować parametr „cls”.",
        "classMethodClsParam": "Metody klasy powinny przyjmować parametr „cls”",
        "classNotRuntimeSubscriptable": "Indeks dolny dla klasy „{name}” wygeneruje wyjątek czasu uruchamiania; umieść adnotację typu w cudzysłowie",
        "classPatternBuiltInArgPositional": "Wzorzec klasy akceptuje tylko podwzorzec pozycyjny",
        "classPatternPositionalArgCount": "Zbyt wiele wzorców pozycyjnych dla klasy „{type}”; oczekiwano {expected}, ale otrzymano {received}",
        "classPatternTypeAlias": "„{type}” nie może być używany we wzorcu klasy, ponieważ jest to alias typu specjalnego",
        "classPropertyDeprecated": "Właściwości klasy są przestarzałe w języku Python 3.11 i nie będą obsługiwane w języku Python 3.13",
        "classTypeParametersIllegal": "Składnia parametru typu klasy wymaga języka Python w wersji 3.12 lub nowszej",
        "classVarFirstArgMissing": "Oczekiwano argumentu typu po wartości „ClassVar”",
        "classVarNotAllowed": "Element „ClassVar” jest niedozwolony w tym kontekście",
        "classVarOverridesInstanceVar": "Zmienna klasy „{name}” przesłania zmienną wystąpienia o tej samej nazwie w klasie „{className}”",
        "classVarTooManyArgs": "Oczekiwano tylko jednego argumentu typu po wartości „ClassVar”",
        "classVarWithTypeVar": "Typ „ClassVar” nie może zawierać zmiennych typu",
        "clsSelfParamTypeMismatch": "Typ parametru „{name}” musi być nadtypem jego klasy „{classType}”",
        "codeTooComplexToAnalyze": "Kod jest zbyt złożony, aby go analizować; zmniejsz złożoność przez refaktoryzację w podprocedury lub poprzez zmniejszenie ścieżek kodu warunkowego",
        "collectionAliasInstantiation": "Nie można utworzyć wystąpienia typu „{type}”. Zamiast niego użyj „{alias}”",
        "comparisonAlwaysFalse": "Warunek zawsze będzie miał wartość Fałsz, ponieważ typy „{leftType}” i „{rightType}” nie nakładają się",
        "comparisonAlwaysTrue": "Warunek zawsze będzie miał wartość Prawda, ponieważ typy „{leftType}” i „{rightType}” nie nakładają się",
        "comprehensionInDict": "Zrozumienia nie można używać z innymi wpisami słownika",
        "comprehensionInSet": "Nie można używać rozumienia z innymi wpisami zestawu",
        "concatenateContext": "„Łączenie” jest niedozwolone w tym kontekście",
        "concatenateParamSpecMissing": "Ostatni argument typu dla elementu „Concatenate” musi mieć wartość ParamSpec lub „...”",
        "concatenateTypeArgsMissing": "Element „Concatenate” wymaga co najmniej dwóch argumentów typu",
        "conditionalOperandInvalid": "Nieprawidłowy warunkowy argument operacji typu „{type}”",
        "constantRedefinition": "Nazwa „{name}” jest stałą (ponieważ jest pisana wielkimi literami) i nie można jej ponownie zdefiniować",
        "constructorNoArgs": "Oczekiwano braku argumentów do konstruktora „{type}”.",
        "constructorParametersMismatch": "Niezgodność między sygnaturą „__new__” i „__init__” w klasie „{classType}”",
        "containmentAlwaysFalse": "Warunek zawsze będzie miał wartość „Fałsz”, ponieważ typy „{leftType}” i „{rightType}” nie nakładają się na siebie",
        "containmentAlwaysTrue": "Warunek zawsze będzie miał wartość „True”, ponieważ typy „{leftType}” i „{rightType}” nie nakładają się na siebie",
        "continueInFinally": "Wartość „continue” nie może być używana w klauzuli finally",
        "continueOutsideLoop": "Wartość „continue” może być używana tylko w pętli",
        "coroutineInConditionalExpression": "Wyrażenie warunkowe odwołuje się do koprocedury, która zawsze wyznacza wartość True",
        "dataClassBaseClassFrozen": "Klasa niezablokowana nie może dziedziczyć po klasie zablokowanej",
        "dataClassBaseClassNotFrozen": "Zamrożona klasa nie może dziedziczyć po klasie niezamrożonej",
        "dataClassConverterFunction": "Argument typu „{argType}” nie jest prawidłowym konwerterem pola „{fieldName}” typu „{fieldType}”",
        "dataClassConverterOverloads": "Żadne przeciążenia „{funcName}” nie są prawidłowymi konwerterami dla pola „{fieldName}” typu „{fieldType}”",
        "dataClassFieldInheritedDefault": "Pole „{fieldName}” zastępuje pole o tej samej nazwie, ale brakuje wartości domyślnej",
        "dataClassFieldWithDefault": "Pola bez wartości domyślnych nie mogą występować po polach z wartościami domyślnymi",
        "dataClassFieldWithPrivateName": "Pole klasy danych nie może używać nazwy prywatnej",
        "dataClassFieldWithoutAnnotation": "Pole klasy danych bez adnotacji typu spowoduje wyjątek środowiska uruchomieniowego",
        "dataClassPostInitParamCount": "Klasa danych __post_init__ ma niepoprawną liczbę parametrów; oczekiwana liczba pól InitVar to: {expected}",
        "dataClassPostInitType": "Klasa danych __post_init__ ma niezgodność typu parametru metody dla pola „{fieldName}”",
        "dataClassSlotsOverwrite": "Element __slots__ jest już zdefiniowany w klasie",
        "dataClassTransformExpectedBoolLiteral": "Oczekiwano wyrażenia, które statycznie daje w wyniku wartość True lub False",
        "dataClassTransformFieldSpecifier": "Oczekiwano krotki klas lub funkcji, a uzyskano typ „{type}”",
        "dataClassTransformPositionalParam": "Wszystkie argumenty elementu „dataclass_transform” muszą być argumentami słów kluczowych",
        "dataClassTransformUnknownArgument": "Argument „{name}” nie jest obsługiwany przez dataclass_transform",
        "dataProtocolInSubclassCheck": "Protokoły danych (które zawierają atrybuty niebędące atrybutami metody) są niedozwolone w wywołaniach klasy issubclass",
        "declaredReturnTypePartiallyUnknown": "Zadeklarowany zwracany typ „{returnType}” jest częściowo nieznany",
        "declaredReturnTypeUnknown": "Deklarowany zwracany typ jest nieznany",
        "defaultValueContainsCall": "Wywołania funkcji i modyfikowalne obiekty są niedozwolone w wyrażeniu wartości domyślnej parametru",
        "defaultValueNotAllowed": "Parametr o wartości „*” lub „**” nie może mieć wartości domyślnej",
        "delTargetExpr": "Nie można usunąć wyrażenia",
        "deprecatedClass": "Klasa „{name}” jest przestarzała",
        "deprecatedConstructor": "Konstruktor klasy „{name}” jest przestarzały",
        "deprecatedDescriptorDeleter": "Metoda „__set__” dla deskryptora „{name}” jest przestarzała",
        "deprecatedDescriptorGetter": "Metoda „__set__” dla deskryptora „{name}” jest przestarzała",
        "deprecatedDescriptorSetter": "Metoda „__set__” dla deskryptora „{name}” jest przestarzała",
        "deprecatedFunction": "Ta funkcja „{name}” jest przestarzała",
        "deprecatedMethod": "Metoda „{name}” w klasie „{className}” jest przestarzała",
        "deprecatedPropertyDeleter": "Metoda usuwająca dla właściwości „{name}” jest przestarzała",
        "deprecatedPropertyGetter": "Metoda pobierająca dla właściwości „{name}” jest przestarzała",
        "deprecatedPropertySetter": "Metoda pobierająca dla właściwości „{name}” jest przestarzała",
        "deprecatedType": "Ten typ jest przestarzały dla języka Python w wersji {version}; zamiast tego użyj „{replacement}”.",
        "dictExpandIllegalInComprehension": "Rozszerzanie słownika jest niedozwolone w rozumieniu",
        "dictInAnnotation": "Wyrażenie słownikowe jest niedozwolone w adnotacji typu",
        "dictKeyValuePairs": "Wpisy słownika muszą zawierać pary klucz/wartość",
        "dictUnpackIsNotMapping": "Oczekiwano mapowania dla operatora rozpakowywania słownika",
        "dunderAllSymbolNotPresent": "Nazwa „{name}” jest określona w wartości __all__, ale nie występuje w module",
        "duplicateArgsParam": "Dozwolony tylko jeden parametr „*”",
        "duplicateBaseClass": "Zduplikowana klasa bazowa jest niedozwolona",
        "duplicateCapturePatternTarget": "Element docelowy przechwytywania „{name}” nie może występować więcej niż raz w obrębie tego samego wzorca",
        "duplicateCatchAll": "Dozwolona jest tylko jedna klauzula typu catch-all z wyjątkiem klauzuli",
        "duplicateEnumMember": "Składowa wyliczenia „{name}” jest już zadeklarowana",
        "duplicateGenericAndProtocolBase": "Dozwolona jest tylko jedna klasa bazowa Generic[...] lub Protocol[...].",
        "duplicateImport": "Nazwa „{importName}” została zaimportowana więcej niż raz",
        "duplicateKeywordOnly": "Dozwolony tylko jeden separator „*”.",
        "duplicateKwargsParam": "Dozwolony tylko jeden parametr „**”.",
        "duplicateParam": "Duplikuj parametr „{name}”",
        "duplicatePositionOnly": "Dozwolony tylko jeden parametr „/”",
        "duplicateStarPattern": "W sekwencji wzorca dozwolony jest tylko jeden wzorzec „*”",
        "duplicateStarStarPattern": "Dozwolony jest tylko jeden wpis „**”",
        "duplicateUnpack": "Na liście dozwolona jest tylko jedna operacja rozpakowywania",
        "ellipsisAfterUnpacked": "Nie można używać „...” z rozpakowanym typeVarTuple lub krotką",
        "ellipsisContext": "Wartość „...” jest niedozwolona w tym kontekście",
        "ellipsisSecondArg": "Wartość „...” jest dozwolona tylko jako drugi z dwóch argumentów",
        "enumClassOverride": "Klasa wyliczenia „{name}” jest ostateczna i nie można jej podzielić na podklasy",
        "exceptionGroupIncompatible": "Składnia grupy wyjątków („except*”) wymaga języka Python w wersji 3.11 lub nowszej",
        "exceptionTypeIncorrect": "Typ „{type}” nie pochodzi od parametru BaseException",
        "exceptionTypeNotClass": "Typ „{type}” nie jest prawidłową klasą wyjątku",
        "exceptionTypeNotInstantiable": "Konstruktor typu wyjątku „{type}” wymaga co najmniej jednego argumentu",
        "expectedAfterDecorator": "Oczekiwano deklaracji funkcji lub klasy po dekoratorze",
        "expectedArrow": "Oczekiwano wartości „->”, po której następuje adnotacja zwracanego typu",
        "expectedAsAfterException": "Oczekiwano „jako” po typie wyjątku",
        "expectedAssignRightHandExpr": "Oczekiwano wyrażenia po prawej stronie znaku „=”",
        "expectedBinaryRightHandExpr": "Oczekiwano wyrażenia po prawej stronie operatora",
        "expectedBoolLiteral": "Oczekiwano wartości True lub False",
        "expectedCase": "Oczekiwano instrukcji „case”",
        "expectedClassName": "Oczekiwano nazwy klasy",
        "expectedCloseBrace": "Brak zamknięcia dla: „{”",
        "expectedCloseBracket": "Brak zamknięcia dla: „[”",
        "expectedCloseParen": "Brak zamknięcia dla: „(”",
        "expectedColon": "Oczekiwano „:”",
        "expectedComplexNumberLiteral": "Oczekiwano literału liczby zespolonej na potrzeby dopasowywania wzorca",
        "expectedDecoratorExpr": "Formularz wyrażenia nie jest obsługiwany przez dekorator w wersji wcześniejszej niż Python 3.9",
        "expectedDecoratorName": "Oczekiwano nazwy dekoratora",
        "expectedDecoratorNewline": "Oczekiwano nowego wiersza na końcu dekoratora",
        "expectedDelExpr": "Oczekiwano wyrażenia po „del”",
        "expectedElse": "Oczekiwano elementu „innego”",
        "expectedEquals": "Oczekiwano „=”",
        "expectedExceptionClass": "Nieprawidłowa klasa lub obiekt wyjątku",
        "expectedExceptionObj": "Oczekiwano obiektu wyjątku, klasy wyjątku lub wartości Brak",
        "expectedExpr": "Oczekiwano wyrażenia",
        "expectedFunctionAfterAsync": "Oczekiwano definicji funkcji po wartości „async”",
        "expectedFunctionName": "Oczekiwano nazwy funkcji po wyrażeniu „def”",
        "expectedIdentifier": "Oczekiwany identyfikator",
        "expectedImport": "Oczekiwano wartości „import”",
        "expectedImportAlias": "Oczekiwano symbolu po parametrze „as”",
        "expectedImportSymbols": "Oczekiwano jednej lub więcej nazw symboli po zaimportowaniu",
        "expectedIn": "Oczekiwano parametru „in”",
        "expectedInExpr": "Oczekiwano wyrażenia po „in”",
        "expectedIndentedBlock": "Oczekiwano wciętego bloku",
        "expectedMemberName": "Oczekiwano nazwy atrybutu po „.”",
        "expectedModuleName": "Oczekiwana nazwa modułu",
        "expectedNameAfterAs": "Oczekiwano nazwy symbolu po „jako”",
        "expectedNamedParameter": "Parametr słowa kluczowego musi następować po znaku „*”",
        "expectedNewline": "Oczekiwano nowego wiersza",
        "expectedNewlineOrSemicolon": "Instrukcje muszą być oddzielone znakami nowych wierszy lub średnikami",
        "expectedOpenParen": "Oczekiwano „(”",
        "expectedParamName": "Oczekiwano nazwy parametru",
        "expectedPatternExpr": "Oczekiwano wyrażenia wzorca",
        "expectedPatternSubjectExpr": "Oczekiwano wyrażenia tematu wzorca",
        "expectedPatternValue": "Oczekiwano wyrażenia wartości wzorca w postaci „a.b”",
        "expectedReturnExpr": "Oczekiwano wyrażenia po „return”.",
        "expectedSliceIndex": "Oczekiwano wyrażenia indeksu lub wycinka",
        "expectedTypeNotString": "Oczekiwano typu, ale otrzymano literał ciągu",
        "expectedTypeParameterName": "Oczekiwano nazwy parametru typu",
        "expectedYieldExpr": "Oczekiwano wyrażenia w instrukcji wstrzymywania",
        "finalClassIsAbstract": "Klasa „{type}” jest oznaczona jako ostateczna i musi implementować wszystkie symbole abstrakcyjne",
        "finalContext": "Wartość „Final” jest niedozwolona w tym kontekście",
        "finalMethodOverride": "Metoda „{name}” nie może przesłonić metody końcowej zdefiniowanej w klasie „{className}”",
        "finalNonMethod": "Nie można oznaczyć funkcji „{name}” jako @final, ponieważ nie jest to metoda",
        "finalReassigned": "Element „{name}” jest zadeklarowany jako wersja ostateczna i nie można go ponownie przypisać",
        "finalRedeclaration": "Nazwa „{name}” została wcześniej zadeklarowana jako końcowa",
        "finalRedeclarationBySubclass": "Nie można ponownie zadeklarować nazwy „{name}”, ponieważ klasa nadrzędna „{className}” deklaruje ją jako końcową",
        "finalTooManyArgs": "Oczekiwano jednego argumentu typu po wartości „Final”",
        "finalUnassigned": "Nazwa „{name}” jest zadeklarowana jako końcowa, ale wartość nie jest przypisana",
        "formatStringBrace": "Pojedynczy zamykający nawias klamrowy jest niedozwolony w literale ciągu f; użyj podwójnego zamykającego nawiasu klamrowego",
        "formatStringBytes": "Literały ciągów formatu (ciągi f) nie mogą być binarne",
        "formatStringDebuggingIllegal": "Specyfikator debugowania ciągu f „=” wymaga wersji języka Python 3.8 lub nowszej",
        "formatStringEscape": "Sekwencja ucieczki (ukośnik odwrotny) jest niedozwolona w części wyrażenia ciągu f w wersji języka wcześniejszej niż Python 3.12",
        "formatStringExpectedConversion": "Oczekiwano specyfikatora konwersji po znaku „!” w ciągu f-string",
        "formatStringIllegal": "Literały ciągów formatu (ciągi f) wymagają wersji języka Python 3.6 lub nowszej",
        "formatStringInPattern": "Ciąg formatu jest niedozwolony we wzorcu",
        "formatStringNestedFormatSpecifier": "Wyrażenia zagnieżdżone zbyt głęboko w specyfikatorze ciągu formatu",
        "formatStringNestedQuote": "Ciągi zagnieżdżone w ciągu f nie mogą używać tego samego znaku cudzysłowu co ciąg f w wersji języka wcześniejszej niż Python 3.12",
        "formatStringUnicode": "Literały ciągu formatu (f-strings) nie mogą być formatu unicode",
        "formatStringUnterminated": "Niezakończone wyrażenie w ciągu f; oczekiwano znaku „}”",
        "functionDecoratorTypeUnknown": "Nietypowany dekorator funkcji zasłania typ funkcji; ignorując dekoratora",
        "functionInConditionalExpression": "Wyrażenie warunkowe odwołuje się do funkcji, której wynikiem zawsze jest wartość Prawda",
        "functionTypeParametersIllegal": "Składnia parametru typu klasy wymaga wersji języka Python 3.12 lub nowszej",
        "futureImportLocationNotAllowed": "Importy z __future__ muszą znajdować się na początku pliku",
        "generatorAsyncReturnType": "Zwracany typ funkcji generatora asynchronicznego musi być zgodny z elementem „AsyncGenerator[{yieldType}, Any]”",
        "generatorNotParenthesized": "Wyrażenia generatora muszą być ujęte w nawiasy, jeśli nie są jedynym argumentem",
        "generatorSyncReturnType": "Zwracany typ funkcji generatora musi być zgodny z elementem „Generator[{yieldType}, Any, Any]”",
        "genericBaseClassNotAllowed": "Nie można użyć klasy bazowej „Generic” ze składnią parametru typu",
        "genericClassAssigned": "Nie można przypisać ogólnego typu klasy",
        "genericClassDeleted": "Nie można usunąć ogólnego typu klasy",
        "genericInstanceVariableAccess": "Dostęp do ogólnej zmiennej wystąpienia za pośrednictwem klasy jest niejednoznaczny",
        "genericNotAllowed": "Element „ogólny” jest nieprawidłowy w tym kontekście",
        "genericTypeAliasBoundTypeVar": "Alias typu ogólnego w klasie nie może używać zmiennych typu powiązanego {names}",
        "genericTypeArgMissing": "Wartość „Generic” wymaga co najmniej jednego argumentu typu",
        "genericTypeArgTypeVar": "Argument typu dla wartości „Generic” musi być zmienną typu",
        "genericTypeArgUnique": "Argumenty typu dla elementu „Generic” muszą być unikatowe",
        "globalReassignment": "Nazwa „{name}” jest przypisywana przed deklaracją globalną",
        "globalRedefinition": "Nazwa „{name}” została już zadeklarowana jako globalna",
        "implicitStringConcat": "Niejawne łączenie ciągów jest niedozwolone",
        "importCycleDetected": "Wykryto cykl w łańcuchu importu",
        "importDepthExceeded": "Głębokość łańcucha importu przekroczyła {depth}",
        "importResolveFailure": "Nie można rozpoznać importu „{importName}”.",
        "importSourceResolveFailure": "Nie można rozpoznać importu „{importName}” ze źródła",
        "importSymbolUnknown": "Nazwa „{name}” jest nieznanym symbolem importu",
        "incompatibleMethodOverride": "Metoda „{name}” przesłania klasę „{className}” w niezgodny sposób",
        "inconsistentIndent": "Wartość zmniejszenia wcięcia jest niezgodna z poprzednim wcięciem",
        "inconsistentTabs": "Niespójne użycie tabulatorów i spacji we wcięciach",
        "initMethodSelfParamTypeVar": "Adnotacja typu dla parametru „self” metody „__init__” nie może zawierać zmiennych typu o zakresie klasy",
        "initMustReturnNone": "Zwracany typ „__init__” musi mieć wartość Brak",
        "initSubclassCallFailed": "Nieprawidłowe argumenty słów kluczowych dla metody __init_subclass__",
        "initSubclassClsParam": "Przesłonięcie __init_subclass__ powinno przyjmować parametr „cls”.",
        "initVarNotAllowed": "Element „InitVar” jest niedozwolony w tym kontekście",
        "instanceMethodSelfParam": "Metody wystąpienia powinny przyjmować parametr „self”",
        "instanceVarOverridesClassVar": "Zmienna wystąpienia „{name}” zastępuje zmienną klasy o tej samej nazwie w klasie „{className}”",
        "instantiateAbstract": "Nie można utworzyć wystąpienia klasy abstrakcyjnej „{type}”",
        "instantiateProtocol": "Nie można utworzyć wystąpienia klasy protokołu typu „{type}”",
        "internalBindError": "Wystąpił błąd wewnętrzny podczas wiązania pliku „{file}”: {message}",
        "internalParseError": "Wystąpił błąd wewnętrzny podczas analizowania pliku „{file}”: {message}",
        "internalTypeCheckingError": "Wystąpił błąd wewnętrzny podczas sprawdzania typu pliku „{file}”: {message}",
        "invalidIdentifierChar": "Nieprawidłowy znak w identyfikatorze",
        "invalidStubStatement": "Instrukcja nie ma znaczenia w pliku zastępczym typu",
        "invalidTokenChars": "Nieprawidłowy znak „{text}” w tokenie",
        "isInstanceInvalidType": "Drugi argument instrukcji „isinstance” musi być klasą lub krotką klas",
        "isSubclassInvalidType": "Drugi argument „issubclass” musi być klasą lub krotką klas",
        "keyValueInSet": "Pary klucz/wartość nie są dozwolone w zestawie",
        "keywordArgInTypeArgument": "Argumentów słów kluczowych nie można używać na listach argumentów typu",
        "keywordOnlyAfterArgs": "Separator argumentów tylko ze słowami kluczowymi jest niedozwolony po parametrze „*”",
        "keywordParameterMissing": "Co najmniej jeden parametr słowa kluczowego musi występować po parametrze „*”",
        "keywordSubscriptIllegal": "Argumenty słów kluczowych w indeksach podrzędnych nie są obsługiwane",
        "lambdaReturnTypePartiallyUnknown": "Zwracany typ wyrażenia lambda „{returnType}” jest częściowo nieznany",
        "lambdaReturnTypeUnknown": "Zwracany typ wyrażenia lambda jest nieznany",
        "listAssignmentMismatch": "Wyrażenia typu „{type}” nie można przypisać do listy docelowej",
        "listInAnnotation": "Wyrażenie listy jest niedozwolone w adnotacji typu",
        "literalEmptyArgs": "Oczekiwano co najmniej jednego argumentu typu po wartości „Literal”",
        "literalNamedUnicodeEscape": "Nazwane sekwencje ucieczki Unicode nie są obsługiwane w adnotacjach ciągów „Literal”",
        "literalNotAllowed": "„Literał” nie może być używany w tym kontekście bez argumentu typu",
        "literalNotCallable": "Nie można utworzyć wystąpienia typu literału",
        "literalUnsupportedType": "Argumenty typu dla elementu „Literal” muszą mieć wartość Brak, wartość literału (int, bool, str lub bytes) lub wartość wyliczenia",
        "matchIncompatible": "Instrukcje dopasowania wymagają języka Python w wersji 3.10 lub nowszej",
        "matchIsNotExhaustive": "Przypadki w instrukcji dopasowania nie obsługują wyczerpująco wszystkich wartości",
        "maxParseDepthExceeded": "Przekroczono maksymalną głębokość analizy; podziel wyrażenie na mniejsze wyrażenia podrzędne",
        "memberAccess": "Nie można uzyskać dostępu do atrybutu „{name}” dla klasy „{type}”",
        "memberDelete": "Nie można usunąć atrybutu „{name}” dla klasy „{type}”",
        "memberSet": "Nie można przypisać atrybutu „{name}” dla klasy „{type}”",
        "metaclassConflict": "Metaklasa klasy pochodnej musi być podklasą metaklas wszystkich jej klas bazowych",
        "metaclassDuplicate": "Można podać tylko jedną metaklasę",
        "metaclassIsGeneric": "Metaklasa nie może być ogólna",
        "methodNotDefined": "Nie zdefiniowano metody „{name}”.",
        "methodNotDefinedOnType": "Metoda „{name}” nie została zdefiniowana dla typu „{type}”",
        "methodOrdering": "Nie można utworzyć spójnej kolejności metod",
        "methodOverridden": "„{name}” przesłania metodę o tej samej nazwie w klasie „{className}” o niezgodnym typie „{type}”",
        "methodReturnsNonObject": "Metoda „{name}” nie zwraca obiektu",
        "missingSuperCall": "Metoda „{methodName}” nie wywołuje metody o tej samej nazwie w klasie nadrzędnej",
        "moduleAsType": "Nie można użyć modułu jako typu",
        "moduleNotCallable": "Moduł nie jest wywoływalny",
        "moduleUnknownMember": "„{memberName}” nie jest znanym atrybutem modułu „{moduleName}”",
        "namedExceptAfterCatchAll": "Nazwana klauzula „except” nie może występować po klauzuli „catch-all except”",
        "namedParamAfterParamSpecArgs": "Parametr słowa kluczowego \"{name}\" nie może występować w sygnaturze po parametrze argumentów ParamSpec",
        "namedTupleEmptyName": "Nazwy w nazwanej krotce nie mogą być puste",
        "namedTupleEntryRedeclared": "Nie można nadpisać „{name}”, ponieważ klasa nadrzędna „{className}” jest nazwaną krotką.",
        "namedTupleFirstArg": "Oczekiwano nazwanej nazwy klasy krotki jako pierwszego argumentu",
        "namedTupleMultipleInheritance": "Wielokrotne dziedziczenie z kotki NamedTuple nie jest obsługiwane",
        "namedTupleNameKeyword": "Nazwy pól nie mogą być słowem kluczowym",
        "namedTupleNameType": "Oczekiwano krotki z dwoma wpisami określającej nazwę i typ wpisu",
        "namedTupleNameUnique": "Nazwy w nazwanej krotce muszą być unikatowe",
        "namedTupleNoTypes": "Krotka „namedtuple” nie zapewnia typów wpisów krotki; zamiast tego użyj „NamedTuple”.",
        "namedTupleSecondArg": "Oczekiwano nazwanej listy wpisów krotki jako drugiego argumentu",
        "newClsParam": "Przesłonięcie __new__ powinno przyjmować parametr „cls”.",
        "newTypeAnyOrUnknown": "Drugi argument elementu NewType musi być znaną klasą, a nie dowolną lub nieznaną",
        "newTypeBadName": "Pierwszy argument elementu NewType musi być literałem ciągu",
        "newTypeLiteral": "Typ NewType nie może być używany z typem Literał",
        "newTypeNameMismatch": "Element NewType musi być przypisany do zmiennej o tej samej nazwie",
        "newTypeNotAClass": "Oczekiwano klasy jako drugiego argumentu dla elementu NewType",
        "newTypeParamCount": "Typ NewType wymaga dwóch argumentów pozycyjnych",
        "newTypeProtocolClass": "Elementu NewType nie można używać z typem strukturalnym (protokołem lub klasą TypedDict)",
        "noOverload": "Żadne przeciążenia dla nazwy „{name}” nie pasują do podanych argumentów",
        "noReturnContainsReturn": "Funkcja z zadeklarowanym zwracanym typem „NoReturn” nie może zawierać instrukcji Return",
        "noReturnContainsYield": "Funkcja z zadeklarowanym zwracanym typem „NoReturn” nie może zawierać instrukcji Yield",
        "noReturnReturnsNone": "Funkcja z zadeklarowanym typem zwracanym „NoReturn” nie może zwracać wartości „None”",
        "nonDefaultAfterDefault": "Argument inny niż domyślny następuje po argumencie domyślnym",
        "nonLocalInModule": "Deklaracja nielokalna nie jest dozwolona na poziomie modułu",
        "nonLocalNoBinding": "Nie znaleziono powiązania dla nielokalnej nazwy „{name}”.",
        "nonLocalReassignment": "Nazwa „{name}” jest przypisywana przed deklaracją nielokalną",
        "nonLocalRedefinition": "Nazwa „{name}” została już zadeklarowana jako nielokalna",
        "noneNotCallable": "Nie można wywołać obiektu typu „None”",
        "noneNotIterable": "Obiekt typu „Brak” nie może być używany jako wartość iterowalna",
        "noneNotSubscriptable": "Obiekt typu „None” nie może być użyty w indeksie dolnym",
        "noneNotUsableWith": "Obiekt typu „Brak” nie może być używany z parametrem „with”",
        "noneOperator": "Operator „{operator}” nie jest obsługiwany dla wartości „Brak”",
        "noneUnknownMember": "„{name}” nie jest znanym atrybutem „Brak”",
        "notRequiredArgCount": "Oczekiwano jednego argumentu typu po wartości „NotRequired”",
        "notRequiredNotInTypedDict": "Element „NotRequired” jest niedozwolony w tym kontekście",
        "objectNotCallable": "Obiekt typu „{type}” nie jest wywoływalny",
        "obscuredClassDeclaration": "Deklaracja klasy „{name}” jest zasłonięta przez deklarację o tej samej nazwie",
        "obscuredFunctionDeclaration": "Deklaracja funkcji „{name}” jest zasłonięta przez deklarację o tej samej nazwie",
        "obscuredMethodDeclaration": "Deklaracja metody „{name}” jest zasłonięta przez deklarację o tej samej nazwie",
        "obscuredParameterDeclaration": "Deklaracja parametru „{name}” jest zasłonięta przez deklarację o tej samej nazwie",
        "obscuredTypeAliasDeclaration": "Deklaracja aliasu typu „{name}” jest zasłonięta przez deklarację o tej samej nazwie",
        "obscuredVariableDeclaration": "Deklaracja „{name}” jest zasłonięta przez deklarację o tej samej nazwie",
        "operatorLessOrGreaterDeprecated": "Operator „<>” nie jest obsługiwany w języku Python w wersji 3; zamiast tego użyj „!=”.",
        "optionalExtraArgs": "Oczekiwano jednego argumentu typu po parametrze „Optional”",
        "orPatternIrrefutable": "Niepodważalny wzorzec jest dozwolony tylko jako ostatni podwzorzec we wzorcu „or”",
        "orPatternMissingName": "Wszystkie wzorce podrzędne we wzorcu „or” muszą dotyczyć tych samych nazw",
        "overlappingKeywordArgs": "Wpisany słownik nakłada się na parametr słowa kluczowego: {names}",
        "overlappingOverload": "Przeciążenie {obscured} dla nazwy „{name}” nigdy nie zostanie użyte, ponieważ jego parametry nakładają się na przeciążenie {obscuredBy}",
        "overloadAbstractMismatch": "Przeciążone metody muszą być abstrakcyjne lub nieabstrakcyjne",
        "overloadClassMethodInconsistent": "Przeciążenia dla nazwy „{name}” używają metody @classmethod niekonsekwentnie",
        "overloadFinalInconsistencyImpl": "Przeciążenie elementu „{name}” jest oznaczone @final, ale implementacja nie jest",
        "overloadFinalInconsistencyNoImpl": "Przeciążenie {index} dla elementu „{name}” jest oznaczone @final, ale przeciążenie 1 nie jest",
        "overloadImplementationMismatch": "Przeciążone wdrożenie jest niespójne z sygnaturą przeciążenia {index}",
        "overloadReturnTypeMismatch": "Przeciążenie {prevIndex} dla nazwy „{name}” nakłada się na przeciążenie {newIndex} i zwraca niezgodny typ",
        "overloadStaticMethodInconsistent": "Przeciążenia dla nazwy „{name}” używają metody @staticmethod niekonsekwentnie",
        "overloadWithoutImplementation": "Element „{name}” jest oznaczony jako przeciążony, ale nie podano implementacji",
        "overriddenMethodNotFound": "Metoda „{name}” jest oznaczona jako zastąpienie, ale nie istnieje metoda bazowa o tej samej nazwie",
        "overrideDecoratorMissing": "Metoda „{name}” nie jest oznaczona jako zastąpienie, ale zastępuje metodę w klasie „{className}”",
        "paramAfterKwargsParam": "Parametr nie może następować po parametrze „**”",
        "paramAlreadyAssigned": "Parametr „{name}” jest już przypisany",
        "paramAnnotationMissing": "Brak adnotacji typu dla parametru „{name}”",
        "paramAssignmentMismatch": "Wyrażenia typu „{sourceType}” nie można przypisać do parametru typu „{paramType}”",
        "paramNameMissing": "Brak parametru o nazwie „{name}”",
        "paramSpecArgsKwargsUsage": "Atrybuty „args” i „kwargs” specyfikacji ParamSpec muszą znajdować się w sygnaturze funkcji",
        "paramSpecArgsMissing": "Brak argumentów dla parametru ParamSpec „{type}”.",
        "paramSpecArgsUsage": "Atrybut „args” parametru ParamSpec jest ważna tylko wtedy, gdy jest używana z parametrem *args",
        "paramSpecAssignedName": "Parametr ParamSpec musi być przypisany do zmiennej o nazwie „{name}”",
        "paramSpecContext": "Wartość ParamSpec jest niedozwolona w tym kontekście",
        "paramSpecDefaultNotTuple": "Oczekiwano wielokropka, wyrażenia krotki lub parametru ParamSpec dla domyślnej wartości ParamSpec",
        "paramSpecFirstArg": "Oczekiwano nazwy parametru ParamSpec jako pierwszego argumentu",
        "paramSpecKwargsUsage": "Atrybut „kwargs” parametru ParamSpec jest ważna tylko wtedy, gdy jest używana z parametrem **kwargs",
        "paramSpecNotUsedByOuterScope": "Element ParamSpec „{name}” nie ma znaczenia w tym kontekście",
        "paramSpecUnknownArg": "Parametr ParamSpec nie obsługuje więcej niż jednego argumentu",
        "paramSpecUnknownMember": "„{name}” nie jest znanym atrybutem parametru ParamSpec",
        "paramSpecUnknownParam": "„{name}” jest nieznanym parametrem dla parametru ParamSpec",
        "paramTypeCovariant": "Zmienna typu kowariantnego nie może być używana w typie parametru",
        "paramTypePartiallyUnknown": "Typ parametru „{paramName}” jest częściowo nieznany",
        "paramTypeUnknown": "Typ parametru „{paramName}” jest nieznany",
        "parenthesizedContextManagerIllegal": "Nawiasy w instrukcji „with” wymagają wersji języka Python 3.9 lub nowszej",
        "patternNeverMatches": "Wzorzec nigdy nie zostanie dopasowany do typu podmiotu „{type}”",
        "positionArgAfterNamedArg": "Argument pozycyjny nie może występować po argumentach słów kluczowych",
        "positionOnlyAfterArgs": "Separator parametru tylko do pozycjonowania jest niedozwolony po parametrze „*”",
        "positionOnlyAfterKeywordOnly": "Parametr „/” musi występować przed parametrem „*”.",
        "positionOnlyAfterNon": "Parametr tylko do pozycjonowania jest niedozwolony po parametrze, który nie jest tylko do pozycjonowania",
        "positionOnlyFirstParam": "Separator parametrów tylko do pozycjonowania nie jest dozwolony jako pierwszy parametr",
        "positionOnlyIncompatible": "Separator parametrów tylko do pozycjonowania wymaga języka Python 3.8 lub nowszego",
        "privateImportFromPyTypedModule": "Nazwa „{name}” nie jest eksportowana z modułu „{module}”",
        "privateUsedOutsideOfClass": "Nazwa „{name}” jest prywatna i używana poza klasą, w której została zadeklarowana",
        "privateUsedOutsideOfModule": "Nazwa „{name}” jest prywatna i używana poza modułem, w którym została zadeklarowana",
        "propertyOverridden": "„{name}” nieprawidłowo zastępuje właściwość o tej samej nazwie w klasie „{className}”",
        "propertyStaticMethod": "Metody statyczne nie są dozwolone w przypadku metod pobierających, ustawiających lub usuwających właściwości",
        "protectedUsedOutsideOfClass": "Nazwa „{name}” jest chroniona i używana poza klasą, w której została zadeklarowana",
        "protocolBaseClass": "Klasa protokołu typu „{classType}” nie może pochodzić od klasy niebędącej klasą protokołu typu „{baseType}”",
        "protocolBaseClassWithTypeArgs": "Argumenty typu są niedozwolone w przypadku klasy protokołu, gdy jest używana składnia parametru typu",
        "protocolIllegal": "Użycie elementu „Protocol” wymaga języka Python w wersji 3.7 lub nowszej",
        "protocolNotAllowed": "„Protokół” nie może być używany w tym kontekście",
        "protocolUnsafeOverlap": "Klasa nakłada się niebezpiecznie na element „{name}” i może utworzyć dopasowanie w czasie wykonywania",
        "protocolVarianceContravariant": "Zmienna typu „{variable}” używana w klasie protokołu ogólnego „{class}” powinna być kontrawariantna",
        "protocolVarianceCovariant": "Zmienna typu „{variable}” używana w klasie protokołu ogólnego „{class}” powinna być kowariantna",
        "protocolVarianceInvariant": "Zmienna typu „{variable}” używana w klasie protokołu ogólnego „{class}” powinna być niezmienna",
        "pyrightCommentInvalidDiagnosticBoolValue": "Po dyrektywie komentarza Pyright musi następować znak „=” oraz wartość Prawda lub Fałsz",
        "pyrightCommentInvalidDiagnosticSeverityValue": "Po dyrektywie komentarza Pyright musi następować znak „=” oraz wartość Prawda, Fałsz, Błąd, Ostrzeżenie, Informacja lub Brak",
        "pyrightCommentMissingDirective": "Komentarz Pyright musi poprzedzać dyrektywę (bazową lub ścisłą) lub regułę diagnostyczną",
        "pyrightCommentNotOnOwnLine": "Komentarze Pyright używane do kontrolowania ustawień na poziomie plików muszą pojawiać się w oddzielnych wierszach",
        "pyrightCommentUnknownDiagnosticRule": "Reguła „{rule}” jest nieznaną regułą diagnostyczną dla komentarza Pyright",
        "pyrightCommentUnknownDiagnosticSeverityValue": "Wartość „{value}” jest nieprawidłowa dla komentarza Pyright; oczekiwano wartości: Prawda, Fałsz, Błąd, Ostrzeżenie, Informacja lub Brak",
        "pyrightCommentUnknownDirective": "Wartość „{directive}” jest nieznaną dyrektywą dla komentarza Pyright; oczekiwano wartości „strict” lub „basic”",
        "readOnlyArgCount": "Oczekiwano jednego argumentu typu po wartości „ReadOnly”",
        "readOnlyNotInTypedDict": "Element „ReadOnly” jest niedozwolony w tym kontekście",
        "recursiveDefinition": "Nie można określić typu „{name}”, ponieważ odwołuje się on do samego siebie",
        "relativeImportNotAllowed": "Importy względne nie mogą być używane z formularzem „import .a”; zamiast tego użyj „from . import a”.",
        "requiredArgCount": "Oczekiwano jednego argumentu typu po wartości „Required”",
        "requiredNotInTypedDict": "Element „Required” jest niedozwolony w tym kontekście",
        "returnInAsyncGenerator": "Instrukcja „return” z wartością jest niedozwolona w generatorze asynchronicznym",
        "returnMissing": "Funkcja z zadeklarowanym typem zwracanym „{returnType}” musi zwracać wartość we wszystkich ścieżkach kodu",
        "returnOutsideFunction": "Instrukcja „return” może być używana tylko w ramach funkcji",
        "returnTypeContravariant": "Kontrawariantna zmienna typu nie może być używana w zwracanym typie",
        "returnTypeMismatch": "Wyrażenie typu „{exprType}” jest niezgodne z typem zwracania „{returnType}”",
        "returnTypePartiallyUnknown": "Zwracany typ „{returnType}” jest częściowo nieznany",
        "returnTypeUnknown": "Zwracany typ jest nieznany",
        "revealLocalsArgs": "Oczekiwano braku argumentów dla wywołania „reveal_locals”",
        "revealLocalsNone": "Brak elementów lokalnych w tym zakresie",
        "revealTypeArgs": "Oczekiwano pojedynczego argumentu pozycyjnego dla wywołania „reveal_type”",
        "revealTypeExpectedTextArg": "Argument „expected_text” dla funkcji „reveal_type” musi być wartością literału str",
        "revealTypeExpectedTextMismatch": "Wpisz niezgodność tekstu; oczekiwano „{expected}”, ale otrzymano „{received}”",
        "revealTypeExpectedTypeMismatch": "Niezgodność typu; oczekiwano wartości „{expected}”, a uzyskano „{received}”",
        "selfTypeContext": "Wartość „Self” jest nieprawidłowa w tym kontekście",
        "selfTypeMetaclass": "Nie można użyć elementu „Self” w ramach metaklasy (podklasy elementu „type”)",
        "selfTypeWithTypedSelfOrCls": "Nie można użyć wartości „Self” w funkcji z parametrem „self” lub „cls”, która ma adnotację typu inną niż „Self”",
        "setterGetterTypeMismatch": "Typu wartości metody ustawiającej właściwość nie można przypisać do zwracanego typu metody pobierającej",
        "singleOverload": "Nazwa „{name}” jest oznaczona jako przeciążona, ale brakuje dodatkowych przeciążeń",
        "slotsAttributeError": "Nie określono atrybutu „{name}” w elemencie __slots__",
        "slotsClassVarConflict": "„{name}” powoduje konflikt ze zmienną wystąpienia zadeklarowaną w elemencie „__slots__”",
        "starPatternInAsPattern": "Wzór gwiazdy nie może być użyty z miejscem docelowym parametru „as”.",
        "starPatternInOrPattern": "Wzór gwiazdy nie może mieć wartości ORed w ramach innych wzorów",
        "starStarWildcardNotAllowed": "Symbolu ** nie można używać z symbolem wieloznacznym „_”",
        "staticClsSelfParam": "Metody statyczne nie powinny przyjmować parametru „self” ani „cls”.",
        "stdlibModuleOverridden": "Ścieżka „{path}” zastępuje moduł stdlib „{name}”",
        "stringNonAsciiBytes": "Znak inny niż ASCII jest niedozwolony w literale ciągu bajtów",
        "stringNotSubscriptable": "Wyrażenie ciągu nie może być indeksowane w adnotacji typu; ujmij całą adnotację w cudzysłów",
        "stringUnsupportedEscape": "Nieobsługiwana sekwencja ucieczki w literale ciągu",
        "stringUnterminated": "Literał ciągu jest niezakończony",
        "stubFileMissing": "Nie znaleziono pliku zastępczego dla „{importName}”",
        "stubUsesGetAttr": "Typ pliku zastępczego jest niekompletny; element „__getattr__” przesłania błędy typu dla modułu",
        "sublistParamsIncompatible": "Parametry podlisty nie są obsługiwane w wersji języka Python 3.x",
        "superCallArgCount": "Oczekiwano nie więcej niż dwóch argumentów wywołania „super”",
        "superCallFirstArg": "Oczekiwano typu klasy jako pierwszego argumentu wywołania „super”, ale otrzymano „{type}”",
        "superCallSecondArg": "Drugi argument wywołania „super” musi być obiektem lub klasą wywodzącą się z typu „{type}”",
        "superCallZeroArgForm": "Forma bez argumentów wywołania „super” jest prawidłowa tylko w ramach metody",
        "superCallZeroArgFormStaticMethod": "Forma z zerowym argumentem wywołania „super” jest nieprawidłowa w metodzie statycznej",
        "symbolIsPossiblyUnbound": "Nazwa „{name}” jest prawdopodobnie niepowiązana",
        "symbolIsUnbound": "Nazwa „{name}” jest niepowiązana",
        "symbolIsUndefined": "Nazwa „{name}” nie jest zdefiniowana",
        "symbolOverridden": "Nazwa „{name}” przesłania symbol o tej samej nazwie w klasie „{className}”",
        "ternaryNotAllowed": "Wyrażenie słownikowe jest niedozwolone w adnotacji typu",
        "totalOrderingMissingMethod": "Klasa musi definiować jedną z następujących wartości: „__lt__”, „__le__”, „__gt__” lub „__ge__”, aby użyć parametru total_ordering",
        "trailingCommaInFromImport": "Końcowy przecinek nie jest dozwolony bez otaczających nawiasów",
        "tryWithoutExcept": "Instrukcja „Try” musi mieć co najmniej jedną klauzulę „except” lub „finally”",
        "tupleAssignmentMismatch": "Wyrażenia typu „{type}” nie można przypisać do docelowej krotki",
        "tupleInAnnotation": "Wyrażenie krotki jest niedozwolone w adnotacji typu",
        "tupleIndexOutOfRange": "Indeks {index} jest poza zakresem dla typu {type}",
        "typeAliasIllegalExpressionForm": "Nieprawidłowy formularz wyrażenia dla definicji aliasu typu",
        "typeAliasIsRecursiveDirect": "Alias typu „{name}” nie może używać samego siebie w swojej definicji",
        "typeAliasNotInModuleOrClass": "Typ TypeAlias można zdefiniować tylko w zakresie modułu lub klasy",
        "typeAliasRedeclared": "Nazwa „{name}” jest zadeklarowana jako TypeAlias i może być przypisana tylko raz",
        "typeAliasStatementBadScope": "Deklaracja typu może być użyta tylko w zakresie modułu lub klasy",
        "typeAliasStatementIllegal": "Instrukcja typu alias wymaga języka Python w wersji 3.12 lub nowszej",
        "typeAliasTypeBaseClass": "Alias typu zdefiniowany w instrukcji „{type}” nie może być użyty jako klasa bazowa",
        "typeAliasTypeMustBeAssigned": "Typ TypeAliasType musi być przypisany do zmiennej o takiej samej nazwie jak alias typu",
        "typeAliasTypeNameArg": "Pierwszy argument dla typu typeAliasType musi być literałem ciągu reprezentującym nazwę aliasu typu",
        "typeAliasTypeNameMismatch": "Nazwa aliasu typu musi być zgodna z nazwą zmiennej, do której jest przypisana",
        "typeAliasTypeParamInvalid": "Lista parametrów typu musi być krotką zawierającą tylko parametry TypeVar, TypeVarTuple lub ParamSpec",
        "typeAnnotationCall": "Wyrażenie wywołania jest niedozwolone w wyrażeniu typu",
        "typeAnnotationVariable": "Zmienna niedozwolona w wyrażeniu typu",
        "typeAnnotationWithCallable": "Argument typu „type” musi być klasą; elementy wywoływane nie są obsługiwane",
        "typeArgListExpected": "Oczekiwano parametru ParamSpec, wielokropka lub listy typów",
        "typeArgListNotAllowed": "Wyrażenie listy jest niedozwolone dla tego argumentu typu",
        "typeArgsExpectingNone": "Oczekiwano braku argumentów typu dla klasy „{name}”",
        "typeArgsMismatchOne": "Oczekiwano jednego argumentu typu, ale otrzymano {received}",
        "typeArgsMissingForAlias": "Oczekiwano argumentów typu dla aliasu typu ogólnego „{name}”",
        "typeArgsMissingForClass": "Oczekiwano argumentów typu dla ogólnej klasy „{name}”",
        "typeArgsTooFew": "Podano zbyt mało argumentów typu dla „{name}”; oczekiwano wartości {expected}, ale otrzymano {received}",
        "typeArgsTooMany": "Podano zbyt wiele argumentów typu dla nazwy „{name}”; oczekiwano {expected}, a uzyskano {received}",
        "typeAssignmentMismatch": "Wyrażenie typu „{sourceType}” jest niezgodne z zadeklarowanym typem „{destType}”",
        "typeAssignmentMismatchWildcard": "Symbol importu „{name}” ma typ „{sourceType}”, który jest niezgodny z zadeklarowanym typem „{destType}”",
        "typeCallNotAllowed": "Wywołanie type() nie powinno być używane w adnotacji typu",
        "typeCheckOnly": "Nazwa „{name}” jest oznaczona jako @type_check_only i może być używana tylko w adnotacjach typu",
        "typeCommentDeprecated": "Używanie komentarzy typu jest przestarzałe; zamiast tego użyj adnotacji typu",
        "typeExpectedClass": "Oczekiwano wyrażenia typu, ale otrzymano „{type}”",
        "typeGuardArgCount": "Oczekiwano pojedynczego argumentu typu po parametrze „TypeGuard” lub „TypeIs”",
        "typeGuardParamCount": "Funkcje i metody zabezpieczające typu zdefiniowane przez użytkownika muszą mieć co najmniej jeden parametr wejściowy",
        "typeIsReturnType": "Zwracany typ TypeIs („{returnType}”) jest niezgodny z typem parametru wartości („{type}”)",
        "typeNotAwaitable": "Nie można oczekiwać typu „{type}”",
        "typeNotIntantiable": "Nie można utworzyć wystąpienia „{type}”",
        "typeNotIterable": "Typ „{type}” nie jest iterowalny",
        "typeNotSpecializable": "Nie można specjalizować typu „{type}”",
        "typeNotSubscriptable": "Obiekt typu „{type}” nie może być użyty w indeksie dolnym",
        "typeNotSupportBinaryOperator": "Operator „{operator}” nieobsługiwany dla typów „{leftType}” i „{rightType}”",
        "typeNotSupportBinaryOperatorBidirectional": "Operator „{operator}” nie jest obsługiwany dla typów „{leftType}” i „{rightType}”, gdy oczekiwanym typem jest „{expectedType}”",
        "typeNotSupportUnaryOperator": "Operator „{operator}” nie jest obsługiwany dla typu „{type}”",
        "typeNotSupportUnaryOperatorBidirectional": "Operator „{operator}” nie jest obsługiwany dla typu „{type}”, gdy oczekiwanym typem jest „{expectedType}”",
        "typeNotUsableWith": "Obiekt typu „{type}” nie może być używany z parametrem „with”, ponieważ nie wdraża metody {method}",
        "typeParameterBoundNotAllowed": "Powiązanie lub ograniczenie nie może być używane z parametrem typu ze zmienną liczbą argumentów lub parametrem ParamSpec",
        "typeParameterConstraintTuple": "Ograniczenie parametru typu musi być krotką dwóch lub więcej typów",
        "typeParameterExistingTypeParameter": "Parametr typu „{name}” jest już używany",
        "typeParameterNotDeclared": "Parametr typu „{name}” nie znajduje się na liście parametrów typu dla „{container}”",
        "typeParametersMissing": "Należy określić co najmniej jeden parametr typu",
        "typePartiallyUnknown": "Typ „{name}” jest częściowo nieznany",
        "typeUnknown": "Typ „{name}” jest nieznany",
        "typeVarAssignedName": "Typ TypeVar musi być przypisany do zmiennej o nazwie „{name}”",
        "typeVarAssignmentMismatch": "Nie można przypisać typu „{type}” do zmiennej typu „{name}”",
        "typeVarBoundAndConstrained": "Typ TypeVar nie może być jednocześnie powiązany i ograniczony",
        "typeVarBoundGeneric": "Typ powiązany TypeVar nie może być ogólny",
        "typeVarConstraintGeneric": "Typ ograniczenia TypeVar nie może być ogólny",
        "typeVarDefaultBoundMismatch": "Domyślny typ TypeVar musi być podtypem powiązanego typu",
        "typeVarDefaultConstraintMismatch": "Typ domyślny TypeVar musi być jednym z typów z ograniczeniami",
        "typeVarDefaultIllegal": "Typy domyślne zmiennych typów wymagają wersji języka Python 3.13 lub nowszej",
        "typeVarDefaultInvalidTypeVar": "Parametr typu „{name}” ma typ domyślny, który odnosi się do co najmniej jednej zmiennej typu, która jest poza zakresem",
        "typeVarFirstArg": "Oczekiwano nazwy TypeVar jako pierwszego argumentu",
        "typeVarNoMember": "Typ atrybutu TypeVar „{type}” nie ma atrybutu „{name}”",
        "typeVarNotSubscriptable": "Typ TypeVar „{type}” nie może być subskrybowany",
        "typeVarNotUsedByOuterScope": "Zmienna typu „{name}” nie ma w tym kontekście żadnego znaczenia",
        "typeVarPossiblyUnsolvable": "Zmienna typu „{name}” może zostać nierozwiązana, jeśli obiekt wywołujący nie poda argumentu dla parametru „{param}”",
        "typeVarSingleConstraint": "Typ TypeVar musi mieć co najmniej dwa typy ograniczone",
        "typeVarTupleConstraints": "Element TypeVarTuple nie może mieć ograniczeń wartości",
        "typeVarTupleContext": "Wartość TypeVarTuple jest niedozwolona w tym kontekście",
        "typeVarTupleDefaultNotUnpacked": "Typ domyślny TypeVarTuple musi być nierozpakowaną krotką lub parametrem TypeVarTuple",
        "typeVarTupleMustBeUnpacked": "Operator rozpakowywania jest wymagany dla wartości parametru TypeVarTuple",
        "typeVarTupleUnknownParam": "Nazwa „{name}” jest nieznanym parametrem typu TypeVarTuple",
        "typeVarUnknownParam": "„{name}” jest nieznanym parametrem dla argumentu TypeVar",
        "typeVarUsedByOuterScope": "Argument TypeVar „{name}” jest już używany przez zakres zewnętrzny",
        "typeVarUsedOnlyOnce": "Typ TypeVar „{name}” pojawia się tylko raz w sygnaturze funkcji ogólnej",
        "typeVarVariance": "Zmienna typu TypeVar nie może być jednocześnie kowariantna i kontrawariantna",
        "typeVarWithDefaultFollowsVariadic": "Wartość TypeVar „{typeVarName}” ma wartość domyślną i nie może następować po wartości TypeVarTuple „{variadicName}”.",
        "typeVarWithoutDefault": "Element „{name}” nie może występować po elemencie „{other}” na liście parametrów typu, ponieważ nie ma typu domyślnego",
        "typeVarsNotInGenericOrProtocol": "Elementy Generic[] lub Protocol[] muszą zawierać wszystkie zmienne typu",
        "typedDictAccess": "Nie można uzyskać dostępu do elementu w TypedDict",
        "typedDictAssignedName": "Element TypedDict musi być przypisany do zmiennej o nazwie „{name}”",
        "typedDictBadVar": "Klasy TypedDict mogą zawierać tylko adnotacje typu",
        "typedDictBaseClass": "Wszystkie klasy bazowe dla klas TypedDict muszą być również klasami TypedDict",
        "typedDictBoolParam": "Oczekiwano, że parametr „{name}” będzie miał wartość Prawda lub Fałsz",
        "typedDictClosedExtras": "Klasa bazowa „{name}” jest zamkniętym elementem TypedDict; dodatkowe elementy muszą być typu „{type}”",
        "typedDictClosedNoExtras": "Klasa bazowa „{name}” jest zamkniętym elementem TypedDict; dodatkowe elementy są niedozwolone",
        "typedDictDelete": "Nie można usunąć elementu w typie TypedDict",
        "typedDictEmptyName": "Nazwy w elemencie TypedDict nie mogą być puste",
        "typedDictEntryName": "Oczekiwano literału ciągu dla nazwy wpisu słownika",
        "typedDictEntryUnique": "Nazwy w słowniku muszą być unikatowe",
        "typedDictExtraArgs": "Dodatkowe argumenty TypedDict nie są obsługiwane",
        "typedDictFieldNotRequiredRedefinition": "Element TypedDict „{name}” nie może zostać przedefiniowany jako Niewymagany",
        "typedDictFieldReadOnlyRedefinition": "Element TypedDict „{name}” nie może być przedefiniowany jako Tylko do odczytu.",
        "typedDictFieldRequiredRedefinition": "Element TypedDict „{name}” nie może zostać przedefiniowany jako Wymagany",
        "typedDictFirstArg": "Oczekiwano nazwy klasy TypedDict jako pierwszego argumentu",
        "typedDictInitsubclassParameter": "Element TypedDict nie obsługuje parametru __init_subclass__ „{name}”",
        "typedDictNotAllowed": "Nie można użyć elementu „TypedDict” w tym kontekście",
        "typedDictSecondArgDict": "Oczekiwano parametru dict lub słowa kluczowego jako drugiego parametru",
        "typedDictSecondArgDictEntry": "Oczekiwano prostego wpisu słownika",
        "typedDictSet": "Nie można przypisać elementu w TypedDict",
        "unaccessedClass": "Nie uzyskano dostępu do klasy „{name}”",
        "unaccessedFunction": "Brak dostępu do funkcji „{name}”.",
        "unaccessedImport": "Import „{name}” nie jest dostępny",
        "unaccessedSymbol": "Brak dostępu do „{name}”.",
        "unaccessedVariable": "Brak dostępu do zmiennej „{name}”.",
        "unannotatedFunctionSkipped": "Analiza funkcji „{name}” została pominięta, ponieważ nie ma adnotacji",
        "unaryOperationNotAllowed": "Operator jednoargumentowy nie jest dozwolony w adnotacji typu",
        "unexpectedAsyncToken": "Oczekiwano wartości „def”, „with” lub „for” po „async”",
        "unexpectedExprToken": "Nieoczekiwany token na końcu wyrażenia",
        "unexpectedIndent": "Nieoczekiwane wcięcie",
        "unexpectedUnindent": "Nieoczekiwany brak wcięcia",
        "unhashableDictKey": "Klucz słownika musi być wartością skrótu",
        "unhashableSetEntry": "Ustawiany wpis musi być wartością skrótu",
        "uninitializedAbstractVariables": "Zmienne zdefiniowane w abstrakcyjnej klasie bazowej nie są inicjowane w klasie końcowej „{classType}”",
        "uninitializedInstanceVariable": "Zmienna wystąpienia „{name}” nie została zainicjowana w treści klasy ani w metodzie __init__",
        "unionForwardReferenceNotAllowed": "Składnia unii nie może być używana z operandem ciągu; użyj cudzysłowów wokół całego wyrażenia",
        "unionSyntaxIllegal": "Alternatywna składnia unii wymaga języka Python w wersji 3.10 lub nowszej",
        "unionTypeArgCount": "Unia wymaga co najmniej dwóch argumentów typu",
        "unionUnpackedTuple": "Związek nie może zawierać rozpakowanej krotki",
        "unionUnpackedTypeVarTuple": "Unia nie może zawierać rozpakowanego elementu TypeVarTuple",
        "unnecessaryCast": "Niepotrzebne wywołanie „cast”; typ jest już „{type}”",
        "unnecessaryIsInstanceAlways": "Niepotrzebne wywołanie wystąpienia; „{testType}” jest zawsze wystąpieniem „{classType}”",
        "unnecessaryIsSubclassAlways": "Niepotrzebne wywołanie „issubclass”; „{testType}” jest zawsze podklasą klasy „{classType}”",
        "unnecessaryPyrightIgnore": "Niepotrzebny komentarz „# pyright: ignore”",
        "unnecessaryPyrightIgnoreRule": "Niepotrzebna reguła „# pyright: ignore”: „{name}”",
        "unnecessaryTypeIgnore": "Niepotrzebny komentarz „# type: ignore”",
        "unpackArgCount": "Oczekiwano jednego argumentu typu po wartości „Unpack”",
        "unpackExpectedTypeVarTuple": "Oczekiwano typu TypeVarTuple lub krotki jako argumentu typu dla rozpakowywania",
        "unpackExpectedTypedDict": "Oczekiwano argumentu typu TypedDict dla rozpakowywania",
        "unpackIllegalInComprehension": "Operacja rozpakowywania nie jest dozwolona w rozumieniu",
        "unpackInAnnotation": "Operator rozpakowywania nie jest dozwolony w adnotacji typu",
        "unpackInDict": "Operacja rozpakowywania nie jest dozwolona w słownikach",
        "unpackInSet": "Rozpakowywanie operatora jest niedozwolone w zestawie",
        "unpackNotAllowed": "Rozpakowywanie jest niedozwolone w tym kontekście",
        "unpackOperatorNotAllowed": "Operacja rozpakowywania jest niedozwolona w tym kontekście",
        "unpackTuplesIllegal": "Operacja rozpakowywania nie jest dozwolona w krotkach przed językiem Python w wersji 3.8",
        "unpackedArgInTypeArgument": "Nie można użyć nierozpakowanych argumentów w tym kontekście",
        "unpackedArgWithVariadicParam": "Nie można użyć nierozpakowanego argumentu dla parametru TypeVarTuple",
        "unpackedDictArgumentNotMapping": "Wyrażenie argumentu po znakach ** musi być mapowaniem z typem klucza „str”",
        "unpackedDictSubscriptIllegal": "Operator rozpakowywania słownika w indeksie dolnym jest niedozwolony",
        "unpackedSubscriptIllegal": "Operator rozpakowywania w indeksie dolnym wymaga języka Python w wersji 3.11 lub nowszej",
        "unpackedTypeVarTupleExpected": "Oczekiwano nierozpakowanego typu TypeVarTuple; użyj Unpack[{name1}] lub *{name2}",
        "unpackedTypedDictArgument": "Nie można dopasować nierozpakowanego argumentu TypedDict do parametrów",
        "unreachableCode": "Kod jest nieosiągalny",
        "unreachableExcept": "Klauzula wyjątku jest nieosiągalna, ponieważ wyjątek jest już obsługiwany",
        "unsupportedDunderAllOperation": "Operacja na elemencie „__all__” nie jest obsługiwana, więc wyeksportowana lista symboli może być nieprawidłowa",
        "unusedCallResult": "Wynik wyrażenia wywołania jest typu „{type}” i nie jest używany; przypisz do zmiennej „_”, jeśli jest to zamierzone",
        "unusedCoroutine": "Wynik wywołania funkcji asynchronicznej nie jest używany; użyj wartości „await” lub przypisz wynik do zmiennej",
        "unusedExpression": "Wartość wyrażenia jest nieużywana",
        "varAnnotationIllegal": "Adnotacje typu dla zmiennych wymagają języka Python w wersji 3.6 lub nowszej; użyj komentarza typu, aby uzyskać zgodność z poprzednimi wersjami",
        "variableFinalOverride": "Zmienna „{name}” jest oznaczona jako końcowa i zastępuje zmienną inną niż końcowa o tej samej nazwie w klasie „{className}”",
        "variadicTypeArgsTooMany": "Lista argumentów typu może zawierać co najwyżej jeden nierozpakowany typ TypeVarTuple lub krotkę",
        "variadicTypeParamTooManyAlias": "Alias typu może mieć co najwyżej jeden parametr typu TypeVarTuple, ale otrzymał wiele ({names})",
        "variadicTypeParamTooManyClass": "Klasa ogólna może mieć co najwyżej jeden parametr typu TypeVarTuple, ale otrzymał wiele ({names})",
        "walrusIllegal": "Operator „:=” wymaga języka Python w wersji 3.8 lub nowszej",
        "walrusNotAllowed": "Operator „:=” jest niedozwolony w tym kontekście bez otaczających nawiasów",
        "wildcardInFunction": "Importowanie symboli wieloznacznych jest niedozwolone w obrębie klasy lub funkcji",
        "wildcardLibraryImport": "Importowanie symboli wieloznacznych z biblioteki jest niedozwolone",
        "wildcardPatternTypePartiallyUnknown": "Typ przechwycony przez wzorzec symboli wieloznacznych jest częściowo nieznany",
        "wildcardPatternTypeUnknown": "Typ przechwycony przez wzorzec symboli wieloznacznych jest nieznany",
        "yieldFromIllegal": "Użycie wartości „yield from” wymaga języka Python w wersji 3.3 lub nowszej",
        "yieldFromOutsideAsync": "Instrukcja „yield from” jest niedozwolona w funkcji asynchronicznej",
        "yieldOutsideFunction": "Instrukcja „yield” jest niedozwolona poza funkcją lub wyrażeniem lambda",
        "yieldWithinListCompr": "Instrukcja „yield” nie jest dozwolona w rozumieniu listy",
        "zeroCaseStatementsFound": "Instrukcja dopasowania musi zawierać co najmniej jedną instrukcję dotyczącą wielkości liter",
        "zeroLengthTupleNotAllowed": "Krotka o zerowej długości jest niedozwolona w tym kontekście"
    },
    "DiagnosticAddendum": {
        "annotatedNotAllowed": "Formularza specjalnego „Adnotacja” nie można używać z kontrolami wystąpień i klas",
        "argParam": "Argument odpowiada parametrowi „{paramName}”",
        "argParamFunction": "Argument odpowiada parametrowi „{paramName}” w funkcji „{functionName}”",
        "argsParamMissing": "Parametr „*{paramName}” nie ma odpowiadającego mu parametru",
        "argsPositionOnly": "Niezgodność parametrów tylko dla pozycji; oczekiwano wartości „{expected}”, a uzyskano „{received}”",
        "argumentType": "Typ argumentu to „{type}”",
        "argumentTypes": "Typy argumentów: ({types})",
        "assignToNone": "Typ jest niezgodny z wartością „Brak”",
        "asyncHelp": "Czy chodziło o wartość „async with”?",
        "baseClassIncompatible": "Klasa bazowa „{baseClass}” jest niezgodna z typem „{type}”",
        "baseClassIncompatibleSubclass": "Klasa bazowa „{baseClass}” pochodzi od klasy podrzędnej „{subclass}”, która jest niezgodna z typem „{type}”",
        "baseClassOverriddenType": "Klasa bazowa „{baseClass}” udostępnia typ „{type}”, który jest przesłonięty",
        "baseClassOverridesType": "Zastąpienie klasy bazowej „{baseClass}” typem „{type}”",
        "bytesTypePromotions": "Ustaw właściwość disableBytesTypePromotions na wartość false, aby włączyć zachowanie promocji typu dla elementów „bytearray” i „memoryview”",
        "conditionalRequiresBool": "Metoda __bool__ dla typu „{operandType}” zwraca typ \"{boolReturnType}\" zamiast „bool”",
        "dataClassFieldLocation": "Deklaracja pola",
        "dataClassFrozen": "Nazwa „{name}” jest zamrożona",
        "dataProtocolUnsupported": "Element „{name}” to protokół danych",
        "descriptorAccessBindingFailed": "Nie można powiązać metody „{name}” dla klasy deskryptora „{className}”",
        "descriptorAccessCallFailed": "Nie można wywołać metody „{name}” dla klasy deskryptora „{className}”",
        "finalMethod": "Metoda końcowa",
        "functionParamDefaultMissing": "Brak domyślnego argumentu dla parametru „{name}”",
        "functionParamName": "Niezgodność nazw parametrów: „{destName}” a „{srcName}”",
        "functionParamPositionOnly": "Niezgodność parametrów tylko do położenia; parametr „{name}” nie jest tylko pozycją",
        "functionReturnTypeMismatch": "Typ zwracanego typu funkcji „{sourceType}” jest niezgodny z typem „{destType}”",
        "functionTooFewParams": "Funkcja akceptuje zbyt mało parametrów pozycyjnych; oczekiwano {expected}, ale otrzymano {received}",
        "functionTooManyParams": "Funkcja akceptuje zbyt wiele parametrów pozycyjnych; oczekiwano {expected}, ale otrzymano {received}",
        "genericClassNotAllowed": "Typ ogólny z argumentami typu jest niedozwolony dla sprawdzania wystąpienia lub klasy",
        "incompatibleDeleter": "Metoda usuwająca właściwości jest niezgodna",
        "incompatibleGetter": "Metoda pobierająca właściwości jest niezgodna",
        "incompatibleSetter": "Metoda ustawiająca właściwości jest niezgodna",
        "initMethodLocation": "Metoda __init__ jest zdefiniowana w klasie „{type}”",
        "initMethodSignature": "Sygnatura __init__ to typ „{type}”",
        "initSubclassLocation": "Metoda __init_subclass__ jest zdefiniowana w klasie „{name}”",
        "invariantSuggestionDict": "Rozważ przełączenie z wartości „dict” na „Mapping”, która jest kowariantna w typie wartości",
        "invariantSuggestionList": "Rozważ zmianę wartości „list” na „Sequence”, która jest kowariantna",
        "invariantSuggestionSet": "Rozważ przełączenie z wartości „set” na „Container”, która jest kowariantna",
        "keyNotRequired": "„{name}” nie jest wymaganym kluczem w typie „{type}”, więc dostęp może spowodować wyjątek środowiska uruchomieniowego",
        "keyReadOnly": "Nazwa „{name}” jest kluczem tylko do odczytu w typie „{type}”",
        "keyRequiredDeleted": "Nazwa „{name}” jest wymaganym kluczem i nie można go usunąć",
        "keyUndefined": "Nazwa „{name}” nie jest zdefiniowanym kluczem w typie „{type}”",
        "kwargsParamMissing": "Parametr „**{paramName}” nie ma odpowiadającego mu parametru",
        "listAssignmentMismatch": "Typ „{type}” jest niezgodny z listą docelową",
        "literalAssignmentMismatch": "„{sourceType}” jest niezgodny z typem „{destType}”",
        "matchIsNotExhaustiveHint": "Jeśli kompleksowa obsługa nie jest zamierzona, dodaj „case _: pass”",
        "matchIsNotExhaustiveType": "Nieobsługiwany typ: „{type}”",
        "memberAssignment": "Wyrażenia typu „{type}” nie można przypisać do atrybutu „{name}” klasy „{classType}”",
        "memberIsAbstract": "„{type}.{name}” nie zostało zaimplementowane",
        "memberIsAbstractMore": "i jeszcze {count}...",
        "memberIsClassVarInProtocol": "Element „{name}” jest zdefiniowany jako element ClassVar w protokole",
        "memberIsFinalInProtocol": "Nazwa „{name}” jest oznaczona jako końcowa w protokole",
        "memberIsInitVar": "Składowa „{name}” jest polem tylko do operacji init",
        "memberIsInvariant": "Nazwa „{name}” jest niezmienna, ponieważ jest modyfikowalna",
        "memberIsNotClassVarInClass": "Element „{name}” musi być zdefiniowany jako ClassVar, aby był zgodny z protokołem",
        "memberIsNotClassVarInProtocol": "Element „{name}” nie jest zdefiniowany jako ClassVar w protokole",
        "memberIsNotFinalInProtocol": "Element „{name}” nie jest oznaczony jako wersja ostateczna w protokole",
        "memberIsWritableInProtocol": "Nazwa „{name}” jest zapisywalna w protokole",
        "memberSetClassVar": "Atrybut „{name}” nie może zostać przypisany przez wystąpienie klasy, ponieważ jest to element ClassVar",
        "memberTypeMismatch": "Nazwa „{name}” jest niezgodnym typem",
        "memberUnknown": "Atrybut „{name}” jest nieznany",
        "metaclassConflict": "Metaklasa „{metaclass1}” powoduje konflikt z „{metaclass2}”",
        "missingDeleter": "Brak metody usuwania właściwości",
        "missingGetter": "Brak metody pobierającej właściwości",
        "missingSetter": "Brak metody zestawu właściwości",
        "namedParamMissingInDest": "W lokalizacji docelowej brakuje parametru słowa kluczowego „{name}”.",
        "namedParamMissingInSource": "W źródle brakuje parametru słowa kluczowego „{name}”.",
        "namedParamTypeMismatch": "Parametr słowa kluczowego „{name}” typu „{sourceType}” jest niezgodny z typem „{destType}”",
        "namedTupleNotAllowed": "Funkcja NamedTuple nie może być używana do sprawdzania wystąpień lub klas",
        "newMethodLocation": "Metoda __new__ jest zdefiniowana w klasie „{type}”",
        "newMethodSignature": "Sygnatura __new__ to typ „{type}”",
        "newTypeClassNotAllowed": "Klasy utworzonej za pomocą elementu NewType nie można używać z sprawdzaniem wystąpień i klas",
        "noOverloadAssignable": "Żadna przeciążona funkcja nie pasuje do typu „{type}”",
        "noneNotAllowed": "Żadne nie może być używane do sprawdzania wystąpienia ani klasy",
        "orPatternMissingName": "Brak nazw: {name}",
        "overloadIndex": "Przeciążenie {index} jest najbardziej zbliżonym dopasowaniem",
        "overloadNotAssignable": "Nie można przypisać jednego lub więcej przeciążeń „{name}”.",
        "overloadSignature": "Sygnatura przeciążenia jest zdefiniowana tutaj",
        "overriddenMethod": "Przesłonięta metoda",
        "overriddenSymbol": "Przesłonięty symbol",
        "overrideInvariantMismatch": "Typ zastąpienia „{overrideType}” nie jest taki sam jak typ podstawowy „{baseType}”",
        "overrideIsInvariant": "Zmienna podlega przeobrażeniom, dlatego jej typ jest niezmienny",
        "overrideNoOverloadMatches": "Żadna sygnatura przeciążenia w przesłonięciu nie jest zgodna z metodą bazową",
        "overrideNotClassMethod": "Metoda bazowa jest zadeklarowana jako metoda classmethod, ale przesłonięcie nie",
        "overrideNotInstanceMethod": "Metoda bazowa jest zadeklarowana jako metoda wystąpienia, ale zastąpienie nie jest",
        "overrideNotStaticMethod": "Metoda bazowa jest zadeklarowana jako metoda statyczna, ale przesłonięcie nie",
        "overrideOverloadNoMatch": "Zastąpienie nie obsługuje wszystkich przeciążeń metody podstawowej",
        "overrideOverloadOrder": "Przeciążenia dla metody przesłaniania muszą być w takiej samej kolejności, co metoda bazowa",
        "overrideParamKeywordNoDefault": "Niezgodność parametru słowa kluczowego „{name}”: parametr bazowy ma domyślną wartość argumentu, parametr zastąpienia nie ma jej",
        "overrideParamKeywordType": "Niezgodność typu parametru słowa kluczowego „{name}”: parametr bazowy jest typu „{baseType}”, a parametr zastąpienia jest typu „{overrideType}”",
        "overrideParamName": "Niezgodność nazwy parametru {index}: parametr podstawowy nosi nazwę „{baseName}”, a parametr zastąpienia — „{overrideName}”",
        "overrideParamNameExtra": "W bazie brakuje parametru „{name}”.",
        "overrideParamNameMissing": "Brak parametru „{name}” w zastąpieniu",
        "overrideParamNamePositionOnly": "Niezgodność parametru {index}: parametr podstawowy „{baseName}” jest parametrem słowa kluczowego, parametr przesłonięcia jest tylko w pozycji",
        "overrideParamNoDefault": "Niezgodność parametru {index}: parametr bazowy ma domyślną wartość argumentu, a parametr zastąpienia nie ma jej",
        "overrideParamType": "Niezgodność typów parametru {index}: parametr bazowy jest typu „{baseType}”, parametr zastąpienia jest typu „{overrideType}”",
        "overridePositionalParamCount": "Niezgodność liczby parametrów pozycyjnych; metoda podstawowa ma {baseCount}, a zastąpienie {overrideCount}",
        "overrideReturnType": "Niezgodność zwracanego typu: metoda podstawowa zwraca typ „{baseType}”, przesłonięcie zwraca typ „{overrideType}”",
        "overrideType": "Klasa bazowa definiuje typ jako „{type}”",
        "paramAssignment": "Parametr {index}: typ „{sourceType}” jest niezgodny z typem „{destType}”",
        "paramSpecMissingInOverride": "Brak parametrów ParamSpec w metodzie zastąpienia",
        "paramType": "Typ parametru to „{paramType}”",
        "privateImportFromPyTypedSource": "Zamiast tego importuj z modułu „{module}”.",
        "propertyAccessFromProtocolClass": "Nie można uzyskać dostępu do właściwości zdefiniowanej w klasie protokołu jako zmiennej klasy",
        "propertyMethodIncompatible": "Metoda właściwości „{name}” jest niezgodna",
        "propertyMethodMissing": "Brak metody właściwości „{name}” w zastąpieniu",
        "propertyMissingDeleter": "Właściwość „{name}” nie ma zdefiniowanego elementu usuwającego",
        "propertyMissingSetter": "Właściwość „{name}” nie ma zdefiniowanej metody ustawiającej",
        "protocolIncompatible": "Protokół „{sourceType}” jest niezgodny z protokołem „{destType}”",
        "protocolMemberMissing": "Brak nazwy „{name}”.",
        "protocolRequiresRuntimeCheckable": "Klasa protokołu musi być @runtime_checkable, aby mogła być używana ze sprawdzaniem wystąpienia i klasy",
        "protocolSourceIsNotConcrete": "„{sourceType}” nie jest typem specyficznej klasy i nie można go przypisać do typu „{destType}”",
        "protocolUnsafeOverlap": "Atrybuty „{name}” mają takie same nazwy jak protokół",
        "pyrightCommentIgnoreTip": "Użyj polecenia „# pyright: ignore[<diagnostic rules>], aby pominąć diagnostykę przez jeden wiersz",
        "readOnlyAttribute": "Atrybut „{name}” jest tylko do odczytu",
        "seeClassDeclaration": "Zobacz deklarację klasy",
        "seeDeclaration": "Zobacz deklarację",
        "seeFunctionDeclaration": "Zobacz deklarację funkcji",
        "seeMethodDeclaration": "Zobacz deklarację metody",
        "seeParameterDeclaration": "Zobacz deklarację parametru",
        "seeTypeAliasDeclaration": "Zobacz deklarację aliasu typu",
        "seeVariableDeclaration": "Zobacz deklarację zmiennej",
        "tupleAssignmentMismatch": "Typ „{type}” jest niezgodny z docelową krotką",
        "tupleEntryTypeMismatch": "Wpis krotki {entry} jest nieprawidłowego typu",
        "tupleSizeIndeterminateSrc": "Niezgodność rozmiaru krotki; oczekiwano {expected}, ale otrzymano nieokreślony",
        "tupleSizeIndeterminateSrcDest": "Niezgodność rozmiaru krotki; oczekiwano {expected}, a otrzymano rozmiar nieokreślony",
        "tupleSizeMismatch": "Niezgodność rozmiaru krotki; oczekiwano {expected}, ale otrzymano {received}",
        "tupleSizeMismatchIndeterminateDest": "Niezgodność rozmiaru krotki; oczekiwano {expected}, a otrzymano {received}",
        "typeAliasInstanceCheck": "Alias typu utworzony za pomocą instrukcji „{type}” nie może być użyty do sprawdzania wystąpień i klas",
        "typeAssignmentMismatch": "Typ „{sourceType}” jest niezgodny z typem „{destType}”",
        "typeBound": "Typ „{sourceType}” jest niezgodny z typem powiązanym „{destType}” dla zmiennej typu „{name}”",
        "typeConstrainedTypeVar": "Typ „{type}” jest niezgodny ze zmienną typu ograniczonego „{name}”",
        "typeIncompatible": "Typ „{sourceType}” jest niezgodny z „{destType}”",
        "typeNotClass": "Typ „{type}” nie jest klasą",
        "typeNotStringLiteral": "„{type}” nie jest literałem ciągu",
        "typeOfSymbol": "Typ nazwy „{name}” jest to „{type}”",
        "typeParamSpec": "Typ „{type}” jest niezgodny ze specyfikacją ParamSpec „{name}”",
        "typeUnsupported": "Typ „{type}” nie jest obsługiwany",
        "typeVarDefaultOutOfScope": "Zmienna typu „{name}” nie wchodzi w zakres",
        "typeVarIsContravariant": "Parametr typu „{name}” jest kontrawariantny, ale „{sourceType}” nie jest nadtypem „{destType}”",
        "typeVarIsCovariant": "Parametr typu „{name}” jest kowariantny, ale „{sourceType}” nie jest podtypem „{destType}”",
        "typeVarIsInvariant": "Parametr typu „{name}” jest niezmienny, ale „{sourceType}” nie jest taki sam jak „{destType}”",
        "typeVarNotAllowed": "Typ TypeVar nie jest dozwolony dla sprawdzania wystąpienia lub klasy",
        "typeVarTupleRequiresKnownLength": "Nie można powiązać parametru TypeVarTuple z krotką o nieznanej długości",
        "typeVarUnnecessarySuggestion": "Zamiast tego użyj elementu {type}",
        "typeVarUnsolvableRemedy": "Podaj przeciążenie, które określa zwracany typ, gdy nie podano argumentu",
        "typeVarsMissing": "Brak zmiennych typu: {names}",
        "typedDictBaseClass": "Klasa „{type}” nie jest typem TypedDict",
        "typedDictClassNotAllowed": "Klasa TypedDict nie jest dozwolona na potrzeby sprawdzania wystąpienia lub klasy",
        "typedDictClosedExtraNotAllowed": "Nie można dodać elementu \"{name}\"",
        "typedDictClosedExtraTypeMismatch": "Nie można dodać elementu \"{name}\" z typem „{type}”",
        "typedDictClosedFieldNotRequired": "Nie można dodać elementu \"{name}\", ponieważ musi on mieć wartość NotRequired",
        "typedDictExtraFieldNotAllowed": "Element „{name}” nie jest obecny w typie „{type}”",
        "typedDictExtraFieldTypeMismatch": "Typ „{name}” jest niezgodny z typem „__extra_items__” w typie „{type}”",
        "typedDictFieldMissing": "Brak nazwy „{name}” w „{type}”",
        "typedDictFieldNotReadOnly": "Nazwa „{name}” nie jest tylko do odczytu w „{type}”",
        "typedDictFieldNotRequired": "Nazwa „{name}” nie jest wymagana w typie „{type}”",
        "typedDictFieldRequired": "Nazwa „{name}” jest wymagana w typie „{type}”",
        "typedDictFieldTypeMismatch": "Nie można przypisać typu „{type}” do elementu „{name}”",
        "typedDictFieldUndefined": "Nazwa „{name}” jest niezdefiniowanym elementem w typie „{type}”",
        "typedDictFinalMismatch": "Typ „{sourceType}” jest niezgodny z typem „{destType}” z powodu niezgodności @final",
        "typedDictKeyAccess": "Użyj elementu [\"{name}\"], aby odwołać się do elementu w TypedDict",
        "typedDictNotAllowed": "Funkcja TypedDict nie może być używana do sprawdzania wystąpień lub klas",
        "unhashableType": "Typ „{type}” nie jest wartością skrótu",
        "uninitializedAbstractVariable": "zmienna wystąpienia „{name}” jest zdefiniowana w abstrakcyjnej klasie bazowej „{classType}” ale nie została zainicjowana",
        "unreachableExcept": "Typ „{exceptionType}” jest podklasą typu „{parentType}”",
        "useDictInstead": "Użyj funkcji Dict[T1, T2], aby wskazać typ słownika",
        "useListInstead": "Użyj funkcji List[T], aby wskazać typ listy, lub Union[T1, T2], aby wskazać typ unii",
        "useTupleInstead": "Użyj Tuple[T1, ..., Tn], aby wskazać typ krotki lub Union[T1, T2], aby wskazać typ unii",
        "useTypeInstead": "Zamiast tego użyj typu Type[T].",
        "varianceMismatchForClass": "Wariancja argumentu typu „{typeVarName}” jest niezgodna z klasą bazową „{className}”",
        "varianceMismatchForTypeAlias": "Wariancja argumentu typu „{typeVarName}” jest niezgodna z parametrem „{typeAliasParam}”"
    }
}
