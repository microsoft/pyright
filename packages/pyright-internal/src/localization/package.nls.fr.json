{
    "CodeAction": {
        "createTypeStub": "Créer un Stub de type",
        "createTypeStubFor": "Créer un Stub de type pour « {moduleName} »",
        "executingCommand": "Exécution de la commande",
        "filesToAnalyzeCount": "{count} fichiers à analyser",
        "filesToAnalyzeOne": "1 fichier à analyser",
        "findingReferences": "Recherche de références",
        "organizeImports": "Organiser les importations",
        "renameShadowedFile": "Renommez \"{oldFile}\" en \"{newFile}\""
    },
    "Completion": {
        "autoImportDetail": "Importation automatique",
        "indexValueDetail": "Valeur de l'indice"
    },
    "Diagnostic": {
        "abstractMethodInvocation": "Désolé, nous n’avons pas pu appeler la méthode « {method} », car elle est abstraite et non implémentée",
        "annotatedMetadataInconsistent": "Le type de métadonnées annoté « {metadataType} » n’est pas compatible avec le type « {type} »",
        "annotatedParamCountMismatch": "Non-concordance du nombre d'annotations de paramètre : attendu {expected} mais reçu {received}",
        "annotatedTypeArgMissing": "Un argument de type et une ou plusieurs annotations sont attendus pour « Annotated »",
        "annotationBytesString": "Les expressions de type ne peuvent pas utiliser de littéraux de chaîne d'octets",
        "annotationFormatString": "Les expressions de type ne peuvent pas utiliser de littéraux de chaîne de format (chaînes f)",
        "annotationNotSupported": "Annotation de type non prise en charge pour cette instruction",
        "annotationRawString": "Les expressions de type ne peuvent pas utiliser de littéraux de chaîne bruts",
        "annotationSpansStrings": "Les expressions de type ne peuvent pas s'étendre sur plusieurs littéraux de chaîne",
        "annotationStringEscape": "Les expressions de type ne peuvent pas contenir de caractères d'échappement",
        "argAssignment": "Impossible d’affecter l’argument de type « {argType} » au paramètre de type « {paramType} »",
        "argAssignmentFunction": "Impossible d’affecter l’argument de type « {argType} » au paramètre de type « {paramType} » dans la fonction « {functionName} »",
        "argAssignmentParam": "Impossible d’affecter l’argument de type « {argType} » au paramètre « {paramName} » de type « {paramType} »",
        "argAssignmentParamFunction": "Impossible d’affecter l’argument de type « {argType} » au paramètre « {paramName} » de type « {paramType} » dans la fonction « {functionName} »",
        "argMissingForParam": "Argument manquant pour le paramètre {name}",
        "argMissingForParams": "Arguments manquants pour les paramètres {names}",
        "argMorePositionalExpectedCount": "{expected} arguments positionnels supplémentaires attendus",
        "argMorePositionalExpectedOne": "1 argument positionnel supplémentaire attendu",
        "argPositional": "Argument positionnel attendu",
        "argPositionalExpectedCount": "Arguments positionnels {expected} attendus",
        "argPositionalExpectedOne": "1 argument positionnel attendu",
        "argTypePartiallyUnknown": "Le type d'argument est partiellement inconnu",
        "argTypeUnknown": "Le type d’argument est inconnu",
        "assertAlwaysTrue": "L’expression Assert prend toujours la valeur true",
        "assertTypeArgs": "« assert_type » attend deux arguments positionnels",
        "assertTypeTypeMismatch": "Non-concordance de « assert_type » : « {expected} » attendu, mais « {received} »",
        "assignmentExprComprehension": "La cible d'expression d'affectation \"{name}\" ne peut pas utiliser le même nom que la compréhension pour la cible",
        "assignmentExprContext": "L’expression d’assignation doit se trouver dans le module, la fonction ou l’expression lambda",
        "assignmentExprInSubscript": "Les expressions d’assignation dans un indice sont prises en charge uniquement dans Python 3.10 et versions ultérieures",
        "assignmentInProtocol": "Les variables d'instance ou de classe au sein d'une classe Protocol doivent être explicitement déclarées dans le corps de la classe",
        "assignmentTargetExpr": "L’expression ne peut pas être une cible d’assignation",
        "asyncNotInAsyncFunction": "L'utilisation de \"async\" n'est pas autorisée en dehors de la fonction async",
        "awaitIllegal": "L’utilisation de « await » nécessite Python 3.5 ou version ultérieure",
        "awaitNotAllowed": "Les expressions de type ne peuvent pas utiliser « await »",
        "awaitNotInAsync": "« await » autorisé uniquement dans la fonction asynchrone",
        "backticksIllegal": "Les expressions entourées de accents inverses ne sont pas prises en charge dans Python 3.x; utiliser repr à la place",
        "baseClassCircular": "La classe ne peut pas dériver d'elle-même",
        "baseClassFinal": "La classe de base « {type} » est marquée comme finale et ne peut pas être sous-classée",
        "baseClassIncompatible": "Les classes de base de {type} sont mutuellement incompatibles",
        "baseClassInvalid": "L’argument pour la classe doit être une classe de base",
        "baseClassMethodTypeIncompatible": "Les classes de base de la classe « {classType} » définissent la méthode « {name} » de manière incompatible",
        "baseClassUnknown": "Le type de classe de base est inconnu, ce qui masque le type de classe dérivée",
        "baseClassVariableTypeIncompatible": "Les classes de base de la classe « {classType} » définissent la variable « {name} » de manière incompatible",
        "binaryOperationNotAllowed": "Opérateur binaire non autorisé dans l'expression de type",
        "bindTypeMismatch": "Impossible de lier la méthode \"{methodName}\" car \"{type}\" n'est pas attribuable au paramètre \"{paramName}\"",
        "breakInExceptionGroup": "« break » n’est pas autorisé dans un bloc « except* »",
        "breakOutsideLoop": "\"break\" ne peut être utilisé qu'à l'intérieur d'une boucle",
        "bytesUnsupportedEscape": "Séquence d’échappement non prise en charge dans le littéral de bytes",
        "callableExtraArgs": "Seuls deux arguments de type sont attendus pour « Callable »",
        "callableFirstArg": "Liste de types de paramètres attendue ou « ... »",
        "callableNotInstantiable": "Impossible d’instancier le type « {type} »",
        "callableSecondArg": "Type de retour attendu en tant que deuxième argument de type pour « Callable »",
        "casePatternIsIrrefutable": "Le motif irréfutable n'est autorisé que pour la dernière instruction case",
        "classAlreadySpecialized": "Le type « {type} » est déjà spécialisé",
        "classDecoratorTypeUnknown": "Le décorateur de classe non typé masque le type de classe ; décorateur ignorant",
        "classDefinitionCycle": "La définition de classe pour \"{name}\" dépend d'elle-même",
        "classGetItemClsParam": "__class_getitem__ remplacement doit prendre un paramètre « cls »",
        "classMethodClsParam": "Les méthodes de classe doivent prendre un paramètre \"cls\"",
        "classNotRuntimeSubscriptable": "L'indice pour la classe « {name} » générera une exception d'exécution ; placez l'expression de type entre guillemets",
        "classPatternBuiltInArgPositional": "Le modèle de classe accepte uniquement le sous-modèle positionnel",
        "classPatternPositionalArgCount": "Trop de modèles positionnels pour les \"{type}\" de classe ; {expected} attendue mais {received} reçues",
        "classPatternTypeAlias": "\"{type}\" ne peut pas être utilisé dans un modèle de classe car il s'agit d'un alias de type spécialisé",
        "classPropertyDeprecated": "Les propriétés de classe sont obsolètes dans Python 3.11 et ne seront pas prises en charge dans Python 3.13",
        "classTypeParametersIllegal": "La syntaxe du paramètre de type de classe nécessite Python 3.12 ou version ultérieure",
        "classVarFirstArgMissing": "Attendu un argument de type après \"ClassVar\"",
        "classVarNotAllowed": "« ClassVar » n’est pas autorisé dans ce contexte",
        "classVarOverridesInstanceVar": "La variable de classe « {name} » remplace la variable d’instance du même nom dans la classe « {className} »",
        "classVarTooManyArgs": "Attendu un seul argument de type après \"ClassVar\"",
        "classVarWithTypeVar": "Le type \"ClassVar\" ne peut pas inclure de variables de type",
        "clsSelfParamTypeMismatch": "Le type de paramètre \"{name}\" doit être un supertype de sa classe \"{classType}\"",
        "codeTooComplexToAnalyze": "Le code est trop complexe à analyser ; réduire la complexité en refactorisant en sous-routines ou en réduisant les chemins de code conditionnels",
        "collectionAliasInstantiation": "Le type \"{type}\" ne peut pas être instancié, utilisez \"{alias}\" à la place",
        "comparisonAlwaysFalse": "La condition prend toujours la valeur False, car les types « {leftType} » et « {rightType} » ne se chevauchent pas",
        "comparisonAlwaysTrue": "La condition prend toujours la valeur True, car les types « {leftType} » et « {rightType} » ne se chevauchent pas",
        "comprehensionInDict": "La compréhension ne peut pas être utilisée avec d’autres entrées de dictionnaire",
        "comprehensionInSet": "La compréhension ne peut pas être utilisée avec d’autres entrées set",
        "concatenateContext": "« Concatenate » n’est pas autorisé dans ce contexte",
        "concatenateParamSpecMissing": "Le dernier argument de type pour « Concatenate » doit être un ParamSpec ou bien « ... »",
        "concatenateTypeArgsMissing": "« Concatenate » nécessite au moins deux arguments de type",
        "conditionalOperandInvalid": "Opérande conditionnel non valide de type \"{type}\"",
        "constantRedefinition": "\"{name}\" est constant (car il est en majuscule) et ne peut pas être redéfini",
        "constructorParametersMismatch": "Non-concordance entre la signature de __new__ et __init__ dans la classe \"{classType}\"",
        "containmentAlwaysFalse": "L'expression sera toujours évaluée à False car les types \"{leftType}\" et \"{rightType}\" ne se chevauchent pas",
        "containmentAlwaysTrue": "L'expression sera toujours évaluée à True puisque les types \"{leftType}\" et \"{rightType}\" ne se chevauchent pas",
        "continueInExceptionGroup": "« continue » n’est pas autorisé dans un bloc « except* »",
        "continueOutsideLoop": "« continuer » ne peut être utilisé qu’au sein d’une boucle",
        "coroutineInConditionalExpression": "L'expression conditionnelle fait référence à une coroutine qui est toujours évaluée à True",
        "dataClassBaseClassFrozen": "Une classe non gelée ne peut pas hériter d'une classe gelée",
        "dataClassBaseClassNotFrozen": "Une classe figée ne peut pas hériter d’une classe qui n’est pas figée",
        "dataClassConverterFunction": "L’argument de type « {argType} » n’est pas un convertisseur valide pour le champ « {fieldName} » de type « {fieldType} »",
        "dataClassConverterOverloads": "Aucune surcharge de « {funcName} » n’est valide pour le champ « {fieldName} » de type « {fieldType} »",
        "dataClassFieldInheritedDefault": "« {fieldName} » remplace un champ du même nom mais n’a pas de valeur par défaut",
        "dataClassFieldWithDefault": "Les champs sans valeurs par défaut ne peuvent pas apparaître après les champs avec des valeurs par défaut",
        "dataClassFieldWithPrivateName": "Le champ Dataclass ne peut pas utiliser de nom privé",
        "dataClassFieldWithoutAnnotation": "Le champ Dataclass sans annotation de type provoquera une exception d'exécution",
        "dataClassPostInitParamCount": "La classe de données __post_init__ nombre de paramètres incorrect ; le nombre de champs InitVar est {expected}",
        "dataClassPostInitType": "Incompatibilité du type de paramètre de méthode __post_init__ Dataclass pour le champ « {fieldName} »",
        "dataClassSlotsOverwrite": "__slots__ est déjà défini dans la classe",
        "dataClassTransformExpectedBoolLiteral": "Expression attendue qui prend statiquement la valeur True ou False",
        "dataClassTransformFieldSpecifier": "Expected tuple of classes or functions but received type \"{type}\"",
        "dataClassTransformPositionalParam": "Tous les arguments de « dataclass_transform » doivent être des arguments de mot clé",
        "dataClassTransformUnknownArgument": "L’argument « {name} » n’est pas pris en charge par dataclass_transform",
        "dataProtocolInSubclassCheck": "Les protocoles de données (qui incluent des attributs non méthode) ne sont pas autorisés dans les appels de issubclass",
        "declaredReturnTypePartiallyUnknown": "Le type de retour déclaré « {returnType} » est partiellement inconnu",
        "declaredReturnTypeUnknown": "Le type de retour déclaré est inconnu",
        "defaultValueContainsCall": "Les appels de fonction et les objets mutables ne sont pas autorisés dans l'expression de la valeur par défaut du paramètre",
        "defaultValueNotAllowed": "Le paramètre avec « * » ou « ** » ne peut pas avoir de valeur par défaut",
        "delTargetExpr": "L'expression ne peut pas être supprimée",
        "deprecatedClass": "La classe \"{name}\" est obsolète",
        "deprecatedConstructor": "Le constructeur de la classe « {name} » est déconseillé",
        "deprecatedDescriptorDeleter": "La méthode « __delete__ » du descripteur « {name} » est déconseillée",
        "deprecatedDescriptorGetter": "La méthode « __get__ » du descripteur « {name} » est déconseillée",
        "deprecatedDescriptorSetter": "La méthode « __set__ » du descripteur « {name} » est déconseillée",
        "deprecatedFunction": "La fonction \"{name}\" est obsolète",
        "deprecatedMethod": "La méthode \"{name}\" dans la classe \"{className}\" est obsolète",
        "deprecatedPropertyDeleter": "Le deleter de la property « {name} » est déconseillé",
        "deprecatedPropertyGetter": "Le getter de la property « {name} » est déconseillé",
        "deprecatedPropertySetter": "Le setter de la property « {name} » est déconseillé",
        "deprecatedType": "Ce type est déconseillé à compter de Python {version}; utiliser « {replacement} » à la place",
        "dictExpandIllegalInComprehension": "Expansion du dictionnaire non autorisée dans la compréhension",
        "dictInAnnotation": "Expression de dictionnaire non autorisée dans l'expression de type",
        "dictKeyValuePairs": "Les entrées de dictionnaire doivent contenir des paires clé/valeur",
        "dictUnpackIsNotMapping": "Mappage attendu pour l’opérateur de décompression de dictionnaire",
        "dunderAllSymbolNotPresent": "« {name} » est spécifié dans __all__ mais n’est pas présent dans le module",
        "duplicateArgsParam": "Un seul paramètre « * » est autorisé",
        "duplicateBaseClass": "Classe de base en double non autorisée",
        "duplicateCapturePatternTarget": "La cible Capture \"{name}\" ne peut pas apparaître plus d'une fois dans le même modèle",
        "duplicateCatchAll": "Une seule clause catch-all except autorisée",
        "duplicateEnumMember": "Le membre Enum « {name} » est déjà déclaré",
        "duplicateGenericAndProtocolBase": "Une seule classe de base Generic[...] ou Protocol[...] autorisée",
        "duplicateImport": "« {importName} » est importé plusieurs fois",
        "duplicateKeywordOnly": "Un seul séparateur « * » autorisé",
        "duplicateKwargsParam": "Un seul paramètre « ** » est autorisé",
        "duplicateParam": "Dupliquer le paramètre « {name} »",
        "duplicatePositionOnly": "Un seul paramètre \"/\" autorisé",
        "duplicateStarPattern": "Un seul motif \"*\" autorisé dans une séquence de motifs",
        "duplicateStarStarPattern": "Une seule entrée \"**\" autorisée",
        "duplicateUnpack": "Une seule opération de décompression autorisée dans la liste",
        "ellipsisAfterUnpacked": "\"...\" ne peut pas être utilisé avec un TypeVarTuple ou un tuple décompressé",
        "ellipsisContext": "« ... » n’est pas autorisé dans ce contexte",
        "ellipsisSecondArg": "« ... » n’est autorisé qu’en tant que second des deux arguments",
        "enumClassOverride": "La classe Enum « {name} » est finale et ne peut pas être sous-classée",
        "enumMemberDelete": "Le membre Enum « {name} » ne peut pas être supprimé",
        "enumMemberSet": "Le membre Enum « {name} » ne peut pas être affecté",
        "enumMemberTypeAnnotation": "Les annotations de type ne sont pas autorisées pour les membres enum",
        "exceptGroupMismatch": "L’instruction Try ne peut pas inclure à la fois « except » et « except* »",
        "exceptGroupRequiresType": "La syntaxe du groupe d’exceptions (« except* ») nécessite un type d’exception",
        "exceptionGroupIncompatible": "La syntaxe du groupe d’exceptions (« except* ») nécessite Python 3.11 ou version ultérieure",
        "exceptionGroupTypeIncorrect": "Le type d’exception dans except* ne peut pas dériver de BaseGroupException",
        "exceptionTypeIncorrect": "\"{type}\" ne dérive pas de BaseException",
        "exceptionTypeNotClass": "« {type} » n’est pas une classe d’exception valide",
        "exceptionTypeNotInstantiable": "Le constructeur pour le type d’exception « {type} » requiert un ou plusieurs arguments",
        "expectedAfterDecorator": "Fonction attendue ou déclaration de classe après le décorateur",
        "expectedArrow": "« -> » attendu suivi d’une annotation de type de retour",
        "expectedAsAfterException": "« as » attendu après le type d’exception",
        "expectedAssignRightHandExpr": "Expression attendue à droite de « = »",
        "expectedBinaryRightHandExpr": "Expression attendue à droite de l’opérateur",
        "expectedBoolLiteral": "Attendu True ou False",
        "expectedCase": "Instruction « case » attendue",
        "expectedClassName": "Nom de classe attendu",
        "expectedCloseBrace": "« { » n’a pas été fermé",
        "expectedCloseBracket": "« [ » n’a pas été fermé",
        "expectedCloseParen": "« ( » n’a pas été fermé",
        "expectedColon": "« : » attendu",
        "expectedComplexNumberLiteral": "Littéral de nombre complexe attendu pour la correspondance de modèle",
        "expectedDecoratorExpr": "Formulaire d’expression non pris en charge pour l’élément décoratif antérieur à Python 3.9",
        "expectedDecoratorName": "Nom de l’élément décoratif attendu",
        "expectedDecoratorNewline": "Nouvelle ligne attendue à la fin de l’élément décoratif",
        "expectedDelExpr": "Expression attendue après « del »",
        "expectedElse": "« else » attendu",
        "expectedEquals": "« = » attendu",
        "expectedExceptionClass": "Classe ou objet d'exception non valide",
        "expectedExceptionObj": "Objet d’exception attendu, classe d’exception ou None",
        "expectedExpr": "Expression attendue",
        "expectedFunctionAfterAsync": "Définition de fonction attendue après \"async\"",
        "expectedFunctionName": "Nom de fonction attendu après « def »",
        "expectedIdentifier": "Identifiant attendu",
        "expectedImport": "« importation » attendue",
        "expectedImportAlias": "Symbole attendu après « as »",
        "expectedImportSymbols": "Un ou plusieurs noms de symboles attendus après « l’importation »",
        "expectedIn": "« in » attendu",
        "expectedInExpr": "Expression attendue après « in »",
        "expectedIndentedBlock": "Bloc en retrait attendu",
        "expectedMemberName": "Nom d’attribut attendu après « . »",
        "expectedModuleName": "Nom de module attendu",
        "expectedNameAfterAs": "Nom de symbole attendu après \"as\"",
        "expectedNamedParameter": "Le paramètre de mot clé doit suivre « * »",
        "expectedNewline": "Nouvelle ligne attendue",
        "expectedNewlineOrSemicolon": "Les instructions doivent être séparées par des nouvelles lignes ou des points-virgules",
        "expectedOpenParen": "Attendu \"(\"",
        "expectedParamName": "Nom du paramètre attendu",
        "expectedPatternExpr": "Expression de modèle attendue",
        "expectedPatternSubjectExpr": "Expression du sujet du modèle attendu",
        "expectedPatternValue": "Expression de valeur de modèle attendue sous la forme « a.b »",
        "expectedReturnExpr": "Expression attendue après « return »",
        "expectedSliceIndex": "Expression d'index ou de tranche attendue",
        "expectedTypeNotString": "Type attendu mais réception d’un littéral de chaîne",
        "expectedTypeParameterName": "Nom de paramètre de type attendu",
        "expectedYieldExpr": "Expression attendue dans l'instruction yield",
        "finalClassIsAbstract": "La classe « {type} » est marquée comme finale et doit implémenter toutes les symboles abstraits",
        "finalContext": "« Final » n’est pas autorisé dans ce contexte",
        "finalInLoop": "Impossible d’assigner une variable « Final » dans une boucle",
        "finalMethodOverride": "La méthode « {name} » ne peut pas remplacer la méthode finale définie dans la classe « {className} »",
        "finalNonMethod": "La fonction « {name} » ne peut pas être marquée @final, car il ne s’agit pas d’une méthode",
        "finalReassigned": "« {name} » est déclaré Final et ne peut pas être réaffecté",
        "finalRedeclaration": "« {name} » a été déclaré comme Final",
        "finalRedeclarationBySubclass": "« {name} » ne peut pas être redéclaré, car la classe parente « {className} » la déclare Final",
        "finalTooManyArgs": "Argument de type unique attendu après « Final »",
        "finalUnassigned": "« {name} » est déclaré Final, mais la valeur n’est pas affectée",
        "formatStringBrace": "Accolade fermante unique non autorisée dans le littéral f-string ; utiliser une double accolade fermée",
        "formatStringBytes": "Les littéraux de chaîne de format (chaînes f) ne peuvent pas être binaires",
        "formatStringDebuggingIllegal": "Le spécificateur de débogage de chaîne F \"=\" nécessite Python 3.8 ou une version plus récente",
        "formatStringEscape": "Séquence d'échappement (barre oblique inverse) non autorisée dans la partie expression de la chaîne f avant Python 3.12",
        "formatStringExpectedConversion": "Spécificateur de conversion attendu après « ! » dans f-string",
        "formatStringIllegal": "Les littéraux de chaîne de format (chaînes f) nécessitent Python 3.6 ou une version plus récente",
        "formatStringInPattern": "Chaîne de format non autorisée dans le modèle",
        "formatStringNestedFormatSpecifier": "Expressions imbriqués trop profondément dans le spécificateur de chaîne de format",
        "formatStringNestedQuote": "Les chaînes imbriquées dans une chaîne f ne peuvent pas utiliser le même guillemet que la chaîne f avant Python 3.12",
        "formatStringUnicode": "Les littéraux de chaîne de format (f-strings) ne peuvent pas être unicode",
        "formatStringUnterminated": "Expression non terminée dans f-string ; attendant \"}\"",
        "functionDecoratorTypeUnknown": "Le décorateur de fonction non typé masque le type de fonction ; élément décoratif ignoré",
        "functionInConditionalExpression": "L’expression conditionnelle fait référence à une fonction qui prend toujours la valeur True",
        "functionTypeParametersIllegal": "La syntaxe des paramètres de type de fonction nécessite Python 3.12 ou une version plus récente",
        "futureImportLocationNotAllowed": "Les importations à partir de __future__ doivent se trouver au début du fichier",
        "generatorAsyncReturnType": "Le type de retour de la fonction de générateur asynchrone doit être compatible avec « AsyncGenerator[{yieldType}, Any] »",
        "generatorNotParenthesized": "Les expressions de générateur doivent être entre parenthèses si elles ne sont pas uniquement des arguments",
        "generatorSyncReturnType": "Le type de retour de la fonction de générateur doit être compatible avec « Generator[{yieldType}, Any, Any] »",
        "genericBaseClassNotAllowed": "La classe de base « Generic » ne peut pas être utilisée avec la syntaxe de paramètre de type",
        "genericClassAssigned": "Impossible d’attribuer le type de classe générique",
        "genericClassDeleted": "Le type de classe générique ne peut pas être supprimé",
        "genericInstanceVariableAccess": "L’accès à une variable d’instance générique via une classe est ambigu",
        "genericNotAllowed": "« Generic » n’est pas valide dans ce contexte",
        "genericTypeAliasBoundTypeVar": "L’alias de type générique dans la classe ne peut pas utiliser les variables de type lié {names}",
        "genericTypeArgMissing": "« Generic » nécessite au moins un argument de type",
        "genericTypeArgTypeVar": "L’argument de type pour « Generic » doit être une variable de type",
        "genericTypeArgUnique": "Les arguments de type pour « Generic » doivent être uniques",
        "globalReassignment": "« {name} » est attribué avant la déclaration globale",
        "globalRedefinition": "« {name} » a déjà été déclaré global",
        "implicitStringConcat": "Concaténation implicite de chaînes non autorisée",
        "importCycleDetected": "Cycle détecté dans la chaîne d'importation",
        "importDepthExceeded": "La profondeur de la chaîne d'importation a dépassé {depth}",
        "importResolveFailure": "Impossible de résoudre l’importation « {importName} »",
        "importSourceResolveFailure": "Impossible de résoudre l’importation « {importName} » à partir de la source",
        "importSymbolUnknown": "« {name} » est un symbole d’importation inconnu",
        "incompatibleMethodOverride": "La méthode « {name} » remplace la classe « {className} » de manière incompatible",
        "inconsistentIndent": "Le montant du retrait ne correspond pas au retrait précédent",
        "inconsistentTabs": "Utilisation incohérente des onglets et des espaces dans la mise en retrait",
        "initMethodSelfParamTypeVar": "L’annotation de type pour le paramètre « self » de la méthode « __init__ » ne peut pas contenir de variables de type de portée de classe",
        "initMustReturnNone": "Le type de retour de « __init__ » doit être None",
        "initSubclassCallFailed": "Arguments de mot clé incorrects pour la méthode __init_subclass__",
        "initSubclassClsParam": "__init_subclass__ remplacement doit prendre un paramètre « cls »",
        "initVarNotAllowed": "« InitVar » n’est pas autorisé dans ce contexte",
        "instanceMethodSelfParam": "Les méthodes d’instance doivent prendre un paramètre « self »",
        "instanceVarOverridesClassVar": "La variable d'instance \"{name}\" remplace la variable de classe du même nom dans la classe \"{className}\"",
        "instantiateAbstract": "Impossible d'instancier la classe abstraite \"{type}\"",
        "instantiateProtocol": "Impossible d’instancier la classe de Protocol \"{type}\"",
        "internalBindError": "Une erreur interne s’est produite lors de la liaison du fichier « {file} » : {message}",
        "internalParseError": "Une erreur interne s’est produite lors de l’analyse du fichier « {file} » : {message}",
        "internalTypeCheckingError": "Une erreur interne s’est produite lors de la vérification de type du fichier « {file} » : {message}",
        "invalidIdentifierChar": "Caractère invalide dans l'identifiant",
        "invalidStubStatement": "L’instruction n’a aucun sens dans un fichier stub de type",
        "invalidTokenChars": "Caractère non valide \"{text}\" dans le jeton",
        "isInstanceInvalidType": "Le deuxième argument de \"isinstance\" doit être une classe ou un tuple de classes",
        "isSubclassInvalidType": "Le deuxième argument de « issubclass » doit être une classe ou un tuple de classes",
        "keyValueInSet": "Les paires clé/valeur ne sont pas autorisées dans un set",
        "keywordArgInTypeArgument": "Les arguments de mot-clé ne peuvent pas être utilisés dans les listes d'arguments de type",
        "keywordArgShortcutIllegal": "Le raccourci d’argument de mot clé nécessite Python 3.14 ou une version plus récente",
        "keywordOnlyAfterArgs": "Séparateur d’arguments mot clé uniquement non autorisé après le paramètre « * »",
        "keywordParameterMissing": "Un ou plusieurs paramètres de mot-clé doivent suivre le paramètre \"*\"",
        "keywordSubscriptIllegal": "Les arguments de mot-clé dans les indices ne sont pas pris en charge",
        "lambdaReturnTypePartiallyUnknown": "Le type de retour de lambda, « {returnType} », est partiellement inconnu",
        "lambdaReturnTypeUnknown": "Le type de retour de lambda est inconnu",
        "listAssignmentMismatch": "Impossible d’affecter l’expression de type « {type} » à la liste cible",
        "listInAnnotation": "Expression de List non autorisée dans l’expression de type",
        "literalEmptyArgs": "Attendu un ou plusieurs arguments de type après \"Literal\"",
        "literalNamedUnicodeEscape": "Les séquences d’échappement Unicode nommées ne sont pas prises en charge dans les annotations de chaîne « Literal »",
        "literalNotAllowed": "« Literal » ne peut pas être utilisé dans ce contexte sans argument de type",
        "literalNotCallable": "Impossible d’instancier le type Literal",
        "literalUnsupportedType": "Les arguments de type pour « Literal » doivent être None, une valeur littérale (int, bool, str ou bytes) ou une valeur enum",
        "matchIncompatible": "Les instructions de Match nécessitent Python 3.10 ou version ultérieure",
        "matchIsNotExhaustive": "Les cas dans l’instruction match ne gèrent pas toutes les valeurs de manière exhaustive",
        "maxParseDepthExceeded": "Profondeur d’analyse maximale dépassée ; scinder l’expression en sous-expressions plus petites",
        "memberAccess": "Désolé... Nous ne pouvons pas accéder à l’attribut « {name} » pour la classe « {type} »",
        "memberDelete": "Désolé... Nous ne pouvons pas supprimer l’attribut « {name} » pour la classe « {type} »",
        "memberSet": "Désolé... Nous ne pouvons pas affecter l’attribut « {name} » pour la classe « {type} »",
        "metaclassConflict": "La métaclasse d’une classe dérivée doit être une sous-classe des métaclasses de toutes ses classes de base",
        "metaclassDuplicate": "Une seule métaclasse peut être fournie",
        "metaclassIsGeneric": "La métaclasse ne peut pas être générique",
        "methodNotDefined": "Méthode « {name} » non définie",
        "methodNotDefinedOnType": "Méthode « {name} » non définie sur le type « {type} »",
        "methodOrdering": "Impossible de créer un classement de méthode cohérent",
        "methodOverridden": "\"{name}\" remplace la méthode du même nom dans la classe \"{className}\" avec un type incompatible \"{type}\"",
        "methodReturnsNonObject": "La méthode « {name} » ne retourne pas d’objet",
        "missingSuperCall": "La méthode « {methodName} » n’appelle pas la méthode du même nom dans la classe parente",
        "mixingBytesAndStr": "Les valeurs Bytes et str ne peuvent pas être concaténées",
        "moduleAsType": "Le module ne peut pas être utilisé comme type",
        "moduleNotCallable": "Le module ne peut pas être appelé",
        "moduleUnknownMember": "« {memberName} » n’est pas un attribut connu du module « {moduleName} »",
        "namedExceptAfterCatchAll": "Une clause except nommée ne peut pas apparaître après une clause except fourre-tout",
        "namedParamAfterParamSpecArgs": "Le paramètre de mot clé « {name} » ne peut pas apparaître dans la signature après le paramètre ParamSpec args",
        "namedTupleEmptyName": "Les noms dans un tuple nommé ne peuvent pas être vides",
        "namedTupleEntryRedeclared": "Impossible de remplacer « {name} », car la classe parente « {className} » est un tuple nommé",
        "namedTupleFirstArg": "Nom de classe de tuple nommé attendu en tant que premier argument",
        "namedTupleMultipleInheritance": "L’héritage multiple avec NamedTuple n’est pas pris en charge",
        "namedTupleNameKeyword": "Les noms de champs ne peuvent pas être un mot-clé",
        "namedTupleNameType": "Expected two-entry tuple specifying entry name and type",
        "namedTupleNameUnique": "Les noms dans un tuple nommé doivent être uniques",
        "namedTupleNoTypes": "« namedtuple » ne fournit aucun type pour les entrées de tuple ; utilisez « NamedTuple » à la place",
        "namedTupleSecondArg": "Expected named tuple entry list as second argument",
        "newClsParam": "__new__ remplacement doit prendre un paramètre « cls »",
        "newTypeAnyOrUnknown": "Le deuxième argument de NewType doit être une classe connue, et non Any ou Unknown",
        "newTypeBadName": "Le premier argument de NewType doit être un littéral de chaîne",
        "newTypeLiteral": "Impossible d’utiliser NewType avec le type Literal",
        "newTypeNameMismatch": "NewType doit être affecté à une variable portant le même nom",
        "newTypeNotAClass": "Classe attendue comme deuxième argument de NewType",
        "newTypeParamCount": "NewType requiert deux arguments positionnels",
        "newTypeProtocolClass": "Désolé, nous n’avons pas pu utiliser NewType avec un type structurelle (un Protocol ou une classe TypedDict)",
        "noOverload": "Aucune surcharge pour « {name} » ne correspond aux arguments fournis",
        "noReturnContainsReturn": "La fonction avec le type de return déclaré « NoReturn » ne peut pas inclure d’instruction de return",
        "noReturnContainsYield": "La fonction avec le type de retour déclaré « NoReturn » ne peut pas inclure d’instruction yield",
        "noReturnReturnsNone": "La fonction avec le type de retour déclaré \"NoReturn\" ne peut pas renvoyer \"None\"",
        "nonDefaultAfterDefault": "L’argument autre que l’argument par défaut suit l’argument par défaut",
        "nonLocalInModule": "Déclaration nonlocal non autorisée au niveau du module",
        "nonLocalNoBinding": "Aucune liaison pour le « {name} » nonlocal trouvé",
        "nonLocalReassignment": "« {name} » est attribué avant la déclaration nonlocal",
        "nonLocalRedefinition": "« {name} » a déjà été déclaré nonlocal",
        "noneNotCallable": "L’objet de type « None » ne peut pas être appelé",
        "noneNotIterable": "L’objet de type « None » ne peut pas être utilisé en tant que valeur itérable",
        "noneNotSubscriptable": "L’objet de type « None » n’est pas inscriptible",
        "noneNotUsableWith": "Object of type \"None\" cannot be used with \"with\"",
        "noneNotUsableWithAsync": "Object of type \"None\" cannot be used with \"async with\"",
        "noneOperator": "L’opérateur « {operator} » n’est pas pris en charge pour « None »",
        "noneUnknownMember": "« {name} » n’est pas un attribut connu de « None »",
        "notRequiredArgCount": "Argument de type unique attendu après « NotRequired »",
        "notRequiredNotInTypedDict": "« NotRequired » n’est pas autorisé dans ce contexte",
        "objectNotCallable": "L’objet de type « {type} » n’est pas appelant",
        "obscuredClassDeclaration": "La déclaration de classe « {name} » est masquée par une déclaration du même nom",
        "obscuredFunctionDeclaration": "La déclaration de fonction « {name} » est masquée par une déclaration du même nom",
        "obscuredMethodDeclaration": "La déclaration de méthode « {name} » est masquée par une déclaration du même nom",
        "obscuredParameterDeclaration": "La déclaration de paramètre « {name} » est masquée par une déclaration du même nom",
        "obscuredTypeAliasDeclaration": "La déclaration d’alias de type « {name} » est masquée par une déclaration du même nom",
        "obscuredVariableDeclaration": "La déclaration « {name} » est masquée par une déclaration du même nom",
        "operatorLessOrGreaterDeprecated": "L’opérateur « <> » n’est pas pris en charge dans Python 3 ; utilisez « != » à la place",
        "optionalExtraArgs": "Attendu un argument de type après « Optional »",
        "orPatternIrrefutable": "Modèle irréfutable autorisé uniquement en tant que dernier sous-modèle dans un modèle \"ou\"",
        "orPatternMissingName": "Tous les sous-modèles d’un modèle « or » doivent cibler les mêmes noms",
        "overlappingKeywordArgs": "Le dictionnaire tapé chevauche avec le mot clé paramètre : {names}",
        "overlappingOverload": "La surcharge {obscured} pour « {name} » ne sera jamais utilisée, car ses paramètres chevauchent la surcharge {obscuredBy}",
        "overloadAbstractImplMismatch": "Les surcharges doivent correspondre à l’état abstrait de l’implémentation",
        "overloadAbstractMismatch": "Les surcharges doivent toutes être abstraites ou non",
        "overloadClassMethodInconsistent": "Les surcharges pour « {name} » utilisent @classmethod de manière incohérente",
        "overloadFinalInconsistencyImpl": "La surcharge pour « {name} » est marquée @final, mais l’implémentation ne l’est pas",
        "overloadFinalInconsistencyNoImpl": "La surcharge {index} pour « {name} » est marquée @final mais la surcharge 1 n’est pas",
        "overloadImplementationMismatch": "L’implémentation surchargée n’est pas cohérente avec la signature de la surcharge {index}",
        "overloadReturnTypeMismatch": "La surcharge {prevIndex} pour « {name} » chevauche la surcharge {newIndex} et retourne un type incompatible",
        "overloadStaticMethodInconsistent": "Les surcharges pour « {name} » utilisent @staticmethod de manière incohérente",
        "overloadWithoutImplementation": "« {name} » est marqué comme overload, mais aucune implémentation n’est fournie",
        "overriddenMethodNotFound": "La méthode « {name} » est marquée comme override, mais aucune méthode de base du même nom n’est présente",
        "overrideDecoratorMissing": "La méthode \"{name}\" n'est pas marquée comme override mais remplace une méthode dans la classe \"{className}\"",
        "paramAfterKwargsParam": "Le paramètre ne peut pas suivre le paramètre \"**\"",
        "paramAlreadyAssigned": "Le paramètre « {name} » est déjà affecté",
        "paramAnnotationMissing": "L'annotation de type est manquante pour le paramètre \"{name}\"",
        "paramAssignmentMismatch": "L'expression de type \"{sourceType}\" ne peut pas être affectée au paramètre de type \"{paramType}\"",
        "paramNameMissing": "Aucun paramètre nommé « {name} »",
        "paramSpecArgsKwargsDuplicate": "Des arguments pour ParamSpec « {type} » ont déjà été fournis",
        "paramSpecArgsKwargsUsage": "Les attributs « args » et « kwargs » de ParamSpec doivent apparaître tous les deux dans une signature de fonction",
        "paramSpecArgsMissing": "Les arguments pour ParamSpec « {type} » sont manquants",
        "paramSpecArgsUsage": "L’attribut « args » de ParamSpec n’est valide que lorsqu’il est utilisé avec le paramètre *args",
        "paramSpecAssignedName": "ParamSpec doit être affecté à une variable nommée « {name} »",
        "paramSpecContext": "ParamSpec n’est pas autorisé dans ce contexte",
        "paramSpecDefaultNotTuple": "Points de suspension attendus, expression de tuple ou ParamSpec pour la valeur par défaut de ParamSpec",
        "paramSpecFirstArg": "Nom attendu de ParamSpec comme premier argument",
        "paramSpecKwargsUsage": "L’attribut « kwargs » de ParamSpec n’est valide que lorsqu’il est utilisé avec le paramètre **kwargs",
        "paramSpecNotUsedByOuterScope": "ParamSpec « {name} » n’a aucune signification dans ce contexte",
        "paramSpecUnknownArg": "ParamSpec ne prend pas en charge plus d'un argument",
        "paramSpecUnknownMember": "« {name} » n’est pas un attribut connu de ParamSpec",
        "paramSpecUnknownParam": "\"{name}\" est un paramètre inconnu pour ParamSpec",
        "paramTypeCovariant": "Impossible d’utiliser la variable de type Covariant dans le type de paramètre",
        "paramTypePartiallyUnknown": "Le type du paramètre « {paramName} » est partiellement inconnu",
        "paramTypeUnknown": "Le type de paramètre « {paramName} » est inconnu",
        "parenthesizedContextManagerIllegal": "Parentheses within \"with\" statement requires Python 3.9 or newer",
        "patternNeverMatches": "Le modèle ne sera jamais mis en correspondance pour le type d’objet « {type} »",
        "positionArgAfterNamedArg": "L’argument positionnel ne peut pas apparaître après les arguments de mot clé",
        "positionArgAfterUnpackedDictArg": "Positional argument cannot appear after keyword argument unpacking",
        "positionOnlyAfterArgs": "Séparateur de paramètres de position seule non autorisé après le paramètre « * »",
        "positionOnlyAfterKeywordOnly": "Le paramètre « / » doit apparaître avant le paramètre « * »",
        "positionOnlyAfterNon": "Paramètre de position seule non autorisé après un paramètre qui n’est pas en position seule",
        "positionOnlyFirstParam": "Séparateur de paramètres de position seule non autorisé en tant que premier paramètre",
        "positionOnlyIncompatible": "Le séparateur de paramètres de position seule requiert Python 3.8 ou version ultérieure",
        "privateImportFromPyTypedModule": "« {name} » n’est pas exporté à partir du module « {module} »",
        "privateUsedOutsideOfClass": "« {name} » est privé et utilisé en dehors de la classe dans laquelle il est déclaré",
        "privateUsedOutsideOfModule": "« {name} » est privé et utilisé en dehors du module dans lequel il est déclaré",
        "propertyOverridden": "« {name} » remplace à tort la property du même nom dans la classe « {className} »",
        "propertyStaticMethod": "Méthodes statiques non autorisées pour la property getter, setter ou deleter",
        "protectedUsedOutsideOfClass": "\"{name}\" est protégé et utilisé en dehors de la classe dans laquelle il est déclaré",
        "protocolBaseClass": "La classe de Protocol \"{classType}\" ne peut pas dériver de la classe non Protocol \"{baseType}\"",
        "protocolBaseClassWithTypeArgs": "Les arguments de type ne sont pas autorisés avec la classe Protocol lors de l'utilisation de la syntaxe des paramètres de type",
        "protocolIllegal": "L’utilisation de « Protocole » nécessite Python 3.7 ou une version plus récente",
        "protocolNotAllowed": "\"Protocole\" ne peut pas être utilisé dans ce contexte",
        "protocolTypeArgMustBeTypeParam": "L’argument de type pour « Protocol » doit être un paramètre de type",
        "protocolUnsafeOverlap": "La classe chevauche « {name} » de manière non sécurisée et peut produire une correspondance au moment de l’exécution",
        "protocolVarianceContravariant": "La variable de type \"{variable}\" utilisée dans le Protocol générique \"{class}\" doit être contravariante",
        "protocolVarianceCovariant": "La variable de type \"{variable}\" utilisée dans le Protocol générique \"{class}\" doit être covariante",
        "protocolVarianceInvariant": "La variable de type \"{variable}\" utilisée dans le Protocol générique \"{class}\" doit être invariante",
        "pyrightCommentInvalidDiagnosticBoolValue": "La directive de commentaire Pyright doit être suivie de « = » et d’une valeur true ou false",
        "pyrightCommentInvalidDiagnosticSeverityValue": "La directive de commentaire Pyright doit être suivie de « = » et avoir la valeur true, false, error, warning, information ou none",
        "pyrightCommentMissingDirective": "Le commentaire Pyright doit être suivi d’une directive (basic ou strict) ou d’une règle de diagnostic",
        "pyrightCommentNotOnOwnLine": "Les commentaires Pyright utilisés pour contrôler les paramètres au niveau du fichier doivent apparaître sur leur propre ligne",
        "pyrightCommentUnknownDiagnosticRule": "« {rule} » est une règle de diagnostic inconnue pour le commentaire pyright",
        "pyrightCommentUnknownDiagnosticSeverityValue": "« {value} » n’est pas valide pour le commentaire pyright ; true, false, error, warning, information ou none attendu",
        "pyrightCommentUnknownDirective": "« {directive} » est une directive inconnue pour le commentaire pyright; « strict » ou « basic » attendu",
        "readOnlyArgCount": "Attendu un seul argument de type après \"ReadOnly\"",
        "readOnlyNotInTypedDict": "« ReadOnly » n’est pas autorisé dans ce contexte",
        "recursiveDefinition": "Le type de \"{name}\" n'a pas pu être déterminé car il fait référence à lui-même",
        "relativeImportNotAllowed": "Les importations relatives ne peuvent pas être utilisées avec le formulaire « import .a » ; utiliser « from . import a » à la place",
        "requiredArgCount": "Attendu un argument de type unique après \"Required\"",
        "requiredNotInTypedDict": "« Required » n’est pas autorisé dans ce contexte",
        "returnInAsyncGenerator": "L'instruction de retour avec valeur n'est pas autorisée dans le générateur asynchrone",
        "returnInExceptionGroup": "« return » n’est pas autorisé dans un bloc « except* »",
        "returnMissing": "La fonction avec le type de retour déclaré \"{returnType}\" doit renvoyer une valeur sur tous les chemins de code",
        "returnOutsideFunction": "\"return\" ne peut être utilisé que dans une fonction",
        "returnTypeContravariant": "La variable de type contravariant ne peut pas être utilisée dans le type de retour",
        "returnTypeMismatch": "Le type « {exprType} » n’est pas assignable au type de retour « {returnType} »",
        "returnTypePartiallyUnknown": "Le type de retour « {returnType} » est partiellement inconnu",
        "returnTypeUnknown": "Le type de retour est inconnu",
        "revealLocalsArgs": "Aucun argument attendu pour l'appel \"reveal_locals\"",
        "revealLocalsNone": "Aucun élément locals dans cette étendue",
        "revealTypeArgs": "Argument positionnel unique attendu pour l’appel « reveal_type »",
        "revealTypeExpectedTextArg": "L'argument \"expected_text\" pour la fonction \"reveal_type\" doit être une valeur littérale str",
        "revealTypeExpectedTextMismatch": "Incompatibilité de texte de type ; « {expected} » attendu, mais a reçu « {received} »",
        "revealTypeExpectedTypeMismatch": "Incompatibilité de type; attendu \"{expected}\" mais reçu \"{received}\"",
        "selfTypeContext": "« Self » n’est pas valide dans ce contexte",
        "selfTypeMetaclass": "« Self » ne peut pas être utilisé dans une métaclasse (une sous-classe de « type »)",
        "selfTypeWithTypedSelfOrCls": "« Self » ne peut pas être utilisé dans une fonction avec un paramètre « self » ou « cls » qui a une annotation de type autre que « Self »",
        "setterGetterTypeMismatch": "Le type valeur setter de property n’est pas assignable au type de retour getter",
        "singleOverload": "« {name} » est marqué comme surcharge, mais des surcharges supplémentaires sont manquantes",
        "slotsAttributeError": "\"{name}\" n'est pas spécifié dans __slots__",
        "slotsClassVarConflict": "\"{name}\" est en conflit avec la variable d'instance déclarée dans __slots__",
        "starPatternInAsPattern": "Le modèle d’étoile ne peut pas être utilisé avec la cible « as »",
        "starPatternInOrPattern": "Le modèle d’étoile ne peut pas être supprimé dans d’autres modèles",
        "starStarWildcardNotAllowed": "** ne peut pas être utilisé avec le caractère générique « _ »",
        "staticClsSelfParam": "Les méthodes statiques ne doivent pas prendre de paramètre « self » ou « cls »",
        "stdlibModuleOverridden": "\"{path}\" remplace le module stdlib \"{name}\"",
        "stringNonAsciiBytes": "Caractère non-ASCII non autorisé dans le littéral de chaîne d'octets",
        "stringNotSubscriptable": "L'expression de chaîne ne peut pas être indexée dans une expression de type ; placez l'expression entière entre guillemets",
        "stringUnsupportedEscape": "Séquence d'échappement non prise en charge dans le littéral de chaîne",
        "stringUnterminated": "Le littéral de chaîne n’est pas spécifié",
        "stubFileMissing": "Fichier stub introuvable pour « {importName} »",
        "stubUsesGetAttr": "Le fichier stub de type est incomplet ; « __getattr__ » masque les erreurs de type pour le module",
        "sublistParamsIncompatible": "Les paramètres de Sublist ne sont pas pris en charge dans Python 3.x",
        "superCallArgCount": "Pas plus de deux arguments attendus pour l'appel \"super\"",
        "superCallFirstArg": "Type de classe attendu en tant que premier argument de l’appel « super », mais « {type} » reçu",
        "superCallSecondArg": "Le deuxième argument de l’appel « super » doit être un objet ou une classe dérivé de « {type} »",
        "superCallZeroArgForm": "La forme sans argument d'appel \"super\" n'est valide que dans une méthode",
        "superCallZeroArgFormStaticMethod": "La forme à zéro argument de l’appel « super » n’est pas valide dans une méthode statique",
        "symbolIsPossiblyUnbound": "« {name} » est peut-être indépendant",
        "symbolIsUnbound": "« {name} » est indépendant",
        "symbolIsUndefined": "« {name} » n’est pas défini",
        "symbolOverridden": "« {name} » remplace le symbole du même nom dans la classe « {className} »",
        "ternaryNotAllowed": "Expression ternaire non autorisée dans l'expression de type",
        "totalOrderingMissingMethod": "La classe doit définir « __lt__ », « __le__ », « __gt__ » ou « __ge__ » pour utiliser total_ordering",
        "trailingCommaInFromImport": "Virgule de fin non autorisée sans parenthèses adjacentes",
        "tryWithoutExcept": "L'instruction try doit avoir au moins une clause except ou finally",
        "tupleAssignmentMismatch": "L'expression avec le type \"{type}\" ne peut pas être assignée au tuple cible",
        "tupleInAnnotation": "Expression de tuple non autorisée dans l'expression de type",
        "tupleIndexOutOfRange": "L’index {index} est hors limites pour le type {type}",
        "typeAliasIllegalExpressionForm": "Formulaire d’expression non valide pour la définition d’alias de type",
        "typeAliasIsRecursiveDirect": "L'alias de type \"{name}\" ne peut pas s'utiliser lui-même dans sa définition",
        "typeAliasNotInModuleOrClass": "Un TypeAlias ne peut être défini qu’au sein d’un module ou d’une étendue de classe",
        "typeAliasRedeclared": "« {name} » est déclaré en tant que TypeAlias et ne peut être attribué qu’une seule fois",
        "typeAliasStatementBadScope": "Une instruction de type ne peut être utilisée que dans une étendue de module ou de classe",
        "typeAliasStatementIllegal": "L’instruction d’alias de type nécessite Python 3.12 ou version ultérieure",
        "typeAliasTypeBaseClass": "A type alias defined in a \"type\" statement cannot be used as a base class",
        "typeAliasTypeMustBeAssigned": "TypeAliasType doit être affecté à une variable portant le même nom que l'alias de type",
        "typeAliasTypeNameArg": "Le premier argument de TypeAliasType doit être un littéral de chaîne représentant le nom de l'alias de type",
        "typeAliasTypeNameMismatch": "Le nom de l’alias de type doit correspondre au nom de la variable à laquelle il est affecté",
        "typeAliasTypeParamInvalid": "La liste de paramètres de type doit être un tuple contenant uniquement TypeVar, TypeVarTuple ou ParamSpec",
        "typeAnnotationCall": "Expression d'appel non autorisée dans l'expression de type",
        "typeAnnotationVariable": "Variable non autorisée dans l'expression de type",
        "typeAnnotationWithCallable": "L'argument de type pour \"type\" doit être une classe ; les callables ne sont pas pris en charge",
        "typeArgListExpected": "ParamSpec, ellipse ou liste de types attendue",
        "typeArgListNotAllowed": "Expression de liste non autorisée pour cet argument de type",
        "typeArgsExpectingNone": "Aucun argument de type attendu pour la classe « {name} »",
        "typeArgsMismatchOne": "Argument de type attendu mais {received} reçu",
        "typeArgsMissingForAlias": "Arguments de type attendus pour l’alias de type générique « {name} »",
        "typeArgsMissingForClass": "Arguments de type attendus pour la classe générique \"{name}\"",
        "typeArgsTooFew": "Trop peu d’arguments de type fournis pour « {name} » ; {expected} attendu, mais {received} reçu",
        "typeArgsTooMany": "Trop d'arguments de type fournis pour \"{name}\" ; attendu {expected} mais reçu {received}",
        "typeAssignmentMismatch": "Le type « {sourceType} » n’est pas assignable au type déclaré « {destType} »",
        "typeAssignmentMismatchWildcard": "Le symbole d’importation « {name} » a le type « {sourceType} », qui n’est pas assignable au type déclaré « {destType} »",
        "typeCallNotAllowed": "l'appel type() ne doit pas être utilisé dans une expression de type",
        "typeCheckOnly": "\"{name}\" est marqué comme @type_check_only et ne peut être utilisé que dans les annotations de type",
        "typeCommentDeprecated": "L’utilisation de commentaires de type est déconseillée ; utiliser l’annotation de type à la place",
        "typeExpectedClass": "Classe attendue mais « {type} » reçu",
        "typeFormArgs": "« TypeForm » accepte un seul argument positionnel",
        "typeGuardArgCount": "Argument de type unique attendu après « TypeGuard » ou « TypeIs »",
        "typeGuardParamCount": "Les méthodes et fonctions de protection de type définies par l’utilisateur doivent avoir au moins un paramètre d’entrée",
        "typeIsReturnType": "Le type de retour des TypeIs (« {returnType} ») n’est pas cohérent avec le type de paramètre de valeur (« {type} »)",
        "typeNotAwaitable": "« {type} » n’est pas awaitable",
        "typeNotIntantiable": "« {type} » ne peut pas être instancié",
        "typeNotIterable": "« {type} » n’est pas itérable",
        "typeNotSpecializable": "Impossible de spécialiser le type \"{type}\"",
        "typeNotSubscriptable": "L’objet de type « {type} » n’est pas sous-scriptible",
        "typeNotSupportBinaryOperator": "Opérateur \"{operator}\" non pris en charge pour les types \"{leftType}\" et \"{rightType}\"",
        "typeNotSupportBinaryOperatorBidirectional": "L'opérateur \"{operator}\" n'est pas pris en charge pour les types \"{leftType}\" et \"{rightType}\" lorsque le type attendu est \"{expectedType}\"",
        "typeNotSupportUnaryOperator": "L'opérateur \"{operator}\" n'est pas pris en charge pour le type \"{type}\"",
        "typeNotSupportUnaryOperatorBidirectional": "L’opérateur « {operator} » n’est pas pris en charge pour le type « {type} » quand le type attendu est « {expectedType} »",
        "typeNotUsableWith": "Object of type \"{type}\" cannot be used with \"with\" because it does not correctly implement {method}",
        "typeNotUsableWithAsync": "Object of type \"{type}\" cannot be used with \"async with\" because it does not correctly implement {method}",
        "typeParameterBoundNotAllowed": "La limite ou la contrainte ne peut pas être utilisée avec un paramètre de type variadique ou ParamSpec",
        "typeParameterConstraintTuple": "La contrainte de paramètre de type doit être un tuple de plusieurs types",
        "typeParameterExistingTypeParameter": "Le paramètre de type « {name} » est déjà utilisé",
        "typeParameterNotDeclared": "Le paramètre de type « {name} » n’est pas inclus dans la liste des paramètres de type pour « {container} »",
        "typeParametersMissing": "Au moins un paramètre de type doit être spécifié",
        "typePartiallyUnknown": "Le type de « {name} » est partiellement inconnu",
        "typeUnknown": "Le type de « {name} » est inconnu",
        "typeVarAssignedName": "TypeVar doit être affecté à une variable nommée « {name} »",
        "typeVarAssignmentMismatch": "Le type \"{type}\" ne peut pas être affecté à la variable de type \"{name}\"",
        "typeVarBoundAndConstrained": "TypeVar ne peut pas être à la fois lié et contraint",
        "typeVarBoundGeneric": "Le type lié TypeVar ne peut pas être générique",
        "typeVarConstraintGeneric": "Le type de contrainte TypeVar ne peut pas être générique",
        "typeVarDefaultBoundMismatch": "Le type par défaut TypeVar doit être un sous-type du type lié",
        "typeVarDefaultConstraintMismatch": "Le type par défaut TypeVar doit être l'un des types contraints",
        "typeVarDefaultIllegal": "Les types de variables de type par défaut nécessitent Python 3.13 ou une version plus récente",
        "typeVarDefaultInvalidTypeVar": "Le paramètre de type « {name} » a un type par défaut qui fait référence à une ou plusieurs variables de type hors de portée",
        "typeVarFirstArg": "Nom attendu de TypeVar comme premier argument",
        "typeVarInvalidForMemberVariable": "Le type d’attribut ne peut pas utiliser de variable de type « {name} » étendue à une méthode locale",
        "typeVarNoMember": "TypeVar « {type} » n’a aucun attribut « {name} »",
        "typeVarNotSubscriptable": "TypeVar « {type} » n’est pas subscriptible",
        "typeVarNotUsedByOuterScope": "La variable de type « {name} » n’a aucune signification dans ce contexte",
        "typeVarPossiblyUnsolvable": "La variable de type \"{name}\" peut rester non résolue si l'appelant ne fournit aucun argument pour le paramètre \"{param}\"",
        "typeVarSingleConstraint": "TypeVar doit avoir au moins deux types contraints",
        "typeVarTupleConstraints": "TypeVarTuple ne peut pas avoir de contraintes de valeur",
        "typeVarTupleContext": "TypeVarTuple n’est pas autorisé dans ce contexte",
        "typeVarTupleDefaultNotUnpacked": "Le type par défaut TypeVarTuple doit être un tuple décompressé ou TypeVarTuple",
        "typeVarTupleMustBeUnpacked": "L'opérateur Unpack est requis pour la valeur TypeVarTuple",
        "typeVarTupleUnknownParam": "« {name} » est un paramètre inconnu de TypeVarTuple",
        "typeVarUnknownParam": "\"{name}\" est un paramètre inconnu pour TypeVar",
        "typeVarUsedByOuterScope": "TypeVar \"{name}\" est déjà utilisé par une portée externe",
        "typeVarUsedOnlyOnce": "TypeVar « {name} » n’apparaît qu’une seule fois dans la signature de fonction générique",
        "typeVarVariance": "TypeVar ne peut pas être à la fois covariant et contravariant",
        "typeVarWithDefaultFollowsVariadic": "TypeVar « {typeVarName} » a une valeur par défaut et ne peut pas suivre TypeVarTuple « {variadicName} »",
        "typeVarWithoutDefault": "\"{name}\" ne peut pas apparaître après \"{other}\" dans la liste des paramètres de type car il n'a pas de type par défaut",
        "typeVarsNotInGenericOrProtocol": "Generic[] ou Protocol[] doit inclure toutes les variables de type",
        "typedDictAccess": "Impossible d’accéder à l’élément dans TypedDict",
        "typedDictAssignedName": "TypedDict doit être affecté à une variable nommée « {name} »",
        "typedDictBadVar": "Les classes TypedDict ne peuvent contenir que des annotations de type",
        "typedDictBaseClass": "Toutes les classes de base pour les classes TypedDict doivent également être des classes TypedDict",
        "typedDictBoolParam": "Paramètre « {name} » attendu avec la valeur True ou False",
        "typedDictClosedExtras": "La classe de base « {name} » est un TypedDict closed, les éléments supplémentaires doivent être de type « {type} »",
        "typedDictClosedNoExtras": "La classe de base « {name} » est un TypedDict closed, les éléments supplémentaires ne sont pas autorisés",
        "typedDictDelete": "Impossible de supprimer l’élément dans TypedDict",
        "typedDictEmptyName": "Les noms dans un TypedDict ne peuvent pas être vides",
        "typedDictEntryName": "Littéral de chaîne attendu pour le nom d’entrée du dictionnaire",
        "typedDictEntryUnique": "Les noms dans un dictionnaire doivent être uniques",
        "typedDictExtraArgs": "Arguments TypedDict supplémentaires non pris en charge",
        "typedDictExtraItemsClosed": "Un TypedDict ne peut pas être closed s’il prend en charge les éléments supplémentaires",
        "typedDictFieldNotRequiredRedefinition": "L’élément TypedDict « {name} » ne peut pas être redéfini comme étant NotRequired",
        "typedDictFieldReadOnlyRedefinition": "L’élément TypedDict « {name} » ne peut pas être redéfini comme état En ReadOnly",
        "typedDictFieldRequiredRedefinition": "L’élément TypedDict « {name} » ne peut pas être redéfini comme étant Required",
        "typedDictFirstArg": "Nom de classe TypedDict attendu comme premier argument",
        "typedDictInClassPattern": "La classe TypedDict n'est pas autorisée dans le modèle de classe",
        "typedDictInitsubclassParameter": "TypedDict ne prend pas en charge __init_subclass__ paramètre « {name} »",
        "typedDictNotAllowed": "\"TypedDict\" ne peut pas être utilisé dans ce contexte",
        "typedDictSecondArgDict": "Paramètre de mot clé ou de dict attendu en tant que deuxième paramètre",
        "typedDictSecondArgDictEntry": "Entrée de dictionnaire simple attendue",
        "typedDictSet": "Impossible d'attribuer l'élément dans TypedDict",
        "unaccessedClass": "La classe \"{name}\" n'est pas accessible",
        "unaccessedFunction": "La fonction « {name} » n’est pas accessible",
        "unaccessedImport": "L’importation « {name} » n’est pas accessible",
        "unaccessedSymbol": "« {name} » n’est pas utilisé(e)",
        "unaccessedVariable": "La variable « {name} » n’est pas accessible",
        "unannotatedFunctionSkipped": "L'analyse de la fonction \"{name}\" est ignorée car elle n'est pas annotée",
        "unaryOperationNotAllowed": "L'opérateur unaire n'est pas autorisé dans l'expression de type",
        "unexpectedAsyncToken": "« def », « with » ou « for » attendu pour suivre « async »",
        "unexpectedExprToken": "Jeton inattendu à la fin de l’expression",
        "unexpectedIndent": "Retrait inattendu",
        "unexpectedUnindent": "Unindent non attendu",
        "unhashableDictKey": "La clé du dictionnaire doit être hachable",
        "unhashableSetEntry": "L’entrée set doit être hachable",
        "uninitializedAbstractVariables": "Les variables définies dans la classe de base abstraite ne sont pas initialisées dans la classe finale « {classType} »",
        "uninitializedInstanceVariable": "La variable d’instance « {name} » n’est pas initialisée dans le corps de la classe ou dans la méthode __init__",
        "unionForwardReferenceNotAllowed": "La syntaxe Union ne peut pas être utilisée avec l’opérande de chaîne ; utiliser des guillemets autour de l’expression entière",
        "unionSyntaxIllegal": "Une autre syntaxe pour les unions nécessite Python 3.10 ou une version plus récente",
        "unionTypeArgCount": "L’Union requiert au moins deux arguments de type",
        "unionUnpackedTuple": "Union ne peut pas inclure un tuple décompressé",
        "unionUnpackedTypeVarTuple": "Union ne peut pas inclure un TypeVarTuple décompressé",
        "unnecessaryCast": "Appel \"cast\" inutile ; le type est déjà \"{type}\"",
        "unnecessaryIsInstanceAlways": "Appel d’isinstance inutile ; « {testType} » est toujours une instance de « {classType} »",
        "unnecessaryIsInstanceNever": "Appel d’isinstance inutile; « {testType} » n est jamais une instance de « {classType} »",
        "unnecessaryIsSubclassAlways": "Appel issubclass inutile ; \"{testType}\" est toujours une sous-classe de \"{classType}\"",
        "unnecessaryIsSubclassNever": "Appel issubclass inutile; « {testType} » est toujours une sous-classe de « {classType} »",
        "unnecessaryPyrightIgnore": "Commentaire \"# pyright: ignore\" inutile",
        "unnecessaryPyrightIgnoreRule": "Règle inutile « # pyright: ignore » : « {name} »",
        "unnecessaryTypeIgnore": "Commentaire \"# type: ignore\" inutile",
        "unpackArgCount": "Attendu un seul argument de type après \"Unpack\"",
        "unpackExpectedTypeVarTuple": "TypeVarTuple ou tuple attendu en tant qu’argument de type pour Unpack",
        "unpackExpectedTypedDict": "Argument de type TypedDict attendu pour Unpack",
        "unpackIllegalInComprehension": "Opération de décompression non autorisée dans la compréhension",
        "unpackInAnnotation": "L'opérateur de déballage n'est pas autorisé dans l'expression de type",
        "unpackInDict": "Opération de décompression non autorisée dans les dictionnaires",
        "unpackInSet": "Opérateur de déballage non autorisé dans un set",
        "unpackNotAllowed": "Le Unpack n’est pas autorisé dans ce contexte",
        "unpackOperatorNotAllowed": "L’opération de décompression n’est pas autorisée dans ce contexte",
        "unpackTuplesIllegal": "Opération de décompression non autorisée dans les tuples avant Python 3.8",
        "unpackedArgInTypeArgument": "Les arguments décompressés ne peuvent pas être utilisés dans ce contexte",
        "unpackedArgWithVariadicParam": "L'argument décompressé ne peut pas être utilisé pour le paramètre TypeVarTuple",
        "unpackedDictArgumentNotMapping": "L’expression d’argument après ** doit être un mappage avec un type de clé « str »",
        "unpackedDictSubscriptIllegal": "L’opérateur de décompression de dictionnaire dans l’indice n’est pas autorisé",
        "unpackedSubscriptIllegal": "L’opérateur de décompression en indice requiert Python 3.11 ou version ultérieure",
        "unpackedTypeVarTupleExpected": "TypeVarTuple décompressé attendu ; utiliser Unpack[{name1}] ou *{name2}",
        "unpackedTypedDictArgument": "Impossible de faire correspondre l’argument TypedDict décompressé aux paramètres",
        "unreachableCode": "Le code est inaccessible",
        "unreachableCodeType": "L’analyse de type indique que le code est inaccessible",
        "unreachableExcept": "La clause Except est inaccessible, car l’exception est déjà gérée",
        "unsupportedDunderAllOperation": "L’opération sur « __all__ » n’est pas prise en charge. Par conséquent, la liste de symboles exportée peut être incorrecte",
        "unusedCallResult": "Le résultat de l'expression d'appel est de type \"{type}\" et n'est pas utilisé ; affecter à la variable \"_\" si c'est intentionnel",
        "unusedCoroutine": "Le résultat de l’appel de fonction asynchrone n’est pas utilisé ; utiliser « await » ou affecter le résultat à la variable",
        "unusedExpression": "La valeur de l'expression n'est pas utilisée",
        "varAnnotationIllegal": "Les annotations de type pour les variables nécessitent Python 3.6 ou une version ultérieure ; utiliser le commentaire de type pour la compatibilité avec les versions précédentes",
        "variableFinalOverride": "La variable « {name} » est marquée comme Final et remplace la variable non-Final du même nom dans la classe « {className} »",
        "variadicTypeArgsTooMany": "La liste d’arguments de type peut avoir au plus un TypeVarTuple ou tuple décompressé",
        "variadicTypeParamTooManyAlias": "L’alias de type peut avoir au plus un paramètre de type TypeVarTuple, mais a reçu plusieurs ({names})",
        "variadicTypeParamTooManyClass": "La classe générique peut avoir au plus un paramètre de type TypeVarTuple, mais en a reçu plusieurs ({names})",
        "walrusIllegal": "L’opérateur « := » nécessite Python 3.8 ou version ultérieure",
        "walrusNotAllowed": "L’opérateur « := » n’est pas autorisé dans ce contexte sans parenthèses adjacentes",
        "wildcardInFunction": "import de caractères génériques non autorisée dans une classe ou une fonction",
        "wildcardLibraryImport": "import de caractères génériques à partir d’une bibliothèque non autorisée",
        "wildcardPatternTypePartiallyUnknown": "Le type capturé par le modèle générique est partiellement inconnu",
        "wildcardPatternTypeUnknown": "Le type capturé par le modèle générique est inconnu",
        "yieldFromIllegal": "L’utilisation de « yield from » nécessite Python 3.3 ou version ultérieure",
        "yieldFromOutsideAsync": "« yield from » non autorisé dans une fonction asynchrone",
        "yieldOutsideFunction": "« yield » non autorisé en dehors d’une fonction ou d’un lambda",
        "yieldWithinComprehension": "« yield » n’est pas autorisé dans une compréhension de liste",
        "zeroCaseStatementsFound": "L’instruction de Match doit inclure au moins une instruction case",
        "zeroLengthTupleNotAllowed": "Le tuple de longueur nulle n’est pas autorisé dans ce contexte"
    },
    "DiagnosticAddendum": {
        "annotatedNotAllowed": "Impossible d’utiliser le formulaire spécial « Annotated » avec les vérifications d’instance et de classe",
        "argParam": "L’argument correspond au paramètre « {paramName} »",
        "argParamFunction": "L’argument correspond au paramètre « {paramName} » dans la fonction « {functionName} »",
        "argsParamMissing": "Le paramètre \"*{paramName}\" n'a pas de paramètre correspondant",
        "argsPositionOnly": "Non-concordance des paramètres de position uniquement ; attendu {expected} mais reçu {received}",
        "argumentType": "Le type d’argument est « {type} »",
        "argumentTypes": "Types d'argument : ({types})",
        "assignToNone": "Le type n’est pas assignable à « None »",
        "asyncHelp": "Vouliez-vous dire « async with » ?",
        "baseClassIncompatible": "La classe de base « {baseClass} » n’est pas compatible avec le type « {type} »",
        "baseClassIncompatibleSubclass": "La classe de base « {baseClass} » dérive de « {subclass} » qui est incompatible avec le type « {type} »",
        "baseClassOverriddenType": "La classe de base « {baseClass} » fournit le type « {type} », qui est remplacé",
        "baseClassOverridesType": "La classe de base \"{baseClass}\" remplace le type \"{type}\"",
        "bytesTypePromotions": "Définir disableBytesTypePromotions sur false pour activer le comportement de promotion de type pour « bytearray » et « memoryview »",
        "conditionalRequiresBool": "La méthode __bool__ pour le type « {operandType} » retourne le type « {boolReturnType} » plutôt que « bool »",
        "dataClassFieldLocation": "Déclaration de champ",
        "dataClassFrozen": "« {name} » est figé",
        "dataProtocolUnsupported": "« {name} » est un protocole de données",
        "descriptorAccessBindingFailed": "Échec de la liaison du « {name} » de méthode pour la classe de descripteur « {className} »",
        "descriptorAccessCallFailed": "Échec de l’appel du « {name} » de méthode pour la classe de descripteur « {className} »",
        "finalMethod": "Méthode Final",
        "functionParamDefaultMissing": "Le paramètre \"{name}\" n'a pas d'argument par défaut",
        "functionParamName": "Incompatibilité de nom de paramètre : « {destName} » et « {srcName} »",
        "functionParamPositionOnly": "Non-correspondance des paramètres position uniquement ; le paramètre « {name} » n’est pas en position seule",
        "functionReturnTypeMismatch": "Le type de retour de fonction \"{sourceType}\" est incompatible avec le type \"{destType}\"",
        "functionTooFewParams": "La fonction accepte trop peu de paramètres positionnels ; {expected} attendu, mais {received} reçu",
        "functionTooManyParams": "La fonction accepte trop de paramètres positionnels ; {expected} attendu, mais {received} reçu",
        "genericClassNotAllowed": "Type générique avec des arguments de type non autorisé pour les vérifications d’instance ou de classe",
        "incompatibleDeleter": "La méthode du deleter de property n’est pas compatible",
        "incompatibleGetter": "La méthode de getter de property est incompatible",
        "incompatibleSetter": "La méthode setter de property n’est pas compatible",
        "initMethodLocation": "La méthode __init__ est définie dans la classe « {type} »",
        "initMethodSignature": "La signature de __init__ est « {type} »",
        "initSubclassLocation": "La méthode __init_subclass__ est définie dans la classe « {name} »",
        "invariantSuggestionDict": "Envisagez de passer de « dict » à « Mapping », qui est covariant dans le type valeur",
        "invariantSuggestionList": "Envisagez de passer de « list » à « Sequence » qui est covariant",
        "invariantSuggestionSet": "Pensez à passer de \"set\" à \"Container\" qui est covariant",
        "isinstanceClassNotSupported": "« {type} » n’est pas pris en charge pour les vérifications d’instance et de classe",
        "keyNotRequired": "\"{name}\" n'est pas une clé requise dans \"{type}\", donc l'accès peut entraîner une exception d'exécution",
        "keyReadOnly": "« {name} » est une clé en lecture seule dans « {type} »",
        "keyRequiredDeleted": "« {name} » est une clé obligatoire et ne peut pas être supprimée",
        "keyUndefined": "« {name} » n’est pas une clé définie dans « {type} »",
        "kwargsParamMissing": "Le paramètre \"**{paramName}\" n'a pas de paramètre correspondant",
        "listAssignmentMismatch": "Le type « {type} » n’est pas compatible avec la liste cible",
        "literalAssignmentMismatch": "« {sourceType} » n’est pas assignable au type « {destType} »",
        "matchIsNotExhaustiveHint": "Si la gestion exhaustive n’est pas prévue, ajoutez « case _: pass »",
        "matchIsNotExhaustiveType": "Type non géré : « {type} »",
        "memberAssignment": "L'expression de type « {type} » ne peut pas être attribuée à l’attribut « {name} » de la classe « {classType} »",
        "memberIsAbstract": "« {type}.{name} » n’est pas implémenté",
        "memberIsAbstractMore": "et {count} autres...",
        "memberIsClassVarInProtocol": "« {name} » est défini en tant que ClassVar dans le protocole",
        "memberIsInitVar": "« {name} » est un champ init-only",
        "memberIsInvariant": "« {name} » est invariant, car il est mutable",
        "memberIsNotClassVarInClass": "« {name} » doit être défini en tant que ClassVar pour être compatible avec le protocole",
        "memberIsNotClassVarInProtocol": "« {name} » n’est pas défini en tant que ClassVar dans le protocole",
        "memberIsNotReadOnlyInProtocol": "« {name} » n’est pas en lecture seule dans le protocole",
        "memberIsReadOnlyInProtocol": "« {name} » est en lecture seule dans le protocole",
        "memberIsWritableInProtocol": "« {name} » est accessible en écriture dans le protocole",
        "memberSetClassVar": "L’attribut « {name} » ne peut pas être attribué via une instance de classe car il s’agit d’une ClassVar",
        "memberTypeMismatch": "« {name} » est un type incompatible",
        "memberUnknown": "L’attribut « {name} » est inconnu",
        "metaclassConflict": "La métaclasse « {metaclass1} » est en conflit avec « {metaclass2} »",
        "missingDeleter": "La méthode de deleter de property est manquante",
        "missingGetter": "La méthode getter de property est manquante",
        "missingSetter": "setter de définition de property est manquante",
        "namedParamMissingInDest": "Paramètre supplémentaire « {name} »",
        "namedParamMissingInSource": "Paramètre de mot clé manquant « {name} »",
        "namedParamTypeMismatch": "Le paramètre de mot clé « {name} » de type « {sourceType} » est incompatible avec le type « {destType} »",
        "namedTupleNotAllowed": "NamedTuple ne peut pas être utilisé pour les vérifications d’instance ou de classe",
        "newMethodLocation": "La méthode __new__ est définie dans la classe « {type} »",
        "newMethodSignature": "La signature de __new__ est « {type} »",
        "newTypeClassNotAllowed": "La classe créée avec NewType ne peut pas être utilisée avec des vérifications de instance et de classe",
        "noOverloadAssignable": "Aucune fonction surchargée ne correspond au type « {type} »",
        "noneNotAllowed": "None ne peut être utilisé pour les vérifications de instance ou de classe",
        "orPatternMissingName": "Noms manquants : {name}",
        "overloadIndex": "La surcharge {index} est la correspondance la plus proche",
        "overloadNotAssignable": "Une ou plusieurs surcharges de « {name} » ne sont pas assignables",
        "overloadSignature": "La signature de surcharge est définie ici",
        "overriddenMethod": "Méthode substituée",
        "overriddenSymbol": "Symbole substitué",
        "overrideInvariantMismatch": "Le type de remplacement \"{overrideType}\" n'est pas le même que le type de base \"{baseType}\"",
        "overrideIsInvariant": "La variable est mutable donc son type est invariant",
        "overrideNoOverloadMatches": "Aucune signature de surcharge dans le remplacement n’est compatible avec la méthode de base",
        "overrideNotClassMethod": "La méthode de base est déclarée en tant que classmethod, mais la substitution n’est pas",
        "overrideNotInstanceMethod": "La méthode de base est déclarée en tant que méthode d'instance mais la substitution n'est pas",
        "overrideNotStaticMethod": "La méthode de base est déclarée comme staticmethod, mais la substitution n’est pas",
        "overrideOverloadNoMatch": "Le remplacement ne gère pas toutes les surcharges de la méthode de base",
        "overrideOverloadOrder": "Les surcharges pour la méthode de remplacement doivent être dans le même ordre que la méthode de base",
        "overrideParamKeywordNoDefault": "Non-concordance du paramètre de mot-clé \"{name}\" : le paramètre de base a une valeur d'argument par défaut, le paramètre de remplacement n'en a pas",
        "overrideParamKeywordType": "Incompatibilité de type du paramètre de mot clé \"{name}\" : le paramètre de base est de type \"{baseType}\", le paramètre de remplacement est de type \"{overrideType}\"",
        "overrideParamName": "Incompatibilité de nom de paramètre {index} : le paramètre de base est nommé \"{baseName}\", le paramètre de remplacement est nommé \"{overrideName}\"",
        "overrideParamNameExtra": "Le paramètre « {name} » est manquant dans la base",
        "overrideParamNameMissing": "Le paramètre \"{name}\" est manquant dans le remplacement",
        "overrideParamNamePositionOnly": "Incompatibilité du paramètre {index} : le paramètre de base \"{baseName}\" est un paramètre de mot-clé, le paramètre de remplacement est uniquement de position",
        "overrideParamNoDefault": "Non-concordance du paramètre {index} : le paramètre de base a une valeur d'argument par défaut, le paramètre de remplacement n'en a pas",
        "overrideParamType": "Incompatibilité de type de paramètre {index} : le paramètre de base est de type \"{baseType}\", le paramètre de remplacement est de type \"{overrideType}\"",
        "overridePositionalParamCount": "Non-concordance du nombre de paramètres positionnels ; la méthode de base a {baseCount}, mais la substitution a {overrideCount}",
        "overrideReturnType": "Incompatibilité de type de retour : la méthode de base retourne le type « {baseType} », la substitution retourne le type « {overrideType} »",
        "overrideType": "La classe de base définit le type comme « {type} »",
        "paramAssignment": "Paramètre {index} : le type « {sourceType} » est incompatible avec le type « {destType} »",
        "paramSpecMissingInOverride": "Les paramètres ParamSpec sont manquants dans la méthode de remplacement",
        "paramType": "Le type de paramètre est « {paramType} »",
        "privateImportFromPyTypedSource": "Importer à partir de « {module} » à la place",
        "propertyAccessFromProtocolClass": "Une propriété définie dans une classe de protocole n'est pas accessible en tant que variable de classe",
        "propertyMethodIncompatible": "La méthode de property « {name} » n’est pas compatible",
        "propertyMethodMissing": "La méthode de property « {name} » est manquante dans le remplacement",
        "propertyMissingDeleter": "La property « {name} » n’a pas de deleter défini",
        "propertyMissingSetter": "La property « {name} » n’a pas de méthode setter définie",
        "protocolIncompatible": "\"{sourceType}\" est incompatible avec le protocole \"{destType}\"",
        "protocolMemberMissing": "« {name} » n’est pas présent",
        "protocolRequiresRuntimeCheckable": "La classe de Protocol doit être @runtime_checkable à utiliser avec des vérifications d’instance et de classe",
        "protocolSourceIsNotConcrete": "\"{sourceType}\" n'est pas un type de classe concret et ne peut pas être affecté au type \"{destType}\"",
        "protocolUnsafeOverlap": "Les attributs de « {name} » ont les mêmes noms que le protocole",
        "pyrightCommentIgnoreTip": "Utilisez « # pyright: ignore[<diagnostic rules>] » pour supprimer les diagnostics pour une seule ligne",
        "readOnlyAttribute": "L’attribut « {name} » est en lecture seule",
        "seeClassDeclaration": "Voir la déclaration de classe",
        "seeDeclaration": "Voir la déclaration",
        "seeFunctionDeclaration": "Voir la déclaration de fonction",
        "seeMethodDeclaration": "Voir la déclaration de méthode",
        "seeParameterDeclaration": "Voir la déclaration des paramètres",
        "seeTypeAliasDeclaration": "Voir la déclaration d’alias de type",
        "seeVariableDeclaration": "Voir déclaration de variable",
        "tupleAssignmentMismatch": "Le type \"{type}\" est incompatible avec le tuple cible",
        "tupleEntryTypeMismatch": "Le type de l’entrée de tuple {entry} est incorrect",
        "tupleSizeIndeterminateSrc": "Incompatibilité de taille de tuple ; attendu {expected} mais reçu pour une durée indéterminée",
        "tupleSizeIndeterminateSrcDest": "Incompatibilité de taille de tuple : attente de {expected} ou plus, mais réception indéterminée",
        "tupleSizeMismatch": "Incompatibilité de taille de tuple ; attendu {expected} mais reçu {received}",
        "tupleSizeMismatchIndeterminateDest": "Incompatibilité de taille de tuple : attente de {expected} ou plus, mais réception de {received}",
        "typeAliasInstanceCheck": "L’alias de type créé avec l’instruction « type » ne peut pas être utilisé avec des vérifications d’instance et de classe",
        "typeAssignmentMismatch": "Le type « {sourceType} » n’est pas assignable au type « {destType} »",
        "typeBound": "Le type « {sourceType} » n’est pas assignable à la limite supérieure « {destType} » pour la variable de type « {name} »",
        "typeConstrainedTypeVar": "Le type « {type} » n’est pas assignable à la variable de type contrainte « {name} »",
        "typeIncompatible": "« {sourceType} » n’est pas assignable à « {destType} »",
        "typeNotClass": "« {type} » n’est pas une classe",
        "typeNotStringLiteral": "\"{type}\" n'est pas un littéral de chaîne",
        "typeOfSymbol": "Le type de \"{name}\" est \"{type}\"",
        "typeParamSpec": "Le type « {type} » n’est pas compatible avec ParamSpec « {name} »",
        "typeUnsupported": "Le type « {type} » n’est pas pris en charge",
        "typeVarDefaultOutOfScope": "La variable de type « {name} » n’est pas dans l’étendue",
        "typeVarIsContravariant": "Le paramètre de type \"{name}\" est contravariant, mais \"{sourceType}\" n'est pas un supertype de \"{destType}\"",
        "typeVarIsCovariant": "Le paramètre de type \"{name}\" est covariant, mais \"{sourceType}\" n'est pas un sous-type de \"{destType}\"",
        "typeVarIsInvariant": "Le paramètre de type \"{name}\" est invariant, mais \"{sourceType}\" n'est pas le même que \"{destType}\"",
        "typeVarNotAllowed": "TypeVar non autorisé pour les vérifications d’instance ou de classe",
        "typeVarTupleRequiresKnownLength": "TypeVarTuple ne peut pas être lié à un tuple de longueur inconnue",
        "typeVarUnnecessarySuggestion": "Utilisez plutôt {type}",
        "typeVarUnsolvableRemedy": "Fournir une surcharge qui spécifie le type de retour lorsque l’argument n’est pas fourni",
        "typeVarsMissing": "Variables de type manquantes : {names}",
        "typedDictBaseClass": "La classe \"{type}\" n'est pas un TypedDict",
        "typedDictClassNotAllowed": "Classe TypedDict non autorisée pour les vérifications d’instance ou de classe",
        "typedDictClosedExtraNotAllowed": "Impossible d’ajouter l’élément « {name} »",
        "typedDictClosedExtraTypeMismatch": "Impossible d’ajouter l’élément « {name} » avec le type « {type} »",
        "typedDictClosedFieldNotRequired": "Impossible d’ajouter l’élément « {name} », car il doit être NotRequired",
        "typedDictExtraFieldNotAllowed": "« {name} » n’est pas présent dans « {type} »",
        "typedDictExtraFieldTypeMismatch": "Le type de « {name} » est incompatible avec le type « extra_items » dans « {type} »",
        "typedDictFieldMissing": "« {name} » est manquant dans « {type} »",
        "typedDictFieldNotReadOnly": "« {name} » n’est pas en lecture seule dans « {type} »",
        "typedDictFieldNotRequired": "« {name} » n’est pas obligatoire dans « {type} »",
        "typedDictFieldRequired": "« {name} » est obligatoire dans « {type} »",
        "typedDictFieldTypeMismatch": "Le type « {type} » n'est pas attribuable à l’élément « {name} »",
        "typedDictFieldUndefined": "« {name} » est un élément non défini dans le type « {type} »",
        "typedDictFinalMismatch": "« {sourceType} » n’est pas compatible avec « {destType} » en raison d’une incompatibilité de @final",
        "typedDictKeyAccess": "Utilisez [« {name} »] pour référencer l’élément dans TypedDict",
        "typedDictNotAllowed": "TypedDict ne peut pas être utilisé pour les vérifications d’instance ou de classe",
        "unhashableType": "Le type \"{type}\" n'est pas hachable",
        "uninitializedAbstractVariable": "La variable d’instance « {name} » est définie dans la classe de base abstraite « {classType} » mais n’est pas initialisée",
        "unreachableExcept": "« {exceptionType} » est une sous-classe de « {parentType} »",
        "useDictInstead": "Utilisez dict[T1, T2] pour indiquer un type de dictionnaire",
        "useListInstead": "Utiliser list[T] pour indiquer un type de liste ou T1 | T2 pour indiquer un type d’union",
        "useTupleInstead": "Utiliser tuple[T1, ..., Tn] pour indiquer un type de tuple ou T1 | T2 pour indiquer un type d’union",
        "useTypeInstead": "Utiliser type[T] à la place",
        "varianceMismatchForClass": "La variance de l'argument de type \"{typeVarName}\" est incompatible avec la classe de base \"{className}\"",
        "varianceMismatchForTypeAlias": "La variance de l'argument de type \"{typeVarName}\" est incompatible avec \"{typeAliasParam}\""
    },
    "Service": {
        "longOperation": "L’énumération des fichiers sources de l’espace de travail prend beaucoup de temps. Envisagez plutôt d’ouvrir un sous-dossier. [En savoir plus](https://aka.ms/workspace-too-many-files)"
    }
}
