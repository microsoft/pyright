{
    "CodeAction": {
        "createTypeStub": "형식 스텁 만들기",
        "createTypeStubFor": "\"{moduleName}\"에 대한 형식 스텁 만들기",
        "executingCommand": "명령 실행",
        "filesToAnalyzeCount": "분석할 파일 {count}개",
        "filesToAnalyzeOne": "분석할 파일 1개",
        "findingReferences": "참조 찾기",
        "organizeImports": "가져오기 구성",
        "renameShadowedFile": "‘{oldFile}’에서 ‘{newFile}’(으)로 이름 바꾸기"
    },
    "Completion": {
        "autoImportDetail": "자동 가져오기",
        "indexValueDetail": "인덱스 값"
    },
    "Diagnostic": {
        "abstractMethodInvocation": "메서드 \"{method}\"은(는) 추상적이고 구현되지 않았으므로 호출할 수 없습니다.",
        "annotatedParamCountMismatch": "매개 변수 주석 개수가 일치하지 않습니다. {expected}이)(가) 필요하지만 {received}을(를) 받았습니다.",
        "annotatedTypeArgMissing": "\"Annotated\"에 대해 하나의 형식 인수와 하나 이상의 주석이 필요합니다.",
        "annotationFormatString": "형식 주석은 형식 문자열 리터럴(f-문자열)을 사용할 수 없습니다.",
        "annotationNotSupported": "이 문에는 형식 주석이 지원되지 않습니다.",
        "annotationSpansStrings": "형식 주석은 여러 문자열 리터럴에 걸쳐 있을 수 없습니다.",
        "annotationStringEscape": "형식 주석에는 이스케이프 문자를 사용할 수 없습니다.",
        "argAssignment": "\"{argType}\" 형식의 인수를 \"{paramType}\" 형식의 매개 변수에 할당할 수 없습니다.",
        "argAssignmentFunction": "\"{argType}\" 형식의 인수를 \"{functionName}\" 함수의 \"{paramType}\" 형식의 매개 변수에 할당할 수 없습니다.",
        "argAssignmentParam": "\"{argType}\" 형식의 인수를 \"{paramType}\" 형식의 \"{paramName}\" 매개 변수에 할당할 수 없습니다.",
        "argAssignmentParamFunction": "\"{argType}\" 형식의 인수를 \"{functionName}\" 함수에서 \"{paramType}\" 형식의 \"{paramName}\" 매개 변수에 할당할 수 없습니다.",
        "argMissingForParam": "매개 변수 {name}에 대한 인수가 없습니다.",
        "argMissingForParams": "매개 변수 {names}에 대한 인수가 없습니다.",
        "argMorePositionalExpectedCount": "{expected}개 이상의 위치 인수가 필요합니다.",
        "argMorePositionalExpectedOne": "1개의 위치 인수가 더 필요합니다.",
        "argPositional": "위치 인수가 필요합니다.",
        "argPositionalExpectedCount": "{expected} 위치 인수가 필요합니다.",
        "argPositionalExpectedOne": "1개의 위치 인수가 필요합니다.",
        "argTypePartiallyUnknown": "인수 형식을 부분적으로 알 수 없습니다.",
        "argTypeUnknown": "인수 형식을 알 수 없습니다.",
        "assertAlwaysTrue": "어설션 식은 항상 true로 평가됩니다.",
        "assertTypeArgs": "\"assert_type\"에는 두 개의 위치 인수가 필요합니다.",
        "assertTypeTypeMismatch": "\"assert_type\" 불일치: \"{expected}\"이(가) 필요하지만 \"{received}\"을(를) 받았습니다.",
        "assignmentExprComprehension": "‘{name}’ 할당 식 대상은 대상에 대한 이해력과 같은 이름을 사용할 수 없습니다.",
        "assignmentExprContext": "할당 식은 모듈, 함수 또는 람다 내에 있어야 합니다.",
        "assignmentExprInSubscript": "아래 첨자 내의 할당 식은 Python 3.10 이상에서만 지원됩니다.",
        "assignmentInProtocol": "Protocol 클래스 내의 인스턴스 또는 클래스 변수는 클래스 본문 내에서 명시적으로 선언해야 합니다.",
        "assignmentTargetExpr": "식은 할당 대상이 될 수 없습니다.",
        "asyncNotInAsyncFunction": "비동기 함수 외부에서는 ‘async’가 허용되지 않습니다.",
        "awaitIllegal": "\"await\"를 사용하려면 Python 3.5 이상이 필요합니다.",
        "awaitNotAllowed": "형식 주석은 \"await\"를 사용할 수 없습니다.",
        "awaitNotInAsync": "비동기 함수 내에서만 \"await\"를 사용할 수 있습니다.",
        "backticksIllegal": "백틱으로 묶인 식은 Python 3.x에서 지원되지 않습니다. 대신 repr 사용",
        "baseClassCircular": "클래스는 스스로에서 파생될 수 없습니다.",
        "baseClassFinal": "기본 클래스 \"{type}\"이(가) final로 표시되어 서브클래스할 수 없습니다.",
        "baseClassIncompatible": "{type}의 기본 클래스는 상호 호환되지 않습니다.",
        "baseClassInvalid": "클래스에 대한 인수는 기본 클래스여야 합니다.",
        "baseClassMethodTypeIncompatible": "\"{classType}\" 클래스의 기본 클래스가 호환되지 않는 방식으로 \"{name}\" 메서드를 정의합니다.",
        "baseClassUnknown": "기본 클래스 형식을 알 수 없으므로 파생 클래스의 형식이 모호합니다.",
        "baseClassVariableTypeIncompatible": "\"{classType}\" 클래스의 기본 클래스가 \"{name}\" 변수를 호환되지 않는 방식으로 정의합니다.",
        "binaryOperationNotAllowed": "형식 주석에는 이항 연산자를 사용할 수 없습니다.",
        "bindTypeMismatch": "‘{type}’을(를) 매개 변수 ‘{paramName}’에 할당할 수 없으므로 ‘{methodName}’ 메서드를 바인딩할 수 없습니다.",
        "breakOutsideLoop": "‘break’는 루프 내에서만 사용할 수 있습니다.",
        "callableExtraArgs": "\"Callable\"에 두 개의 형식 인수만 필요합니다.",
        "callableFirstArg": "매개 변수 형식 목록 또는 \"...\"가 필요합니다.",
        "callableNotInstantiable": "\"{type}\" 형식을 인스턴스화할 수 없습니다.",
        "callableSecondArg": "반환 형식이 \"Callable\"에 대한 두 번째 형식 인수로 필요합니다.",
        "casePatternIsIrrefutable": "되돌릴 수 없는 패턴은 마지막 case 문에만 사용할 수 있습니다.",
        "classAlreadySpecialized": "\"{type}\" 형식이 이미 특수화되어 있습니다.",
        "classDecoratorTypeUnknown": "형식화되지 않은 클래스 데코레이터는 클래스 형식을 모호하게 합니다. 데코레이터를 무시합니다.",
        "classDefinitionCycle": "‘{name}’에 대한 클래스 정의가 스스로에 종속됩니다.",
        "classGetItemClsParam": "__class_getitem__ 재정의는 \"cls\" 매개 변수를 사용해야 합니다.",
        "classMethodClsParam": "클래스 메서드는 ‘cls’ 매개 변수를 사용해야 합니다.",
        "classNotRuntimeSubscriptable": "클래스 \"{name}\"에 대한 첨자는 런타임 예외를 생성합니다. 따옴표로 형식 주석 묶기",
        "classPatternBuiltInArgPositional": "클래스 패턴은 위치 하위 패턴만 허용합니다.",
        "classPatternPositionalArgCount": "클래스 \"{type}\"에 대한 위치 패턴이 너무 많습니다. {expected}이(가) 필요하지만 {received}을(를) 받았습니다.",
        "classPatternTypeAlias": "‘{type}’은(는) 특수 형식 별칭이므로 클래스 패턴에서 사용할 수 없습니다.",
        "classPropertyDeprecated": "클래스 속성은 Python 3.11에서 더 이상 사용되지 않으며 Python 3.13에서 지원되지 않습니다.",
        "classTypeParametersIllegal": "클래스 형식 매개 변수 구문에는 Python 3.12 이상이 필요합니다.",
        "classVarFirstArgMissing": "‘ClassVar’ 뒤에 형식 인수가 필요합니다.",
        "classVarNotAllowed": "이 컨텍스트에서는 \"ClassVar\"를 사용할 수 없습니다.",
        "classVarOverridesInstanceVar": "클래스 변수 \"{name}\"이(가) \"{className}\" 클래스에서 같은 이름의 인스턴스 변수를 재정의합니다.",
        "classVarTooManyArgs": "‘ClassVar’ 뒤에는 형식 인수가 하나만 필요합니다.",
        "classVarWithTypeVar": "‘ClassVar’ 형식에는 형식 변수를 포함할 수 없습니다.",
        "clsSelfParamTypeMismatch": "‘{name}’ 매개 변수의 형식은 해당 ‘{classType}’ 클래스의 상위 형식이어야 합니다.",
        "codeTooComplexToAnalyze": "코드가 너무 복잡하여 분석할 수 없습니다. 하위 경로로 리팩터링하거나 조건부 코드 경로를 줄여 복잡성 감소",
        "collectionAliasInstantiation": "‘{type}’ 형식을 인스턴스화할 수 없습니다. 대신 ‘{alias}’을(를) 사용하세요.",
        "comparisonAlwaysFalse": "\"{leftType}\" 및 \"{rightType}\" 형식이 겹치지 않으므로 조건은 항상 False로 평가됩니다.",
        "comparisonAlwaysTrue": "\"{leftType}\" 및 \"{rightType}\" 형식이 겹치지 않으므로 조건은 항상 True로 평가됩니다.",
        "comprehensionInDict": "이해력은 다른 사전 항목과 함께 사용할 수 없습니다.",
        "comprehensionInSet": "이해력은 다른 집합 항목과 함께 사용할 수 없습니다.",
        "concatenateContext": "이 컨텍스트에서는 \"연결\"을 사용할 수 없습니다.",
        "concatenateParamSpecMissing": "\"Concatenate\"의 마지막 형식 인수는 ParamSpec 또는 \"...\"이어야 합니다.",
        "concatenateTypeArgsMissing": "‘연결’에는 적어도 두 개의 형식 인수가 필요합니다.",
        "conditionalOperandInvalid": "’{type}’ 형식의 조건부 피연산자입니다.",
        "constantRedefinition": "‘{name}’은(는) 대문자이므로 상수이고 다시 정의할 수 없습니다.",
        "constructorNoArgs": "\"{type}\" 생성자에 인수가 필요하지 않습니다.",
        "constructorParametersMismatch": "‘{classType}’ 클래스에서 __new__ 서명과 __init__가 불일치합니다.",
        "containmentAlwaysFalse": "‘{leftType}’ 및 ‘{rightType}’ 형식이 겹치지 않으므로 식은 항상 False로 평가됩니다.",
        "containmentAlwaysTrue": "‘{leftType}’ 및 ‘{rightType}’ 형식이 겹치지 않으므로 식은 항상 True로 평가됩니다.",
        "continueInFinally": "finally 절 내에서는 \"continue\"를 사용할 수 없습니다.",
        "continueOutsideLoop": "\"continue\"는 루프 내에서만 사용할 수 있습니다.",
        "coroutineInConditionalExpression": "조건식은 항상 True로 평가되는 코루틴을 참조합니다.",
        "dataClassBaseClassFrozen": "고정되지 않은 클래스는 고정된 클래스에서 상속할 수 없습니다.",
        "dataClassBaseClassNotFrozen": "고정 클래스는 고정되지 않은 클래스에서 상속할 수 없습니다.",
        "dataClassConverterFunction": "\"{argType}\" 형식의 인수는 \"{fieldType}\" 형식의 \"{fieldName}\" 필드에 유효한 변환기가 아닙니다.",
        "dataClassConverterOverloads": "\"{funcName}\"의 오버로드는 \"{fieldType}\" 형식의 \"{fieldName}\" 필드에 유효한 변환기가 아닙니다.",
        "dataClassFieldWithDefault": "기본값이 없는 필드는 기본값이 있는 필드 뒤에 나타날 수 없습니다.",
        "dataClassFieldWithPrivateName": "데이터 클래스 필드는 프라이빗 이름을 사용할 수 없습니다.",
        "dataClassFieldWithoutAnnotation": "형식 주석이 없는 데이터 클래스 필드를 사용하면 런타임 예외가 발생합니다.",
        "dataClassPostInitParamCount": "데이터 클래스 __post_init__의 잘못된 매개 변수 수입니다. InitVar 필드 수가 {expected}개입니다.",
        "dataClassPostInitType": "데이터 클래스 __post_init__ 메서드 매개 변수 형식이 필드 \"{fieldName}\"에 대해 일치하지 않습니다.",
        "dataClassSlotsOverwrite": "__slots__ 클래스에 이미 정의되어 있습니다.",
        "dataClassTransformExpectedBoolLiteral": "정적으로 True 또는 False로 계산되는 식이 필요합니다.",
        "dataClassTransformFieldSpecifier": "클래스 또는 함수의 튜플이 필요하지만 ‘{type}’ 형식을 받았습니다.",
        "dataClassTransformPositionalParam": "\"dataclass_transform\"에 대한 모든 인수는 키워드 인수여야 합니다.",
        "dataClassTransformUnknownArgument": "dataclass_transform은 \"{name}\" 인수를 지원하지 않습니다.",
        "dataProtocolInSubclassCheck": "데이터 프로토콜(비 메서드 특성 포함)은 issubclass 호출에서 허용되지 않습니다.",
        "declaredReturnTypePartiallyUnknown": "선언된 반환 형식 \"{returnType}\"을(를) 부분적으로 알 수 없습니다.",
        "declaredReturnTypeUnknown": "선언된 반환 형식을 알 수 없습니다.",
        "defaultValueContainsCall": "매개 변수 기본값 식 내에서는 함수 호출 및 변경 가능한 개체를 사용할 수 없습니다.",
        "defaultValueNotAllowed": "\"*\" 또는 \"**\"가 있는 매개 변수는 기본값을 가질 수 없습니다.",
        "delTargetExpr": "식을 삭제할 수 없습니다.",
        "deprecatedClass": "‘{name}’ 클래스는 사용되지 않습니다.",
        "deprecatedConstructor": "클래스 \"{name}\"의 생성자는 더 이상 사용되지 않습니다.",
        "deprecatedDescriptorDeleter": "\"{name}\" 설명자에 대한 \"____delete____\" 메서드는 사용되지 않습니다.",
        "deprecatedDescriptorGetter": "\"{name}\" 설명자에 대한 \"__get__\" 메서드는 사용되지 않습니다.",
        "deprecatedDescriptorSetter": "\"{name}\" 설명자에 대한 \"__set__\" 메서드는 사용되지 않습니다.",
        "deprecatedFunction": "\"{name}\" 함수는 더 이상 사용되지 않습니다.",
        "deprecatedMethod": "\"{className}\" 클래스의 \"{name}\" 메서드는 더 이상 사용되지 않습니다.",
        "deprecatedPropertyDeleter": "\"{name}\" 속성에 대한 deleter는 사용되지 않습니다.",
        "deprecatedPropertyGetter": "\"{name}\" 속성에 대한 getter는 사용되지 않습니다.",
        "deprecatedPropertySetter": "\"{name}\" 속성에 대한 setter는 사용되지 않습니다.",
        "deprecatedType": "이 형식은 Python {version}부터 사용되지 않습니다. 대신 \"{replacement}\"을(를) 사용하세요.",
        "dictExpandIllegalInComprehension": "사전 확장은 이해에 사용할 수 없습니다.",
        "dictInAnnotation": "형식 주석에는 사전 식을 사용할 수 없습니다.",
        "dictKeyValuePairs": "사전 항목은 키/값 쌍을 포함해야 합니다.",
        "dictUnpackIsNotMapping": "사전 압축 풀기 연산자에 대한 매핑이 필요합니다.",
        "dunderAllSymbolNotPresent": "\"{name}\"이(가) __all__에 지정되었지만 모듈에 없습니다.",
        "duplicateArgsParam": "\"*\" 매개 변수 하나만 허용됨",
        "duplicateBaseClass": "중복 기본 클래스는 허용되지 않습니다.",
        "duplicateCapturePatternTarget": "‘{name}’ 캡처 대상이 동일한 패턴 내에 두 번 이상 나타날 수 없습니다.",
        "duplicateCatchAll": "절을 제외한 하나의 catch-all만 허용됨",
        "duplicateEnumMember": "열거형 멤버 \"{name}\"이(가) 이미 선언되었습니다.",
        "duplicateGenericAndProtocolBase": "하나의 Generic[...] 또는 Protocol[...] 기본 클래스만 허용됩니다.",
        "duplicateImport": "\"{importName}\"을(를) 두 번 이상 가져왔습니다.",
        "duplicateKeywordOnly": "\"*\" 구분 기호는 하나만 사용할 수 있습니다.",
        "duplicateKwargsParam": "\"**\" 매개 변수 하나만 허용됨",
        "duplicateParam": "매개 변수 \"{name}\"이(가) 중복되었습니다.",
        "duplicatePositionOnly": "‘/’ 매개 변수 하나민 허용됩니다.",
        "duplicateStarPattern": "패턴 시퀀스에는 ‘*’ 패턴을 하나만 사용할 수 있습니다.",
        "duplicateStarStarPattern": "‘**’ 항목 하나만 허용됩니다.",
        "duplicateUnpack": "목록에서는 한 개의 압축 풀기 작업만 허용됩니다.",
        "ellipsisAfterUnpacked": "\"...\" 압축을 풀고 있는 TypeVarTuple 또는 튜플과 함께 사용할 수 없습니다.",
        "ellipsisContext": "\"...\"는 이 컨텍스트에서는 허용되지 않습니다.",
        "ellipsisSecondArg": "\"...\"는 두 인수 중 두 번째 인수로만 허용됩니다.",
        "enumClassOverride": "열거형 클래스 \"{name}\"은(는) 최종 클래스이며 서브클래스할 수 없습니다.",
        "exceptionGroupIncompatible": "예외 그룹 구문(\"except*\")에는 Python 3.11 이상이 필요합니다.",
        "exceptionTypeIncorrect": "‘{type}’은 BaseException에서 파생되지 않습니다.",
        "exceptionTypeNotClass": "\"{type}\"은(는) 올바른 예외 클래스가 아닙니다.",
        "exceptionTypeNotInstantiable": "예외 형식 \"{type}\"에 대한 생성자에는 하나 이상의 인수가 필요합니다.",
        "expectedAfterDecorator": "데코레이터 다음에 함수 또는 클래스 선언이 필요합니다.",
        "expectedArrow": "\"->\" 다음에 반환 형식 주석이 와야 합니다.",
        "expectedAsAfterException": "예외 형식 뒤에 ‘as’가 필요합니다.",
        "expectedAssignRightHandExpr": "\"=\" 오른쪽에 식이 필요합니다.",
        "expectedBinaryRightHandExpr": "연산자 오른쪽에 식이 필요합니다.",
        "expectedBoolLiteral": "True 또는 False가 필요합니다.",
        "expectedCase": "\"case\" 문이 필요합니다.",
        "expectedClassName": "클래스 이름이 필요합니다.",
        "expectedCloseBrace": "\"{\"가 닫혀 있지 않습니다.",
        "expectedCloseBracket": "\"[{0}\"이(가) 닫혀 있지 않습니다.",
        "expectedCloseParen": "\"(\"가 닫혀 있지 않음",
        "expectedColon": "':'가 필요합니다.",
        "expectedComplexNumberLiteral": "패턴 일치에 복소수 리터럴이 필요합니다.",
        "expectedDecoratorExpr": "Python 3.9 이전의 데코레이터에는 식 형식이 지원되지 않습니다.",
        "expectedDecoratorName": "데코레이터 이름이 필요합니다.",
        "expectedDecoratorNewline": "데코레이터 끝에 새 줄이 필요합니다.",
        "expectedDelExpr": "\"del\" 뒤에 식이 필요합니다.",
        "expectedElse": "\"else\"가 필요합니다.",
        "expectedEquals": "\"=\"가 필요합니다.",
        "expectedExceptionClass": "잘못된 예외 클래스 또는 개체",
        "expectedExceptionObj": "필요한 예외 개체, 예외 클래스 또는 없음",
        "expectedExpr": "식이 필요합니다.",
        "expectedFunctionAfterAsync": "‘async’ 다음에 함수 정의가 필요합니다.",
        "expectedFunctionName": "\"def\" 뒤에 함수 이름이 필요합니다.",
        "expectedIdentifier": "식별자가 필요합니다.",
        "expectedImport": "\"import\"가 필요합니다.",
        "expectedImportAlias": "\"as\" 뒤에 기호가 필요합니다.",
        "expectedImportSymbols": "가져온 후 하나 이상의 기호 이름이 필요합니다.",
        "expectedIn": "\"in\"이 필요합니다.",
        "expectedInExpr": "\"in\" 뒤에 식이 필요합니다.",
        "expectedIndentedBlock": "들여쓰기 블록이 필요합니다.",
        "expectedMemberName": "\".\" 뒤에 멤버 이름이 필요합니다.",
        "expectedModuleName": "필요한 모듈 이름",
        "expectedNameAfterAs": "‘as’ 뒤에는 기호 이름이 와야 합니다.",
        "expectedNamedParameter": "키워드 매개 변수는 \"*\"를 따라야 합니다.",
        "expectedNewline": "줄 바꿈이 필요합니다.",
        "expectedNewlineOrSemicolon": "문은 줄 바꿈 또는 세미콜론으로 구분해야 합니다.",
        "expectedOpenParen": "’(‘가 필요합니다.",
        "expectedParamName": "매개 변수 이름이 필요합니다.",
        "expectedPatternExpr": "패턴 식이 필요합니다.",
        "expectedPatternSubjectExpr": "패턴 제목 식이 필요합니다.",
        "expectedPatternValue": "\"a.b\" 형식의 패턴 값 식이 필요합니다.",
        "expectedReturnExpr": "\"return\" 뒤에 식이 필요합니다.",
        "expectedSliceIndex": "인덱스 또는 조각 식이 필요합니다.",
        "expectedTypeNotString": "형식이 필요하지만 문자열 리터럴을 받았습니다.",
        "expectedTypeParameterName": "형식 매개 변수 이름이 필요합니다.",
        "expectedYieldExpr": "yield 문에 식이 필요합니다.",
        "finalClassIsAbstract": "\"{type}\" 클래스가 Final로 표시되어 있으며 모든 추상 기호를 구현해야 합니다.",
        "finalContext": "\"Final\"은 이 컨텍스트에서 허용되지 않습니다.",
        "finalMethodOverride": "\"{name}\" 메서드는 \"{className}\" 클래스에 정의된 최종 메서드를 재정의할 수 없습니다.",
        "finalNonMethod": "함수 \"{name}\"은(는) 메서드가 아니므로 @final로 표시할 수 없습니다.",
        "finalReassigned": "‘{name}’이 Final로 선언되었으므로 다시 할당할 수 없습니다.",
        "finalRedeclaration": "\"{name}\"이(가) 이전에 Final로 선언되었습니다.",
        "finalRedeclarationBySubclass": "부모 클래스 \"{className}\"이(가) Final로 선언하므로 \"{name}\"을(를) 다시 선언할 수 없습니다.",
        "finalTooManyArgs": "\"Final\" 뒤에 단일 형식 인수가 필요합니다.",
        "finalUnassigned": "\"{name}\"이(가) Final로 선언되었지만 값이 할당되지 않았습니다.",
        "formatStringBrace": "f-string 리터럴 내에서는 단일 닫는 중괄호를 사용할 수 없습니다. 이중 닫는 중괄호를 사용하세요.",
        "formatStringBytes": "형식 문자열 리터럴(f-strings)은 이진일 수 없습니다.",
        "formatStringDebuggingIllegal": "F-string 디버깅 지정자인 ‘=’는 Python 3.8 이상이 필요합니다.",
        "formatStringEscape": "Python 3.12 이전의 f-string의 식 부분에 이스케이프 시퀀스(백슬래시)를 사용할 수 없습니다.",
        "formatStringExpectedConversion": "f-string에서 \"!\" 뒤에 변환 지정자가 필요합니다.",
        "formatStringIllegal": "형식 문자열 리터럴(f-strings)은 Python 3.6 이상이 필요합니다.",
        "formatStringInPattern": "패턴에서 형식 문자열을 사용할 수 없습니다.",
        "formatStringNestedFormatSpecifier": "형식 문자열 지정자 내에 너무 깊게 중첩된 식",
        "formatStringNestedQuote": "f-string 내에 중첩된 문자열은 Python 3.12 이전의 f-string과 같은 따옴표를 사용할 수 없습니다.",
        "formatStringUnicode": "형식 문자열 리터럴(f-문자열)은 유니코드일 수 없습니다.",
        "formatStringUnterminated": "f-string에 종결되지 않은 식이 있습니다. ‘}‘가 필요합니다.",
        "functionDecoratorTypeUnknown": "형식화되지 않은 함수 데코레이터는 함수 형식을 모호하게 합니다. 데코레이터 무시",
        "functionInConditionalExpression": "조건식은 항상 True로 평가되는 함수를 참조합니다.",
        "functionTypeParametersIllegal": "함수 형식 매개 변수 구문에는 Python 3.12 이상이 필요합니다.",
        "futureImportLocationNotAllowed": "__future__ 가져오기는 파일의 시작 부분에 있어야 합니다.",
        "generatorAsyncReturnType": "비동기 생성기 함수의 반환 형식은 \"AsyncGenerator[{yieldType}, Any]\"와 호환되어야 합니다.",
        "generatorNotParenthesized": "생성기 식은 단독 인수가 아닌 경우 괄호로 지정해야 합니다.",
        "generatorSyncReturnType": "생성기 함수의 반환 형식은 \"Generator[{yieldType}, Any, Any]\"와 호환되어야 합니다.",
        "genericBaseClassNotAllowed": "‘제네릭’ 기본 클래스는 형식 매개 변수 구문과 함께 사용할 수 없습니다.",
        "genericClassAssigned": "제네릭 클래스 형식을 할당할 수 없습니다.",
        "genericClassDeleted": "제네릭 클래스 형식을 삭제할 수 없습니다.",
        "genericInstanceVariableAccess": "클래스를 통한 제네릭 인스턴스 변수에 대한 액세스가 모호합니다.",
        "genericNotAllowed": "이 컨텍스트에서 \"Generic\"이 잘못되었습니다.",
        "genericTypeAliasBoundTypeVar": "클래스 내의 제네릭 형식 별칭은 바인딩된 형식 변수 {names}을(를) 사용할 수 없습니다.",
        "genericTypeArgMissing": "\"Generic\"에는 하나 이상의 형식 인수가 필요합니다.",
        "genericTypeArgTypeVar": "\"Generic\"의 형식 인수는 형식 변수여야 합니다.",
        "genericTypeArgUnique": "\"Generic\"의 형식 인수는 고유해야 합니다.",
        "globalReassignment": "전역 선언 전에 \"{name}\"이(가) 할당되었습니다.",
        "globalRedefinition": "\"{name}\"이(가) 이미 전역으로 선언되었습니다.",
        "implicitStringConcat": "암시적 문자열 연결이 허용되지 않습니다.",
        "importCycleDetected": "가져오기 체인에서 순환이 검색되었습니다.",
        "importDepthExceeded": "가져오기 체인 깊이가 {depth}을(를) 초과했습니다.",
        "importResolveFailure": "가져오기 \"{importName}\"을(를) 확인할 수 없습니다.",
        "importSourceResolveFailure": "원본에서 가져오기 \"{importName}\"을(를) 확인할 수 없습니다.",
        "importSymbolUnknown": "\"{name}\"은(는) 알 수 없는 가져오기 기호입니다.",
        "incompatibleMethodOverride": "\"{name}\" 메서드가 호환되지 않는 방식으로 \"{className}\" 클래스를 재정의합니다.",
        "inconsistentIndent": "들여쓰기하지 않은 양이 이전 들여쓰기와 일치하지 않습니다.",
        "inconsistentTabs": "들여쓰기에서 탭 및 공백의 일관성 없는 사용",
        "initMustReturnNone": "\"__init__\"의 반환 형식은 None이어야 합니다.",
        "initSubclassCallFailed": "__init_subclass__ 메서드의 키워드 인수가 잘못됨",
        "initSubclassClsParam": "__init_subclass__ 재정의는 \"cls\" 매개 변수를 사용해야 합니다.",
        "initVarNotAllowed": "이 컨텍스트에서는 \"InitVar\"가 허용되지 않습니다.",
        "instanceMethodSelfParam": "인스턴스 메서드는 \"self\" 매개 변수를 사용해야 합니다.",
        "instanceVarOverridesClassVar": "‘{name}’ 인스턴스 변수가 ‘{className}’ 클래스에서 같은 이름의 클래스 변수를 재정의합니다.",
        "instantiateAbstract": "'{type}' 추상 클래스를 인스턴스화할 수 없습니다.",
        "instantiateProtocol": "‘{type}’ 프로토콜 클래스를 인스턴스화할 수 없습니다.",
        "internalBindError": "파일 \"{file}\"을(를) 바인딩하는 동안 내부 오류가 발생했습니다. {message}",
        "internalParseError": "파일 \"{file}\"을(를) 구문 분석하는 동안 내부 오류가 발생했습니다. {message}",
        "internalTypeCheckingError": "파일 \"{file}\"의 형식을 확인하는 동안 내부 오류가 발생했습니다. {message}",
        "invalidIdentifierChar": "식별자에 잘못된 문자가 있습니다.",
        "invalidStubStatement": "형식 스텁 파일 내에서는 문이 의미가 없습니다.",
        "invalidTokenChars": "토큰에 잘못된 문자 ‘{text}’이(가) 있습니다.",
        "isInstanceInvalidType": "‘issubclass’에 대한 두 번째 인수는 클래스 또는 클래스의 튜플이어야 합니다.",
        "isSubclassInvalidType": "\"issubclass\"에 대한 두 번째 인수는 클래스 또는 클래스의 튜플이어야 합니다.",
        "keyValueInSet": "집합 내에서 키/값 쌍을 사용할 수 없습니다.",
        "keywordArgInTypeArgument": "키워드 인수는 형식 인수 목록에서 사용할 수 없습니다.",
        "keywordOnlyAfterArgs": "키워드 전용 인수 구분 기호는 \"*\" 매개 변수 뒤에 사용할 수 없습니다.",
        "keywordParameterMissing": "하나 이상의 키워드 매개 변수는 ’*‘ 매개 변수 뒤에 와야 합니다.",
        "keywordSubscriptIllegal": "아래 첨자 내의 키워드 인수는 지원되지 않습니다.",
        "lambdaReturnTypePartiallyUnknown": "람다의 반환 형식 \"{returnType}\"을(를) 부분적으로 알 수 없습니다.",
        "lambdaReturnTypeUnknown": "람다의 반환 형식을 알 수 없습니다.",
        "listAssignmentMismatch": "형식이 \"{type}\"인 식을 대상 목록에 할당할 수 없습니다.",
        "listInAnnotation": "형식 주석에는 목록 식을 사용할 수 없습니다.",
        "literalEmptyArgs": "‘Literal’ 뒤에 하나 이상의 형식 인수가 필요합니다.",
        "literalNotAllowed": "형식 인수가 없으면 이 컨텍스트에서 \"Literal\"을 사용할 수 없습니다.",
        "literalNotCallable": "리터럴 형식은 인스턴스화할 수 없습니다.",
        "literalUnsupportedType": "\"Literal\"의 형식 인수는 None, 리터럴 값(int, bool, str 또는 bytes) 또는 열거형 값이어야 합니다.",
        "matchIncompatible": "Match 문에는 Python 3.10 이상이 필요합니다.",
        "matchIsNotExhaustive": "match 문 내의 사례는 모든 값을 완전히 처리하지 않습니다.",
        "maxParseDepthExceeded": "최대 구문 분석 깊이를 초과했습니다. 식을 더 작은 하위 식으로 나누기",
        "memberAccess": "\"{type}\" 형식의 멤버 \"{name}\"에 액세스할 수 없습니다.",
        "memberDelete": "\"{type}\" 형식의 멤버 \"{name}\"을(를) 삭제할 수 없습니다.",
        "memberSet": "‘{type}’ 형식의 ‘{name}’ 멤버에 액세스할 수 없습니다.",
        "metaclassConflict": "파생 클래스의 메타클래스는 모든 기본 클래스의 메타클래스의 서브클래스여야 합니다.",
        "metaclassDuplicate": "메타클래스를 하나만 제공할 수 있습니다.",
        "metaclassIsGeneric": "메타클래스는 제네릭일 수 없습니다.",
        "methodNotDefined": "\"{name}\" 메서드가 정의되지 않았습니다.",
        "methodNotDefinedOnType": "\"{name}\" 메서드가 \"{type}\" 형식에 정의되지 않았습니다.",
        "methodOrdering": "일관된 메서드 순서를 만들 수 없습니다.",
        "methodOverridden": "‘{name}’은(는) ‘{className}’ 클래스에서 같은 이름의 메서드를 호환되지 않는 ‘{type}’ 형식으로 재정의합니다.",
        "methodReturnsNonObject": "\"{name}\" 메서드가 개체를 반환하지 않습니다.",
        "missingSuperCall": "\"{methodName}\" 메서드가 부모 클래스에서 같은 이름의 메서드를 호출하지 않습니다.",
        "moduleAsType": "모듈은 형식으로 사용할 수 없습니다.",
        "moduleNotCallable": "모듈을 호출할 수 없습니다.",
        "moduleUnknownMember": "‘{memberName}’은(는) ‘{moduleName}’ 모듈의 알려진 멤버가 아닙니다.",
        "namedExceptAfterCatchAll": "명명된 except 절은 catch-all except 절 뒤에 나타날 수 없습니다.",
        "namedParamAfterParamSpecArgs": "ParamSpec args 매개 변수 뒤에 키워드 매개 변수 \"{name}\"을(를) 시그니처에 표시할 수 없습니다.",
        "namedTupleEmptyName": "명명된 튜플 내의 이름은 비워 둘 수 없습니다.",
        "namedTupleEntryRedeclared": "부모 클래스 \"{className}\"이(가) 명명된 튜플이므로 \"{name}\"을(를) 재정의할 수 없습니다.",
        "namedTupleFirstArg": "명명된 튜플 클래스 이름이 첫 번째 인수로 필요합니다.",
        "namedTupleMultipleInheritance": "NamedTuple을 사용한 여러 상속은 지원되지 않습니다.",
        "namedTupleNameKeyword": "필드 이름은 키워드일 수 없습니다.",
        "namedTupleNameType": "항목 이름 및 형식을 지정하는 2개 항목 튜플이 필요합니다.",
        "namedTupleNameUnique": "명명된 튜플 내의 이름은 고유해야 합니다.",
        "namedTupleNoTypes": "\"namedtuple\"은 튜플 항목에 대한 형식을 제공하지 않습니다. 대신 \"NamedTuple\" 사용",
        "namedTupleSecondArg": "두 번째 인수로 명명된 튜플 항목 목록이 필요합니다.",
        "newClsParam": "__new__ 재정의는 \"cls\" 매개 변수를 사용해야 합니다.",
        "newTypeAnyOrUnknown": "NewType에 대한 두 번째 인수는 Any 또는 Unknown이 아닌 알려진 클래스여야 합니다.",
        "newTypeBadName": "NewType의 첫 번째 인수는 문자열 리터럴이어야 합니다.",
        "newTypeLiteral": "NewType은 리터럴 형식과 함께 사용할 수 없습니다.",
        "newTypeNameMismatch": "NewType은 이름이 같은 변수에 할당되어야 합니다.",
        "newTypeNotAClass": "NewType에 대한 두 번째 인수로 클래스가 필요합니다.",
        "newTypeParamCount": "NewType에는 두 개의 위치 인수가 필요합니다.",
        "newTypeProtocolClass": "NewType은 구조적 유형(프로토콜 또는 TypedDict 클래스)과 함께 사용할 수 없습니다.",
        "noOverload": "제공된 인수와 일치하는 \"{name}\"에 대한 오버로드가 없습니다.",
        "noReturnContainsReturn": "선언된 반환 형식이 \"NoReturn\"인 함수는 return 문을 포함할 수 없습니다.",
        "noReturnContainsYield": "선언된 반환 형식이 \"NoReturn\"인 함수는 yield 문을 포함할 수 없습니다.",
        "noReturnReturnsNone": "선언된 반환 형식이 \"NoReturn\"인 함수는 \"None\"을 반환할 수 없습니다.",
        "nonDefaultAfterDefault": "기본값이 아닌 인수가 기본 인수를 따릅니다.",
        "nonLocalInModule": "모듈 수준에서는 비로컬 선언을 사용할 수 없습니다.",
        "nonLocalNoBinding": "비로컬 \"{name}\"에 대한 바인딩을 찾을 수 없습니다.",
        "nonLocalReassignment": "비로컬 선언 전에 \"{name}\"이(가) 할당되었습니다.",
        "nonLocalRedefinition": "\"{name}\"이(가) 이미 비로컬로 선언되었습니다.",
        "noneNotCallable": "‘None’ 유형의 개체를 호출할 수 없습니다.",
        "noneNotIterable": "\"None\" 형식의 개체는 반복 가능한 값으로 사용할 수 없습니다.",
        "noneNotSubscriptable": "’None’ 유형의 개체는 아래 첨자를 사용할 수 없습니다.",
        "noneNotUsableWith": "\"None\" 형식의 개체는 \"with\"와 함께 사용할 수 없습니다.",
        "noneOperator": "\"None\"에 대해 연산자 \"{operator}\"이(가) 지원되지 않습니다.",
        "noneUnknownMember": "\"{name}\"은(는) \"None\"의 알려진 멤버가 아닙니다.",
        "notRequiredArgCount": "\"NotRequired\" 뒤에 단일 형식 인수가 필요합니다.",
        "notRequiredNotInTypedDict": "이 컨텍스트에서는 \"NotRequired\"를 사용할 수 없습니다.",
        "objectNotCallable": "\"{type}\" 형식의 개체를 호출할 수 없습니다.",
        "obscuredClassDeclaration": "클래스 선언 \"{name}\"이(가) 같은 이름의 선언으로 가려져 있습니다.",
        "obscuredFunctionDeclaration": "함수 선언 \"{name}\"이(가) 동일한 이름의 선언으로 가려집니다.",
        "obscuredMethodDeclaration": "메서드 선언 \"{name}\"이(가) 동일한 이름의 선언으로 가려집니다.",
        "obscuredParameterDeclaration": "매개 변수 선언 \"{name}\"이(가) 동일한 이름의 선언으로 가려집니다.",
        "obscuredTypeAliasDeclaration": "형식 별칭 선언 \"{name}\"이(가) 동일한 이름의 선언으로 가려집니다.",
        "obscuredVariableDeclaration": "\"{name}\" 선언이 같은 이름의 선언으로 가려집니다.",
        "operatorLessOrGreaterDeprecated": "\"<>\" 연산자는 Python 3에서 지원되지 않습니다. 대신 \"!=\"를 사용하세요.",
        "optionalExtraArgs": "‘선택 사항’ 뒤에 1개의 형식 인수가 필요합니다.",
        "orPatternIrrefutable": "되돌릴 수 없는 패턴은 ‘or’ 패턴의 마지막 하위 페이지로만 허용됩니다.",
        "orPatternMissingName": "\"or\" 패턴 내의 모든 하위 패턴은 동일한 이름을 대상으로 해야 합니다.",
        "overlappingKeywordArgs": "형식화된 사전이 키워드 매개 변수 {names}과(와) 겹칩니다.",
        "overlappingOverload": "매개 변수가 오버로드 {obscuredBy}과(와) 겹치므로 \"{name}\"에 대한 오버로드 {obscured}이(가) 사용되지 않습니다.",
        "overloadAbstractMismatch": "오버로드된 메서드는 모두 추상이거나 모두 추상이 아니어야 합니다.",
        "overloadClassMethodInconsistent": "\"{name}\"의 오버로드가 @classmethod를 일관되지 않게 사용합니다.",
        "overloadFinalInconsistencyImpl": "\"{name}\"에 대한 오버로드가 @final로 표시되었지만 구현은 아닙니다.",
        "overloadFinalInconsistencyNoImpl": "\"{name}\"에 대한 오버로드 {index}는 @final로 표시되지만 오버로드 1은 표시되지 않습니다.",
        "overloadImplementationMismatch": "오버로드된 구현이 오버로드 {index}의 시그니처와 일치하지 않습니다.",
        "overloadReturnTypeMismatch": "\"{name}\"에 대한 {prevIndex} 오버로드가 오버로드 {newIndex}과(와) 겹치고 호환되지 않는 형식을 반환합니다.",
        "overloadStaticMethodInconsistent": "\"{name}\"의 오버로드가 @staticmethod를 일관되지 않게 사용합니다.",
        "overloadWithoutImplementation": "‘{name}’이(가) 오버로드로 표시되어 있지만 구현이 제공되지 않았습니다.",
        "overriddenMethodNotFound": "‘{name}’ 메서드가 재정의로 표시되어 있지만 이름이 같은 기본 메서드가 없습니다.",
        "overrideDecoratorMissing": "‘{name}’ 메서드가 재정의로 표시되지 않았지만 ‘{className}’ 클래스에서 메서드를 재정의하고 있습니다.",
        "paramAfterKwargsParam": "매개 변수는 ‘**’ 매개 변수 다음에 와야 합니다.",
        "paramAlreadyAssigned": "매개 변수 \"{name}\"이(가) 이미 할당되었습니다.",
        "paramAnnotationMissing": "‘{name}’ 매개 변수에 대한 형식 주석이 없습니다.",
        "paramAssignmentMismatch": "‘{sourceType}’ 형식의 식을 ‘{paramType}’ 형식의 매개 변수에 할당할 수 없습니다.",
        "paramNameMissing": "이름이 \"{name}\"인 매개 변수가 없습니다.",
        "paramSpecArgsKwargsUsage": "ParamSpec의 \"args\" 및 \"kwargs\" 멤버는 모두 함수 서명 내에 나타나야 합니다.",
        "paramSpecArgsMissing": "ParamSpec \"{type}\"에 대한 인수가 없습니다.",
        "paramSpecArgsUsage": "ParamSpec의 ‘args’ 멤버는 *args 매개 변수와 함께 사용할 경우에만 유효합니다.",
        "paramSpecAssignedName": "ParamSpec을 \"{name}\"이라는 변수에 할당해야 합니다.",
        "paramSpecContext": "ParamSpec은 이 컨텍스트에서 허용되지 않습니다.",
        "paramSpecDefaultNotTuple": "ParamSpec의 기본값에는 줄임표, 튜플 식 또는 ParamSpec이 필요합니다.",
        "paramSpecFirstArg": "첫 번째 인수로 ParamSpec의 이름이 필요합니다.",
        "paramSpecKwargsUsage": "ParamSpec의 \"kwargs\" 멤버는 **kwargs 매개 변수와 함께 사용할 때만 유효합니다.",
        "paramSpecNotUsedByOuterScope": "ParamSpec \"{name}\"은(는) 이 컨텍스트에서 의미가 없습니다.",
        "paramSpecScopedToReturnType": "ParamSpec ‘{name}’은 반환 형식 내에서 호출 가능으로 범위가 지정되며 함수 본문에서 참조할 수 없습니다.",
        "paramSpecUnknownArg": "ParamSpec은 한 개 이상의 인수를 지원하지 않습니다.",
        "paramSpecUnknownMember": "\"{name}\"은(는) ParamSpec의 알려진 멤버가 아닙니다.",
        "paramSpecUnknownParam": "‘{name}’은(는) ParamSpec에 대한 알 수 없는 매개 변수입니다.",
        "paramTypeCovariant": "공변(Covariant) 형식 변수는 매개 변수 형식에 사용할 수 없습니다.",
        "paramTypePartiallyUnknown": "매개 변수 \"{paramName}\"의 형식을 부분적으로 알 수 없습니다.",
        "paramTypeUnknown": "매개 변수 \"{paramName}\"의 형식을 알 수 없습니다.",
        "parenthesizedContextManagerIllegal": "‘with’ 문 내의 괄호는 Python 3.9 이상이 필요합니다.",
        "patternNeverMatches": "제목 형식 \"{type}\"에 대해 패턴이 일치하지 않습니다.",
        "positionArgAfterNamedArg": "위치 인수는 키워드 인수 뒤에 나타날 수 없습니다.",
        "positionOnlyAfterArgs": "위치 전용 매개 변수 구분 기호는 \"*\" 매개 변수 뒤에 사용할 수 없습니다.",
        "positionOnlyAfterKeywordOnly": "\"/\" 매개 변수는 \"*\" 매개 변수 앞에 나타나야 합니다.",
        "positionOnlyAfterNon": "위치 전용이 아닌 매개 변수 다음에는 위치 전용 매개 변수를 사용할 수 없습니다.",
        "positionOnlyFirstParam": "위치 전용 매개 변수 구분 기호는 첫 번째 매개 변수로 허용되지 않습니다.",
        "positionOnlyIncompatible": "위치 전용 매개 변수 구분 기호에는 Python 3.8 이상이 필요합니다.",
        "privateImportFromPyTypedModule": "\"{name}\"은(는) \"{module}\" 모듈에서 내보내지지 않습니다.",
        "privateUsedOutsideOfClass": "\"{name}\"은(는) 프라이빗이며 선언된 클래스 외부에서 사용됩니다.",
        "privateUsedOutsideOfModule": "\"{name}\"은(는) 프라이빗이며 선언된 모듈 외부에서 사용됩니다.",
        "propertyOverridden": "‘{name}’은(는) ‘{className}’ 클래스에서 같은 이름의 속성을 잘못 재정의합니다.",
        "propertyStaticMethod": "속성 getter, setter 또는 deleter에는 정적 메서드를 사용할 수 없습니다.",
        "protectedUsedOutsideOfClass": "‘{name}’은(는) 선언된 클래스 외부에서 보호되고 사용됩니다.",
        "protocolBaseClass": "‘{classType}’ 프로토콜 클래스는 ‘{baseType}’ 비프로토콜 클래스에서 파생될 수 없습니다.",
        "protocolBaseClassWithTypeArgs": "형식 매개 변수 구문을 사용할 때는 Protocol 클래스에 형식 인수가 허용되지 않습니다.",
        "protocolIllegal": "\"프로토콜\"을 사용하려면 Python 3.7 이상이 필요합니다.",
        "protocolNotAllowed": "이 컨텍스트에서는 \"Protocol\"을 사용할 수 없습니다.",
        "protocolUnsafeOverlap": "클래스가 \"{name}\"과(와) 안전하지 않게 겹치며 런타임에 일치 항목을 생성할 수 있습니다.",
        "protocolVarianceContravariant": "‘{class}‘ 제네릭 프로토콜에서 사용되는 ’{variable}‘ 형식 변수는 반공변이어야 합니다.",
        "protocolVarianceCovariant": "‘{class}‘ 제네릭 프로토콜에서 사용되는 ’{variable}‘ 형식 변수는 공변이어야 합니다",
        "protocolVarianceInvariant": "‘{class}‘ 제네릭 프로토콜에서 사용되는 ’{variable}‘ 형식 변수는 고정 변수여야 합니다.",
        "pyrightCommentInvalidDiagnosticBoolValue": "Pyright 주석 지시문 뒤에는 \"=\"와 true 또는 false 값이 와야 합니다.",
        "pyrightCommentInvalidDiagnosticSeverityValue": "Pyright 주석 지시문 뒤에는 \"=\"와 true, false, error, warning, information 또는 none 값이 와야 합니다.",
        "pyrightCommentMissingDirective": "Pyright 주석 뒤에는 지시문(기본 또는 엄격) 또는 진단 규칙이 있어야 합니다.",
        "pyrightCommentNotOnOwnLine": "파일 수준 설정을 제어하는 데 사용되는Pyright 주석은 고유의 줄에 표시되어야 합니다.",
        "pyrightCommentUnknownDiagnosticRule": "\"{rule}\"은(는) pyright 주석에 대한 알 수 없는 진단 규칙입니다.",
        "pyrightCommentUnknownDiagnosticSeverityValue": "\"{value}\"이(가) pyright 주석에 대해 잘못된 값입니다. true, false, error, warning, information 또는 none이 필요합니다.",
        "pyrightCommentUnknownDirective": "\"{directive}\"은(는) pyright 주석에 대한 알 수 없는 지시문입니다. \"strict\" 또는 \"basic\"이 필요합니다.",
        "readOnlyArgCount": "‘ReadOnly‘ 뒤에는 단일 형식 인수가 필요합니다.",
        "readOnlyNotInTypedDict": "이 컨텍스트에서는 \"ReadOnly\"를 사용할 수 없습니다.",
        "recursiveDefinition": "‘{name}’ 형식이 스스로를 참조하므로 확인할 수 없습니다.",
        "relativeImportNotAllowed": "상대 가져오기는 \"import .a\" 양식과 함께 사용할 수 없습니다. 대신 \"from . import a\"을(를) 사용합니다.",
        "requiredArgCount": "‘Required’ 뒤에 단일 형식 인수가 필요합니다.",
        "requiredNotInTypedDict": "이 컨텍스트에서는 \"Required\"를 사용할 수 없습니다.",
        "returnInAsyncGenerator": "값이 있는 Return 문은 비동기 생성기에서 사용할 수 없습니다.",
        "returnMissing": "선언된 반환 형식이 \"{returnType}\"인 함수는 모든 코드 경로에서 값을 반환해야 합니다.",
        "returnOutsideFunction": "‘return’은 함수 내에서만 사용할 수 있습니다.",
        "returnTypeContravariant": "반공변 유형 변수는 반환 형식에 사용할 수 없습니다.",
        "returnTypeMismatch": "\"{exprType}\" 형식의 식을 반환 형식 \"{returnType}\"에 할당할 수 없습니다.",
        "returnTypePartiallyUnknown": "반환 형식 \"{returnType}\"을(를) 부분적으로 알 수 없습니다.",
        "returnTypeUnknown": "반환 유형을 알 수 없습니다.",
        "revealLocalsArgs": "‘reveal_locals’ 호출은 인수가 필요하지 않습니다.",
        "revealLocalsNone": "이 범위에 로컬이 없습니다.",
        "revealTypeArgs": "\"reveal_type\" 호출에는 단일 위치 인수가 필요합니다.",
        "revealTypeExpectedTextArg": "‘reveal_type’ 함수의 ‘expected_text’ 인수는 str 리터럴 값이어야 합니다.",
        "revealTypeExpectedTextMismatch": "텍스트 형식이 일치하지 않습니다. \"{expected}\"이(가) 필요하지만 \"{received}\"을(를) 받았습니다.",
        "revealTypeExpectedTypeMismatch": "텍스트 형식이 일치하지 않습니다. ‘{expected}’이(가) 필요하지만 ‘{received}’을(를) 받았습니다.",
        "selfTypeContext": "이 컨텍스트에서는 \"Self\"가 잘못되었습니다.",
        "selfTypeMetaclass": "메타클래스(\"type\"의 서브클래스) 내에서 \"Self\"를 사용할 수 없습니다.",
        "selfTypeWithTypedSelfOrCls": "\"Self\"는 \"Self\" 이외의 형식 주석이 있는 'self' 또는 'cls' 매개 변수가 있는 함수에서 사용할 수 없습니다.",
        "setterGetterTypeMismatch": "속성 setter 값 형식을 getter 반환 형식에 할당할 수 없습니다.",
        "singleOverload": "\"{name}\"이(가) 오버로드로 표시되었지만 추가 오버로드가 없습니다.",
        "slotsAttributeError": "__slots__에서 ‘{name}’이(가) 지정되지 않았습니다.",
        "slotsClassVarConflict": "‘{name}‘이(가) __slots__에 선언된 instance 변수와 충돌합니다.",
        "starPatternInAsPattern": "별 무늬는 \"as\" 대상과 함께 사용할 수 없습니다.",
        "starPatternInOrPattern": "별 무늬는 다른 패턴 내에서 ORed할 수 없습니다.",
        "starStarWildcardNotAllowed": "**는 와일드카드 \"_\"와 함께 사용할 수 없습니다.",
        "staticClsSelfParam": "정적 메서드는 \"self\" 또는 \"cls\" 매개 변수를 사용하면 안 됩니다.",
        "stdlibModuleOverridden": "‘{path}’이(가) ‘{name}’ stdlib 모듈을 재정의하고 있습니다.",
        "stringNonAsciiBytes": "ASCII가 아닌 문자는 바이트 문자열 리터럴에 허용되지 않습니다.",
        "stringNotSubscriptable": "형식 주석에는 문자열 식을 첨자할 수 없습니다. 전체 주석을 따옴표로 묶습니다.",
        "stringUnsupportedEscape": "문자열 리터럴에 지원되지 않는 이스케이프 시퀀스가 있습니다.",
        "stringUnterminated": "문자열 리터럴이 종료되지 않았습니다.",
        "stubFileMissing": "\"{importName}\"에 대한 스텁 파일을 찾을 수 없습니다.",
        "stubUsesGetAttr": "형식 스텁 파일이 불완전합니다. \"__getattr__\"는 모듈에 대한 형식 오류를 모호하게 합니다.",
        "sublistParamsIncompatible": "하위 목록 매개 변수는 Python 3.x에서 지원되지 않습니다.",
        "superCallArgCount": "‘super’ 호출에는 인수가 2개 이하여야 합니다.",
        "superCallFirstArg": "\"super\" 호출에 대한 첫 번째 인수로 클래스 형식이 필요하지만 \"{type}\"을(를) 받았습니다.",
        "superCallSecondArg": "\"super\" 호출에 대한 두 번째 인수는 \"{type}\"에서 파생된 개체 또는 클래스여야 합니다.",
        "superCallZeroArgForm": "\"super\" 호출의 인수가 0인 형식은 메서드 내에서만 유효합니다.",
        "superCallZeroArgFormStaticMethod": "\"super\" 호출의 인수가 0인 형식은 정적 메서드 내에서 유효하지 않습니다.",
        "symbolIsPossiblyUnbound": "\"{name}\"은(는) 바인딩되지 않은 것일 수 있습니다.",
        "symbolIsUnbound": "\"{name}\"의 바인딩이 해제되었습니다.",
        "symbolIsUndefined": "\"{name}\"이(가) 정의되지 않았습니다.",
        "symbolOverridden": "\"{name}\"이(가) 클래스 \"{className}\"에서 동일한 이름의 기호를 재정의합니다.",
        "ternaryNotAllowed": "형식 주석에는 3항 식이 허용되지 않습니다.",
        "totalOrderingMissingMethod": "클래스는 total_ordering을 사용하려면 \"__lt__\", \"__le__\", \"__gt__\" 또는 \"__ge__\" 중 하나를 정의해야 합니다.",
        "trailingCommaInFromImport": "주변 괄호 없이는 후행 쉼표를 사용할 수 없습니다.",
        "tryWithoutExcept": "try 문에는 except 또는 finally 절이 하나 이상 있어야 합니다.",
        "tupleAssignmentMismatch": "형식이 ‘{type}’인 식을 대상 목록에 할당할 수 없습니다.",
        "tupleInAnnotation": "형식 주석에는 튜플 식을 사용할 수 없습니다.",
        "tupleIndexOutOfRange": "{index} 인덱스가 {type} 형식의 범위를 벗어났습니다.",
        "typeAliasIllegalExpressionForm": "형식 별칭 정의에 대한 식 양식이 잘못되었습니다.",
        "typeAliasIsRecursiveDirect": "형식 별칭 ‘{name}’의 정의에서 스스로를 사용할 수 없습니다.",
        "typeAliasNotInModuleOrClass": "TypeAlias는 모듈 또는 클래스 범위 내에서만 정의할 수 있습니다.",
        "typeAliasRedeclared": "\"{name}\"은(는) TypeAlias로 선언되며 한 번만 할당할 수 있습니다.",
        "typeAliasStatementBadScope": "type 문은 모듈 또는 클래스 범위 내에서만 사용할 수 있습니다.",
        "typeAliasStatementIllegal": "형식 별칭 문에는 Python 3.12 이상이 필요합니다.",
        "typeAliasTypeBaseClass": "\"type\" 문에 정의된 형식 별칭은 기본 클래스로 사용할 수 없습니다.",
        "typeAliasTypeMustBeAssigned": "TypeAliasType은 형식 별칭과 이름이 같은 변수에 할당해야 합니다.",
        "typeAliasTypeNameArg": "TypeAliasType의 첫 번째 인수는 형식 별칭의 이름을 나타내는 문자열 리터럴이어야 합니다.",
        "typeAliasTypeNameMismatch": "형식 별칭의 이름은 할당된 변수의 이름과 일치해야 합니다.",
        "typeAliasTypeParamInvalid": "형식 매개 변수 목록은 TypeVar, TypeVarTuple 또는 ParamSpec만 포함하는 튜플이어야 합니다.",
        "typeAnnotationCall": "형식 식에는 호출 식을 사용할 수 없습니다.",
        "typeAnnotationVariable": "형식 식에는 변수를 사용할 수 없습니다.",
        "typeAnnotationWithCallable": "\"type\"에 대한 형식 인수는 클래스여야 합니다. 콜러블은 지원되지 않습니다.",
        "typeArgListExpected": "ParamSpec, 줄임표 또는 형식 목록이 필요합니다.",
        "typeArgListNotAllowed": "이 형식 인수에는 목록 식을 사용할 수 없습니다.",
        "typeArgsExpectingNone": "클래스 \"{name}\"에 형식 인수가 필요하지 않습니다.",
        "typeArgsMismatchOne": "하나의 형식 인수가 필요하지만 {received}을(를) 받았습니다.",
        "typeArgsMissingForAlias": "제네릭 형식 별칭 \"{name}\"에 대한 형식 인수가 필요합니다.",
        "typeArgsMissingForClass": "‘{name}’ 제네릭 클래스에 대한 형식 인수가 필요합니다.",
        "typeArgsTooFew": "\"{name}\"에 대해 제공된 형식 인수가 너무 적습니다. {expected}이(가) 필요하지만 {received}을(를) 받았습니다.",
        "typeArgsTooMany": "‘{name}’에 대한 형식 인수가 너무 많습니다. {expected}이(가) 필요하지만 {received}을(를) 받았습니다.",
        "typeAssignmentMismatch": "\"{sourceType}\" 형식의 식을 선언된 형식 \"{destType}\"에 할당할 수 없습니다.",
        "typeAssignmentMismatchWildcard": "가져오기 기호 \"{name}\"에 선언된 형식 \"{destType}\"에 할당할 수 없는 \"{sourceType}\" 형식이 있습니다.",
        "typeCallNotAllowed": "type() 호출은 형식 주석에 사용하면 안 됩니다.",
        "typeCheckOnly": "\"{name}\"이(가) @type_check_only로 표시되어 있으므로 형식 주석에서만 사용할 수 있습니다.",
        "typeCommentDeprecated": "형식 주석의 사용은 더 이상 사용되지 않습니다. 대신 형식 주석 사용",
        "typeExpectedClass": "형식 식이 필요하지만 \"{type}\"을(를) 받았습니다.",
        "typeGuardArgCount": "\"TypeGuard\" 또는 \"TypeIs\" 뒤에 단일 형식 인수가 필요합니다.",
        "typeGuardParamCount": "사용자 정의 type guard 함수 및 메서드에는 하나 이상의 입력 매개 변수가 있어야 합니다.",
        "typeIsReturnType": "TypeIs의 반환 형식(\"{returnType}\")이 값 매개 변수 형식(\"{type}\")과 일치하지 않습니다.",
        "typeNotAwaitable": "‘{type}’은(는) 대기할 수 없습니다.",
        "typeNotIntantiable": "\"{type}\"을(를) 인스턴스화할 수 없습니다.",
        "typeNotIterable": "\"{type}\" 반복할 수 없습니다.",
        "typeNotSpecializable": "‘{type}’ 형식을 특수화할 수 없습니다.",
        "typeNotSubscriptable": "\"{type}\" 형식의 개체를 첨자할 수 없습니다.",
        "typeNotSupportBinaryOperator": "‘{operator}’ 연산자는 ‘{leftType}’ 및 ‘{rightType}’ 형식에 대해 지원되지 않습니다.",
        "typeNotSupportBinaryOperatorBidirectional": "예상 형식이 ‘{expectedType}’인 경우 ‘{type}’ 형식에 대해 ‘{operator}’ 연산자가 지원되지 않습니다.",
        "typeNotSupportUnaryOperator": "‘None‘에 대해 ’{operator}‘ 연산자가 지원되지 않습니다.",
        "typeNotSupportUnaryOperatorBidirectional": "예상 형식이 \"{expectedType}\" 경우 형식 \"{type}\"에 대해 연산자 \"{operator}\"이(가) 지원되지 않습니다.",
        "typeNotUsableWith": "\"{type}\" 형식의 개체는 {method}을(를) 구현하지 않으므로 \"with\"와 함께 사용할 수 없습니다.",
        "typeParameterBoundNotAllowed": "바운드 또는 제약 조건은 가변 인자 형식 매개 변수 또는 ParamSpec와 함께 사용할 수 없습니다.",
        "typeParameterConstraintTuple": "형식 매개 변수 제약 조건은 두 개 이상의 형식 튜플이어야 합니다.",
        "typeParameterExistingTypeParameter": "형식 매개 변수 \"{name}\"이(가) 이미 사용 중입니다.",
        "typeParameterNotDeclared": "형식 매개 변수 \"{name}\"이(가) \"{container}\"의 형식 매개 변수 목록에 포함되어 있지 않습니다.",
        "typeParametersMissing": "하나 이상의 형식 매개 변수를 지정해야 합니다.",
        "typePartiallyUnknown": "\"{name}\"의 형식을 부분적으로 알 수 없습니다.",
        "typeUnknown": "\"{name}\" 유형을 알 수 없습니다.",
        "typeVarAssignedName": "TypeVar을 \"{name}\"이라는 변수에 할당해야 합니다.",
        "typeVarAssignmentMismatch": "‘{type}’ 형식을 ‘{name}’ 형식 변수에 할당할 수 없습니다.",
        "typeVarBoundAndConstrained": "TypeVar는 바인딩되고 제한될 수 없습니다.",
        "typeVarBoundGeneric": "TypeVar 바인딩 형식은 제네릭일 수 없습니다.",
        "typeVarConstraintGeneric": "TypeVar 제약 조건 형식은 제네릭일 수 없습니다.",
        "typeVarDefaultBoundMismatch": "TypeVar 기본 형식은 바인딩된 형식의 하위 형식이어야 합니다.",
        "typeVarDefaultConstraintMismatch": "TypeVar 기본 형식은 제약이 있는 형식 중 하나여야 합니다.",
        "typeVarDefaultIllegal": "형식 변수 기본 형식은 Python 3.13 이상이 필요합니다.",
        "typeVarDefaultInvalidTypeVar": "형식 매개 변수 \"{name}\"에 범위를 벗어난 하나 이상의 형식 변수를 참조하는 기본 형식이 있습니다.",
        "typeVarFirstArg": "TypeVar의 이름이 첫 번째 인수로 필요합니다.",
        "typeVarNoMember": "TypeVar \"{type}\"에 멤버 \"{name}\"이(가) 없습니다.",
        "typeVarNotSubscriptable": "TypeVar \"{type}\"을(를) 첨자할 수 없습니다.",
        "typeVarNotUsedByOuterScope": "형식 변수 \"{name}\"은(는) 이 컨텍스트에서 의미가 없습니다.",
        "typeVarPossiblyUnsolvable": "호출자가 ‘{param}’ 매개 변수에 대한 인수를 제공하지 않으면 ‘{name}’ 형식 변수가 확인되지 않을 수 있습니다.",
        "typeVarScopedToReturnType": "‘{name}’ 형식 변수는 반환 형식 내에서 호출 가능으로 범위가 지정되며 함수 본문에서 참조할 수 없습니다.",
        "typeVarSingleConstraint": "TypeVar에는 두 개 이상의 제한된 형식이 있어야 합니다.",
        "typeVarTupleConstraints": "TypeVarTuple에는 값 제약 조건이 있을 수 없습니다.",
        "typeVarTupleContext": "TypeVarTuple은 이 컨텍스트에서 허용되지 않습니다.",
        "typeVarTupleDefaultNotUnpacked": "TypeVarTuple 기본 형식은 압축을 푼 튜플 또는 TypeVarTuple이어야 합니다.",
        "typeVarTupleMustBeUnpacked": "TypeVarTuple 값에는 압축 풀기 연산자가 필요합니다.",
        "typeVarTupleUnknownParam": "\"{name}\"은(는) TypeVarTuple에 대한 알 수 없는 매개 변수입니다.",
        "typeVarUnknownParam": "‘{name}’은(는) TypeVar에 대한 알 수 없는 매개 변수입니다.",
        "typeVarUsedByOuterScope": "TypeVar ‘{name}’은(는) 외부 범위에서 이미 사용 중입니다.",
        "typeVarUsedOnlyOnce": "TypeVar \"{name}\"이(가) 제네릭 함수 시그니처에 한 번만 나타납니다.",
        "typeVarVariance": "TypeVar는 공변이면서 반공변일 수 없습니다.",
        "typeVarWithDefaultFollowsVariadic": "TypeVar \"{typeVarName}\"에 기본값이 있으며 TypeVarTuple \"{variadicName}\"을(를) 따를 수 없습니다.",
        "typeVarWithoutDefault": "‘{name}’은 기본 형식이 없으므로 형식 매개 변수 목록에서 ‘{other}’ 뒤에 나타날 수 없습니다.",
        "typeVarsNotInGenericOrProtocol": "Generic[] 또는 Protocol[]에는 모든 형식 변수가 포함되어야 합니다.",
        "typedDictAccess": "TypedDict의 항목에 액세스할 수 없습니다.",
        "typedDictAssignedName": "TypedDict를 \"{name}\"이라는 변수에 할당해야 합니다.",
        "typedDictBadVar": "TypedDict 클래스는 형식 주석만 포함할 수 있습니다.",
        "typedDictBaseClass": "TypedDict 클래스의 모든 기본 클래스도 TypedDict 클래스여야 합니다.",
        "typedDictBoolParam": "\"{name}\" 매개 변수에 True 또는 False 값이 있어야 합니다.",
        "typedDictClosedExtras": "기본 클래스 \"{name}\"은(는) 닫힌 TypedDict입니다. 추가 항목은 \"{type}\" 형식이어야 합니다.",
        "typedDictClosedNoExtras": "기본 클래스 \"{name}\"은(는) 닫힌 TypedDict입니다. 추가 항목은 허용되지 않습니다.",
        "typedDictDelete": "TypedDict에서 항목을 삭제할 수 없습니다.",
        "typedDictEmptyName": "TypedDict 내의 이름은 비워 둘 수 없습니다.",
        "typedDictEntryName": "사전 항목 이름에 필요한 문자열 리터럴",
        "typedDictEntryUnique": "사전 내의 이름은 고유해야 합니다.",
        "typedDictExtraArgs": "추가 TypedDict 인수가 지원되지 않음",
        "typedDictFieldNotRequiredRedefinition": "TypedDict 항목 \"{name}\"은(는) NotRequired로 재정의될 수 없습니다.",
        "typedDictFieldReadOnlyRedefinition": "TypedDict 항목 \"{name}\"은(는) ReadOnly로 재정의될 수 없습니다.",
        "typedDictFieldRequiredRedefinition": "TypedDict 항목 \"{name}\"은(는) 필수 항목으로 재정의될 수 없습니다.",
        "typedDictFirstArg": "TypedDict 클래스 이름이 첫 번째 인수로 필요합니다.",
        "typedDictInitsubclassParameter": "TypedDict는 __init_subclass__ 매개 변수 \"{name}\"을(를) 지원하지 않습니다.",
        "typedDictNotAllowed": "이 컨텍스트에서는 \"TypedDict\"를 사용할 수 없습니다.",
        "typedDictSecondArgDict": "두 번째 매개 변수로 사전 또는 키워드 매개 변수가 필요합니다.",
        "typedDictSecondArgDictEntry": "단순 사전 항목이 필요합니다.",
        "typedDictSet": "TypedDict에서 항목을 할당할 수 없습니다.",
        "unaccessedClass": "‘{name}’ 클래스에 액세스할 수 없습니다.",
        "unaccessedFunction": "함수 \"{name}\"에 액세스할 수 없습니다.",
        "unaccessedImport": "가져오기 \"{name}\"에 액세스할 수 없습니다.",
        "unaccessedSymbol": "\"{name}\"에 액세스할 수 없습니다.",
        "unaccessedVariable": "변수 \"{name}\"에 액세스할 수 없습니다.",
        "unannotatedFunctionSkipped": "주석이 없으므로 ‘{name}’ 함수 분석을 건너뜁니다.",
        "unaryOperationNotAllowed": "형식 주석에는 단항 연산자를 사용할 수 없습니다.",
        "unexpectedAsyncToken": "\"async\"를 따르려면 \"def\", \"with\" 또는 \"for\"가 필요합니다.",
        "unexpectedExprToken": "식 끝에 예기치 않은 토큰이 있습니다.",
        "unexpectedIndent": "예기치 않은 들여쓰기",
        "unexpectedUnindent": "들여쓰기가 필요 없음",
        "unhashableDictKey": "사전 키는 해시 가능해야 합니다.",
        "unhashableSetEntry": "집합 항목은 해시가 가능해야 합니다.",
        "uninitializedAbstractVariables": "추상 기본 클래스에 정의된 변수가 최종 클래스 \"{classType}\"에서 초기화되지 않았습니다.",
        "uninitializedInstanceVariable": "인스턴스 변수 \"{name}\"이(가) 클래스 본문 또는 __init__ 메서드에서 초기화되지 않았습니다.",
        "unionForwardReferenceNotAllowed": "공용 구조체 구문은 문자열 피연산자에서 사용할 수 없습니다. 전체 식 주위에 따옴표 사용",
        "unionSyntaxIllegal": "공용 구조체에 대한 대체 구문에는 Python 3.10 이상이 필요합니다.",
        "unionTypeArgCount": "공용 구조체에는 둘 이상의 형식 인수가 필요합니다.",
        "unionUnpackedTuple": "Union은 압축을 푼 튜플을 포함할 수 없습니다.",
        "unionUnpackedTypeVarTuple": "Union은 압축을 푼 TypeVarTuple을 포함할 수 없습니다.",
        "unnecessaryCast": "불필요한 ‘캐스트’ 호출입니다. 형식이 이미 ‘{type}’입니다.",
        "unnecessaryIsInstanceAlways": "불필요한 isinstance 호출입니다. \"{testType}\"은(는) 항상 \"{classType}\"의 인스턴스입니다.",
        "unnecessaryIsSubclassAlways": "불필요한 issubclass 호출입니다. ’{testType}‘은(는) 항상 ’{classType}‘의 하위 클래스입니다.",
        "unnecessaryPyrightIgnore": "불필요한 ‘# pyright: 무시’ 주석입니다.",
        "unnecessaryPyrightIgnoreRule": "불필요한 \"#ight: ignore\" 규칙: \"{name}\"",
        "unnecessaryTypeIgnore": "불필요한 ‘# 형식: 무시’ 주석입니다.",
        "unpackArgCount": "‘Final’ 뒤에는 단일 형식 인수가 필요합니다.",
        "unpackExpectedTypeVarTuple": "Unpack에 대한 형식 인수로 TypeVarTuple 또는 튜플이 필요합니다.",
        "unpackExpectedTypedDict": "압축 풀기를 위해서는 TypedDict 형식 인수가 필요합니다.",
        "unpackIllegalInComprehension": "압축 풀기 작업은 이해에서 사용할 수 없습니다.",
        "unpackInAnnotation": "형식 주석에는 압축 풀기 연산자를 사용할 수 없습니다.",
        "unpackInDict": "사전에서 압축 풀기 작업이 허용되지 않음",
        "unpackInSet": "집합 내에서는 압축 풀기 연산자를 사용할 수 없습니다.",
        "unpackNotAllowed": "이 컨텍스트에서는 압축 풀기가 허용되지 않습니다.",
        "unpackOperatorNotAllowed": "이 컨텍스트에서는 압축 풀기 작업이 허용되지 않습니다.",
        "unpackTuplesIllegal": "Python 3.8 이전의 튜플에서는 압축 풀기 작업이 허용되지 않습니다.",
        "unpackedArgInTypeArgument": "압축되지 않은 인수는 형식 인수 목록에 사용할 수 없습니다.",
        "unpackedArgWithVariadicParam": "압축을 푼 인수는 TypeVarTuple 매개 변수에 사용할 수 없습니다.",
        "unpackedDictArgumentNotMapping": "** 뒤의 인수 식은 \"str\" 키 형식의 매핑이어야 합니다.",
        "unpackedDictSubscriptIllegal": "아래 첨자에서 사전 압축 풀기 연산자는 사용할 수 없습니다.",
        "unpackedSubscriptIllegal": "아래 첨자의 압축 풀기 연산자에는 Python 3.11 이상이 필요합니다.",
        "unpackedTypeVarTupleExpected": "압축 해제된 TypeVarTuple이 필요합니다. 압축 풀기[{name1}] 또는 *{name2} 사용",
        "unpackedTypedDictArgument": "압축되지 않은 TypedDict 인수를 매개 변수와 일치시킬 수 없습니다.",
        "unreachableCode": "코드에 접근할 수 없습니다.",
        "unreachableExcept": "예외가 이미 처리되었으므로 Except 절에 연결할 수 없습니다.",
        "unsupportedDunderAllOperation": "\"__all__\"에 대한 작업이 지원되지 않으므로 내보낸 기호 목록이 잘못되었을 수 있습니다.",
        "unusedCallResult": "호출 식의 결과가 ‘{type}’ 형식이므로 사용되지 않습니다. 의도적인 경우 변수 ‘_’에 할당하세요.",
        "unusedCoroutine": "비동기 함수 호출의 결과가 사용되지 않습니다. \"await\"를 사용하거나 변수에 결과 할당",
        "unusedExpression": "식 값은 사용되지 않습니다.",
        "varAnnotationIllegal": "변수에 대한 형식 주석에는 Python 3.6 이상이 필요합니다. 이전 버전과의 호환성을 위해 형식 주석 사용",
        "variableFinalOverride": "변수 \"{name}\"이(가) Final로 표시되고 \"{className}\" 클래스에서 이름이 같은 비-Final 변수를 재정의합니다.",
        "variadicTypeArgsTooMany": "형식 인수 목록에는 압축을 풀고 있는 TypeVarTuple 또는 튜플이 하나만 있을 수 있습니다.",
        "variadicTypeParamTooManyAlias": "형식 별칭에는 TypeVarTuple 형식 매개 변수가 최대 하나만 있을 수 있지만 여러 ({names})가 수신되었습니다.",
        "variadicTypeParamTooManyClass": "제네릭 클래스에는 TypeVarTuple 형식 매개 변수가 하나만 있을 수 있지만 여러 ({names})을(를) 받았습니다.",
        "walrusIllegal": "연산자 \":=\"에는 Python 3.8 이상이 필요합니다.",
        "walrusNotAllowed": "주변 괄호 없이는 이 컨텍스트에서 \":=\" 연산자를 사용할 수 없습니다.",
        "wildcardInFunction": "클래스 또는 함수 내에서 와일드카드 가져오기가 허용되지 않음",
        "wildcardLibraryImport": "라이브러리에서 와일드카드를 가져오는 것은 허용되지 않습니다.",
        "wildcardPatternTypePartiallyUnknown": "와일드카드 패턴으로 캡처된 형식을 부분적으로 알 수 없습니다.",
        "wildcardPatternTypeUnknown": "와일드카드 패턴으로 캡처된 형식을 부분적으로 알 수 없습니다.",
        "yieldFromIllegal": "\"yield from\"을 사용하려면 Python 3.3 이상이 필요합니다.",
        "yieldFromOutsideAsync": "비동기 함수에서는 \"yield from\"을 사용할 수 없습니다.",
        "yieldOutsideFunction": "함수 또는 람다 외부에서는 ‘yield’를 사용할 수 없습니다.",
        "yieldWithinListCompr": "목록 이해 내에서는 \"yield\"를 사용할 수 없습니다.",
        "zeroCaseStatementsFound": "Match 문에는 Case 문이 하나 이상 포함되어야 합니다.",
        "zeroLengthTupleNotAllowed": "길이가 0인 튜플은 이 컨텍스트에서 허용되지 않습니다."
    },
    "DiagnosticAddendum": {
        "annotatedNotAllowed": "\"주석이 추가된\" 특수 양식은 인스턴스 및 클래스 검사와 함께 사용할 수 없습니다.",
        "argParam": "인수가 \"{paramName}\" 매개 변수에 해당합니다.",
        "argParamFunction": "인수가 \"{functionName}\" 함수의 \"{paramName}\" 매개 변수에 해당합니다.",
        "argsParamMissing": "‘*{paramName}’ 매개 변수에 해당하는 매개 변수가 없습니다.",
        "argsPositionOnly": "위치 전용 매개 변수가 일치하지 않습니다. {expected}이)(가) 필요하지만 {received}을(를) 받았습니다.",
        "argumentType": "인수 형식이 \"{type}\"입니다.",
        "argumentTypes": "인수 형식: ({types})",
        "assignToNone": "\"None\" 형식에는 형식을 할당할 수 없습니다.",
        "asyncHelp": "‘async with’를 사용하시겠습니까?",
        "baseClassIncompatible": "기본 클래스 \"{baseClass}\"은(는) \"{type}\" 유형과 호환되지 않습니다.",
        "baseClassIncompatibleSubclass": "기본 클래스 \"{baseClass}\"은(는) \"{type}\" 유형과 호환되지 않는 \"{subclass}\"에서 파생됩니다.",
        "baseClassOverriddenType": "기본 클래스 \"{baseClass}\"이(가) 재정의된 \"{type}\" 형식을 제공합니다.",
        "baseClassOverridesType": "‘{baseClass}’ 기본 클래스가 ‘{type}’ 형식을 재정의합니다.",
        "bytesTypePromotions": "disableBytesTypePromotions를 false로 설정하여 \"bytearray\" 및 \"memoryview\"에 대한 형식 승격 동작을 사용하도록 설정합니다.",
        "conditionalRequiresBool": "\"{operandType}\" 형식에 대한 메서드 __bool__에서 \"bool\" 대신 \"{boolReturnType}\" 형식을 반환합니다.",
        "dataClassFieldLocation": "필드 선언",
        "dataClassFrozen": "\"{name}\"이(가) 고정되어 있습니다.",
        "dataProtocolUnsupported": "\"{name}\"은(는) 데이터 프로토콜입니다.",
        "descriptorAccessBindingFailed": "설명자 클래스 \"{className}\"에 대한 메서드 \"{name}\"을(를) 바인딩하지 못했습니다.",
        "descriptorAccessCallFailed": "설명자 클래스 \"{className}\"에 대한 메서드 \"{name}\"을(를) 호출하지 못했습니다.",
        "finalMethod": "최종 메서드",
        "functionParamDefaultMissing": "‘{name}’ 매개 변수에 기본 인수가 없습니다.",
        "functionParamName": "매개 변수 이름 불일치: \"{destName}\" 및 \"{srcName}\"",
        "functionParamPositionOnly": "위치 전용 매개 변수가 일치하지 않습니다. 매개 변수 \"{name}\"은(는) 위치 전용이 아닙니다.",
        "functionReturnTypeMismatch": "‘{sourceType}’ 함수 반환 형식은 ‘{destType}’ 형식과 호환되지 않습니다.",
        "functionTooFewParams": "함수가 너무 적은 위치 매개 변수를 허용합니다. {expected}이(가) 필요하지만 {received}을(를) 받았습니다.",
        "functionTooManyParams": "함수가 너무 많은 위치 매개 변수를 허용합니다. {expected}이(가) 필요하지만 {received}을(를) 받았습니다.",
        "genericClassNotAllowed": "인스턴스 또는 클래스 검사에 형식 인수가 허용되지 않는 제네릭 형식",
        "incompatibleDeleter": "속성 삭제자 메서드가 호환되지 않습니다.",
        "incompatibleGetter": "속성 getter 메서드가 호환되지 않습니다.",
        "incompatibleSetter": "속성 setter 메서드가 호환되지 않습니다.",
        "initMethodLocation": "__init__ 메서드가 \"{type}\" 클래스에 정의되어 있습니다.",
        "initMethodSignature": "__init__의 서명은 \"{type}\"입니다.",
        "initSubclassLocation": "__init_subclass__ 메서드는 \"{name}\" 클래스에 정의되어 있음",
        "invariantSuggestionDict": "값 형식에서 공변(covariant)인 \"dict\"에서 \"Mapping\"(매핑)으로 전환하는 것이 좋습니다.",
        "invariantSuggestionList": "공변(covariant)인 \"list\"에서 \"Sequence\"로 전환하는 것이 좋습니다.",
        "invariantSuggestionSet": "공변(covariant)인 \"set\"에서 \"Container\"로 전환하는 것이 좋습니다.",
        "keyNotRequired": "‘{name}’은(는) ‘{type}’에서 필수 키가 아니므로 액세스로 인해 런타임 예외가 발생할 수 있습니다.",
        "keyReadOnly": "\"{name}\"은(는) \"{type}\"의 읽기 전용 키입니다.",
        "keyRequiredDeleted": "\"{name}\"은(는) 필수 키이므로 삭제할 수 없습니다.",
        "keyUndefined": "\"{name}\"이 \"{type}\"에 정의된 키가 아닙니다.",
        "kwargsParamMissing": "‘**{paramName}’ 매개 변수에 해당하는 매개 변수가 없습니다.",
        "listAssignmentMismatch": "\"{type}\" 형식이 대상 목록과 호환되지 않습니다.",
        "literalAssignmentMismatch": "\"{sourceType}\"을(를) \"{destType}\" 형식에 할당할 수 없습니다.",
        "matchIsNotExhaustiveHint": "전체 처리가 의도되지 않은 경우 \"case _: pass\"를 추가합니다.",
        "matchIsNotExhaustiveType": "처리되지 않은 형식: \"{type}\"",
        "memberAssignment": "‘{type}’ 형식의 식을 ‘{classType}’ 클래스의 ‘{name}’ 멤버에 할당할 수 없습니다.",
        "memberIsAbstract": "\"{type}.{name}\"이(가) 구현되지 않았습니다.",
        "memberIsAbstractMore": "{count}개 더...",
        "memberIsClassVarInProtocol": "\"{name}\"은(는) 프로토콜에서 ClassVar로 정의됩니다.",
        "memberIsFinalInProtocol": "\"{name}\"이(가) 프로토콜에서 Final로 표시됨",
        "memberIsInitVar": "멤버 \"{name}\"은(는) 초기화 전용 필드입니다.",
        "memberIsInvariant": "\"{name}\"은(는) 변경 가능하므로 고정되지 않습니다.",
        "memberIsNotClassVarInClass": "\"{name}\"은(는) 프로토콜과 호환되려면 ClassVar로 정의해야 합니다.",
        "memberIsNotClassVarInProtocol": "\"{name}\"이(가) 프로토콜에서 ClassVar로 정의되지 않았습니다.",
        "memberIsNotFinalInProtocol": "‘{name}’이(가) 프로토콜에서 최종으로 표시되지 않았습니다.",
        "memberIsWritableInProtocol": "\"{name}\"은(는) 프로토콜에서 쓸 수 있습니다.",
        "memberSetClassVar": "‘{name}’ 멤버는 ClassVar이므로 클래스 인스턴스를 통해 할당할 수 없습니다.",
        "memberTypeMismatch": "\"{name}\"은(는) 호환되지 않는 형식입니다.",
        "memberUnknown": "멤버 \"{name}\"을(를) 알 수 없습니다.",
        "metaclassConflict": "메타클래스 \"{metaclass1}\"이(가) \"{metaclass2}\"과(와) 충돌합니다.",
        "missingDeleter": "속성 삭제자 메서드가 없습니다.",
        "missingGetter": "속성 getter 메서드가 없습니다.",
        "missingSetter": "속성 setter 메서드가 없습니다.",
        "namedParamMissingInDest": "키워드 매개 변수 ‘{name}’이(가) 대상에 없습니다.",
        "namedParamMissingInSource": "키워드 매개 변수 ‘{name}’이(가) 소스에 없습니다.",
        "namedParamTypeMismatch": "\"{sourceType}\" 형식의 키워드 매개 변수 \"{name}\"을(를) \"{destType}\" 형식에 할당할 수 없습니다.",
        "namedTupleNotAllowed": "인스턴스 또는 클래스 검사에는 NamedTuple을 사용할 수 없습니다.",
        "newMethodLocation": "__new__ 메서드가 \"{type}\" 클래스에 정의되어 있습니다.",
        "newMethodSignature": "__new__ 의 서명은 \"{type}\"입니다.",
        "newTypeClassNotAllowed": "NewType으로 만든 클래스는 인스턴스 및 클래스 검사에 사용할 수 없습니다.",
        "noOverloadAssignable": "\"{type}\" 형식과 일치하는 오버로드된 함수가 없습니다.",
        "noneNotAllowed": "인스턴스 또는 클래스 검사에는 None을 사용할 수 없음",
        "orPatternMissingName": "누락된 이름: {name}",
        "overloadIndex": "오버로드 {index}이(가) 가장 가까운 일치 항목입니다.",
        "overloadNotAssignable": "\"{name}\"의 오버로드를 하나 이상 할당할 수 없습니다.",
        "overloadSignature": "오버로드 서명은 여기에 정의되어 있습니다.",
        "overriddenMethod": "재정의된 메서드",
        "overriddenSymbol": "재정의된 기호",
        "overrideInvariantMismatch": "\"{overrideType}\" 재정의 형식이 \"{baseType}\" 기본 형식과 같지 않습니다.",
        "overrideIsInvariant": "변수를 변경할 수 있으므로 해당 형식은 고정됩니다.",
        "overrideNoOverloadMatches": "재정의의 오버로드 서명이 기본 메서드와 호환되지 않습니다.",
        "overrideNotClassMethod": "기본 메서드가 classmethod로 선언되었지만 재정의는 그렇지 않은 경우",
        "overrideNotInstanceMethod": "기본 메서드가 instance 메서드로 선언되었지만 재정의가",
        "overrideNotStaticMethod": "기본 메서드가 staticmethod로 선언되었지만 재정의는 그렇지 않습니다.",
        "overrideOverloadNoMatch": "재정의는 기본 메서드의 모든 오버로드를 처리하지 않습니다.",
        "overrideOverloadOrder": "재정의 메서드에 대한 오버로드는 기본 메서드와 동일한 순서여야 합니다.",
        "overrideParamKeywordNoDefault": "‘{name}’ 키워드 매개 변수가 불일치합니다. 기본 매개 변수에 기본 인수 값이 있습니다. 재정의 매개 변수에는 없습니다.",
        "overrideParamKeywordType": "‘{name}’ 키워드 매개 변수 형식이 일치하지 않습니다. 기본 매개 변수는 형식이 ‘{baseType}’, 재정의 매개 변수는 형식이 ‘{overrideType}’입니다.",
        "overrideParamName": "{index} 매개 변수 이름이 일치하지 않습니다. 기본 매개 변수는 이름이 ‘{baseName}’입니다. 재정의 매개 변수는 이름이 ‘{overrideName}’입니다.",
        "overrideParamNameExtra": "기본에 매개 변수 \"{name}\"이(가) 없습니다.",
        "overrideParamNameMissing": "재정의에 ‘{name}’ 매개 변수가 없습니다.",
        "overrideParamNamePositionOnly": "매개 변수 {index} 불일치: 기본 매개 변수 \"{baseName}\"은(는) 키워드 매개 변수이며 재정의 매개 변수는 위치 전용임",
        "overrideParamNoDefault": "{index} 매개 변수가 불일치합니다. 기본 매개 변수에 기본 인수 값이 있습니다. 재정의 매개 변수에는 없습니다.",
        "overrideParamType": "‘{name}’ 매개 변수 형식이 일치하지 않습니다. 기본 매개 변수는 형식이 ‘{baseType}’, 재정의 매개 변수는 형식이 ‘{overrideType}’입니다.",
        "overridePositionalParamCount": "위치 매개 변수 개수가 일치하지 않습니다. 기본 메서드에 {baseCount}개가 있지만 재정의에는 {overrideCount}개가 있습니다.",
        "overrideReturnType": "반환 형식 불일치: 기본 메서드는 \"{baseType}\" 형식을 반환하고 재정의는 \"{overrideType}\" 형식을 반환합니다.",
        "overrideType": "기본 클래스는 형식을 \"{type}\"으로 정의합니다.",
        "paramAssignment": "매개 변수 {index}: \"{sourceType}\" 형식을 \"{destType}\" 형식에 할당할 수 없습니다.",
        "paramSpecMissingInOverride": "재정의 메서드에 ParamSpec 매개 변수가 없습니다.",
        "paramType": "매개 변수 형식은 \"{paramType}\"입니다.",
        "privateImportFromPyTypedSource": "대신 \"{module}\"에서 가져오기",
        "propertyAccessFromProtocolClass": "프로토콜 클래스 내에 정의된 속성은 클래스 변수로 액세스할 수 없습니다.",
        "propertyMethodIncompatible": "속성 메서드 \"{name}\"이(가) 호환되지 않습니다.",
        "propertyMethodMissing": "재정의에 ‘{name}’ 속성 메서드가 없습니다.",
        "propertyMissingDeleter": "\"{name}\" 속성에 정의된 삭제자가 없습니다.",
        "propertyMissingSetter": "\"{name}\" 속성에 정의된 setter가 없습니다.",
        "protocolIncompatible": "‘{sourceType}’은(는) ‘{destType}’ 프로토콜과 호환되지 않습니다.",
        "protocolMemberMissing": "\"{name}\"이(가) 없습니다.",
        "protocolRequiresRuntimeCheckable": "인스턴스 및 클래스 검사와 함께 사용하려면 프로토콜 클래스를 @runtime_checkable 합니다.",
        "protocolSourceIsNotConcrete": "‘{sourceType}’은(는) 구체적인 클래스 형식이 아니므로 ‘{destType}’ 형식에 할당할 수 없습니다.",
        "protocolUnsafeOverlap": "\"{name}\"의 특성은 프로토콜과 이름이 같습니다.",
        "pyrightCommentIgnoreTip": "\"# pyright: ignore[<diagnostic rules>]을(를) 사용하여 한 줄에 대한 진단을 억제합니다.",
        "readOnlyAttribute": "특성 \"{name}\"은(는) 읽기 전용입니다.",
        "seeClassDeclaration": "클래스 선언 참조",
        "seeDeclaration": "선언 참조",
        "seeFunctionDeclaration": "함수 선언 참조",
        "seeMethodDeclaration": "메서드 선언 참조",
        "seeParameterDeclaration": "매개 변수 선언 보기",
        "seeTypeAliasDeclaration": "형식 별칭 선언 참조",
        "seeVariableDeclaration": "변수 선언 보기",
        "tupleAssignmentMismatch": "‘{type}’ 형식이 대상 튜플과 호환되지 않습니다.",
        "tupleEntryTypeMismatch": "튜플 항목 {entry}이(가) 잘못된 형식입니다.",
        "tupleSizeIndeterminateSrc": "튜플 크기 불일치: {expected}이(가) 필요하지만 미정을 받았습니다.",
        "tupleSizeIndeterminateSrcDest": "튜플 크기 불일치: {expected} 이상이 필요하지만 미정을 받았습니다.",
        "tupleSizeMismatch": "튜플 크기 불일치: {expected}이(가) 필요하지만 {received}을(를) 받았습니다.",
        "tupleSizeMismatchIndeterminateDest": "튜플 크기 불일치: {expected} 이상이 필요하지만 {received}을(를) 받았습니다.",
        "typeAliasInstanceCheck": "\"type\" 문을 사용해 만든 형식 별칭은 인스턴스 및 클래스 검사에 사용할 수 없습니다.",
        "typeAssignmentMismatch": "\"{sourceType}\" 형식은 \"{destType}\" 형식에 할당할 수 없습니다.",
        "typeBound": "형식 변수 \"{name}\"에 대해 형식 \"{sourceType}\"이(가) 바인딩된 형식 \"{destType}\"과(와) 호환되지 않습니다.",
        "typeConstrainedTypeVar": "\"{type}\" 형식이 제한된 형식 변수 \"{name}\"과(와) 호환되지 않습니다.",
        "typeIncompatible": "\"{sourceType}\"이(가) \"{destType}\"과(와) 호환되지 않습니다.",
        "typeNotClass": "\"{type}\"이 클래스가 아닙니다.",
        "typeNotStringLiteral": "‘{type}’은(는) 문자열 리터럴이 아닙니다.",
        "typeOfSymbol": "‘{name}’의 유형이 ‘{type}’입니다.",
        "typeParamSpec": "\"{type}\" 형식이 ParamSpec \"{name}\"과(와) 호환되지 않습니다.",
        "typeUnsupported": "\"{type}\" 형식은 지원되지 않습니다.",
        "typeVarDefaultOutOfScope": "형식 변수 \"{name}\"이(가) 범위에 없습니다.",
        "typeVarIsContravariant": "\"{name}\" 형식 매개 변수는 반공변형식 매개 변수)이지만 \"{sourceType}\"은(는) \"{destType}\"의 상위 형식이 아닙니다.",
        "typeVarIsCovariant": "\"{name}\" 형식 매개 변수는 공변(covariant)이지만 \"{sourceType}\"은(는) \"{destType}\"의 하위 형식이 아닙니다.",
        "typeVarIsInvariant": "\"{name}\" 형식 매개 변수는 고정이지만 \"{sourceType}\"은(는) \"{destType}\"와 같지 않습니다.",
        "typeVarNotAllowed": "인스턴스 또는 클래스 검사에 TypeVar가 허용되지 않음",
        "typeVarTupleRequiresKnownLength": "TypeVarTuple을 알 수 없는 길이의 튜플에 바인딩할 수 없습니다.",
        "typeVarUnnecessarySuggestion": "대신 {type}을(를) 사용하세요.",
        "typeVarUnsolvableRemedy": "인수가 제공되지 않을 때 반환 형식을 지정하는 오버로드를 제공합니다.",
        "typeVarsMissing": "누락된 형식 변수: {names}",
        "typedDictBaseClass": "\"{type}\" 클래스는 TypedDict가 아닙니다.",
        "typedDictClassNotAllowed": "인스턴스 또는 클래스 검사에 TypedDict 클래스를 사용할 수 없습니다.",
        "typedDictClosedExtraNotAllowed": "항목 \"{name}\"을(를) 추가할 수 없음",
        "typedDictClosedExtraTypeMismatch": "형식이 \"{type}\"인 항목 \"{name}\"을(를) 추가할 수 없음",
        "typedDictClosedFieldNotRequired": "\"{name}\" 항목은 NotRequired여야 하므로 추가할 수 없습니다.",
        "typedDictExtraFieldNotAllowed": "\"{name}\"이(가) \"{type}\"에 없음",
        "typedDictExtraFieldTypeMismatch": "\"{name}\" 형식은 \"{type}\"의 \"__extra_items__\" 형식과 호환되지 않습니다.",
        "typedDictFieldMissing": "\"{name}\"이(가) \"{type}\"에 없습니다.",
        "typedDictFieldNotReadOnly": "\"{name}\"은(는) \"{type}\"에서 읽기 전용이 아닙니다.",
        "typedDictFieldNotRequired": "\"{name}\"은(는) \"{type}\"에 필요하지 않습니다.",
        "typedDictFieldRequired": "\"{type}\"에 \"{name}\"이(가) 필요합니다.",
        "typedDictFieldTypeMismatch": "\"{type}\" 형식은 \"{name}\" 항목에 할당할 수 없습니다.",
        "typedDictFieldUndefined": "\"{name}\"은(는) \"{type}\" 형식의 정의되지 않은 항목입니다.",
        "typedDictFinalMismatch": "@final 불일치로 인해 \"{sourceType}\"이(가) \"{destType}\"과(와) 호환되지 않습니다.",
        "typedDictNotAllowed": "TypedDict는 인스턴스 또는 클래스 검사에 사용할 수 없습니다.",
        "unhashableType": "‘{type}’ 형식을 해시할 수 없습니다.",
        "uninitializedAbstractVariable": "인스턴스 변수 \"{name}\"이(가) 추상 기본 클래스 \"{classType}\"에 정의되어 있지만 초기화되지 않았습니다.",
        "unreachableExcept": "\"{exceptionType}\"은(는) \"{parentType}\"의 서브클래스입니다.",
        "useDictInstead": "사전 형식을 나타내려면 Dict[T1, T2]를 사용하세요.",
        "useListInstead": "List[T]를 사용하여 목록 형식을 나타내거나 Union[T1, T2]를 사용하여 공용 구조체 형식을 나타내세요.",
        "useTupleInstead": "튜플[T1, ..., Tn]을 사용하여 튜플 형식을 나타내거나 Union[T1, T2]을 사용하여 공용 구조체 형식을 나타냅니다.",
        "useTypeInstead": "대신 Type[T] 사용",
        "varianceMismatchForClass": "‘{typeVarName}’ 형식 인수의 차이는 ‘{className}’ 기본 클래스와 호환되지 않습니다.",
        "varianceMismatchForTypeAlias": "‘{typeVarName}’ 형식 인수의 차이는 ‘{typeAliasParam}’와(과) 호환되지 않습니다."
    }
}
