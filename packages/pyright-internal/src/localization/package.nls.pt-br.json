{
    "CodeAction": {
        "createTypeStub": "Criar Stub de Tipo",
        "createTypeStubFor": "Criar stub de tipo para \"{moduleName}\"",
        "executingCommand": "Executando comando",
        "filesToAnalyzeCount": "{count} arquivos a serem analisados",
        "filesToAnalyzeOne": "1 arquivo a ser analisado",
        "findingReferences": "Localizando referências",
        "organizeImports": "Organizar as importações",
        "renameShadowedFile": "Renomear \"{oldFile}\" para \"{newFile}\""
    },
    "Completion": {
        "autoImportDetail": "Importação automática",
        "indexValueDetail": "Valor do índice"
    },
    "Diagnostic": {
        "abstractMethodInvocation": "O método \"{method}\" não pode ser chamado porque é abstrato e não está implementado",
        "annotatedParamCountMismatch": "Incompatibilidade de contagem de anotações de parâmetro: esperado {expected}, mas recebido {received}",
        "annotatedTypeArgMissing": "Esperava-se um argumento de tipo e uma ou mais anotações para \"Annotated\"",
        "annotationFormatString": "As anotações de tipo não podem usar literais de cadeia de caracteres de formato (cadeias de caracteres f)",
        "annotationNotSupported": "Anotação de tipo sem suporte para esta instrução",
        "annotationSpansStrings": "Anotações de tipo não podem abranger vários literais de cadeia de caracteres",
        "annotationStringEscape": "Anotações de tipo não podem conter caracteres de escape",
        "argAssignment": "O argumento do tipo \"{argType}\" não pode ser atribuído ao parâmetro do tipo \"{paramType}\"",
        "argAssignmentFunction": "O argumento do tipo \"{argType}\" não pode ser atribuído ao parâmetro do tipo \"{paramType}\" na função \"{functionName}\"",
        "argAssignmentParam": "O argumento do tipo \"{argType}\" não pode ser atribuído ao parâmetro \"{paramName}\" do tipo \"{paramType}\"",
        "argAssignmentParamFunction": "O argumento do tipo \"{argType}\" não pode ser atribuído ao parâmetro \"{paramName}\" do tipo \"{paramType}\" na função \"{functionName}\"",
        "argMissingForParam": "Argumento ausente para o parâmetro {name}",
        "argMissingForParams": "Argumentos ausentes para os parâmetros {names}",
        "argMorePositionalExpectedCount": "Esperavam-se mais {expected} argumentos posicionais",
        "argMorePositionalExpectedOne": "Espera-se mais um argumento posicional",
        "argPositional": "Argumento posicional esperado",
        "argPositionalExpectedCount": "{expected} argumentos posicionais esperados",
        "argPositionalExpectedOne": "Argumento posicional esperado 1",
        "argTypePartiallyUnknown": "O tipo de argumento é parcialmente desconhecido",
        "argTypeUnknown": "O tipo de argumento é desconhecido",
        "assertAlwaysTrue": "A expressão assert sempre é avaliada como true",
        "assertTypeArgs": "\"assert_type\" espera dois argumentos posicionais",
        "assertTypeTypeMismatch": "Incompatibilidade \"assert_type\": esperava-se \"{expected}\", mas recebeu \"{received}\"",
        "assignmentExprComprehension": "O destino da expressão de atribuição \"{name}\" não pode usar o mesmo nome da compreensão para o destino",
        "assignmentExprContext": "A expressão de atribuição deve estar dentro de módulo, função ou lambda",
        "assignmentExprInSubscript": "Expressões de atribuição em um subscrito são compatíveis apenas no Python 3.10 e mais recente",
        "assignmentInProtocol": "As variáveis de instância ou classe dentro de uma classe Protocol devem ser declaradas explicitamente dentro do corpo da classe",
        "assignmentTargetExpr": "A expressão não pode ser o destino de atribuição",
        "asyncNotInAsyncFunction": "Uso de \"async\" não permitido fora da função assíncrona",
        "awaitIllegal": "O uso de \"await\" requer o Python 3.5 ou mais recente",
        "awaitNotAllowed": "Anotações de tipo não podem usar \"await\"",
        "awaitNotInAsync": "\"await\" permitido somente dentro da função assíncrona",
        "backticksIllegal": "Não há suporte para expressões delimitadas por backticks no Python 3.x. Use repr em vez disso",
        "baseClassCircular": "A classe não pode derivar de si mesma",
        "baseClassFinal": "A classe base \"{type}\" está marcada como final e não pode ser subclasse",
        "baseClassIncompatible": "Classes base de {type} são mutuamente incompatíveis",
        "baseClassInvalid": "O argumento para a classe deve ser uma classe base",
        "baseClassMethodTypeIncompatible": "Classes base para a classe \"{classType}\" definem o método \"{name}\" de maneira incompatível",
        "baseClassUnknown": "O tipo de classe base é desconhecido, ocultando o tipo de classe derivada",
        "baseClassVariableTypeIncompatible": "Classes base para a classe \"{classType}\" definem a variável \"{name}\" de maneira incompatível",
        "binaryOperationNotAllowed": "Operador binário não permitido na anotação de tipo",
        "bindTypeMismatch": "Não foi possível associar o método \"{methodName}\" porque \"{type}\" não é atribuível ao parâmetro \"{paramName}\"",
        "breakOutsideLoop": "\"break\" só pode ser usado dentro de um loop",
        "callableExtraArgs": "Esperava-se apenas dois argumentos de tipo para \"Callable\"",
        "callableFirstArg": "Lista de tipos de parâmetro esperado ou \"...\"",
        "callableNotInstantiable": "Não é possível criar uma instância do tipo \"{type}\"",
        "callableSecondArg": "Tipo de retorno esperado como segundo argumento de tipo para \"Callable\"",
        "casePatternIsIrrefutable": "O padrão irrefutável é permitido somente para a última instrução case",
        "classAlreadySpecialized": "O tipo \"{type}\" já é especializado",
        "classDecoratorTypeUnknown": "Um decorador de classe sem tipo obscurece o tipo de classe. Ignorando o decorador",
        "classDefinitionCycle": "A definição de classe para \"{name}\" depende de si mesma",
        "classGetItemClsParam": "A substituição__class_getitem__ deve usar um parâmetro \"cls\"",
        "classMethodClsParam": "Os métodos de classe devem usar um parâmetro \"cls\"",
        "classNotRuntimeSubscriptable": "O subscrito para a classe \"{name}\" gerará uma exceção de runtime. Coloque a anotação de tipo entre aspas",
        "classPatternBuiltInArgPositional": "O padrão de classe aceita apenas sub-padrão posicional",
        "classPatternPositionalArgCount": "Muitos padrões posicionais para a classe \"{type}\"; esperado {expected} mas recebido {received}",
        "classPatternTypeAlias": "\"{type}\" não pode ser usado em um padrão de classe porque é um alias de tipo especializado",
        "classPropertyDeprecated": "As propriedades de classe foram preteridas no Python 3.11 e não terão suporte no Python 3.13",
        "classTypeParametersIllegal": "A sintaxe do parâmetro de tipo de classe requer o Python 3.12 ou mais recente",
        "classVarFirstArgMissing": "Um argumento de tipo era esperado após \"ClassVar\"",
        "classVarNotAllowed": "\"ClassVar\" não é permitido neste contexto",
        "classVarOverridesInstanceVar": "A variável de classe \"{name}\" substitui a variável de instância do mesmo nome na classe \"{className}\"",
        "classVarTooManyArgs": "Espera-se apenas um argumento de tipo após \"ClassVar\"",
        "classVarWithTypeVar": "O tipo \"ClassVar\" não pode incluir variáveis de tipo",
        "clsSelfParamTypeMismatch": "O tipo de parâmetro \"{name}\" deve ser um supertipo de sua classe \"{classType}\"",
        "codeTooComplexToAnalyze": "O código é muito complexo para ser analisado. Reduza a complexidade refatorando em sub-rotinas ou reduzindo caminhos de código condicionais",
        "collectionAliasInstantiation": "O tipo \"{type}\" não pode ser instanciado, use \"{alias}\" em vez disso",
        "comparisonAlwaysFalse": "A condição sempre será avaliada como False, pois os tipos \"{leftType}\" e \"{rightType}\" não têm sobreposição",
        "comparisonAlwaysTrue": "A condição sempre será avaliada como True, pois os tipos \"{leftType}\" e \"{rightType}\" não têm sobreposição",
        "comprehensionInDict": "A compreensão não pode ser usada com outras entradas de dicionário",
        "comprehensionInSet": "A compreensão não pode ser usada com outras entradas definidas",
        "concatenateContext": "\"Concatenate\" não é permitido nesse contexto",
        "concatenateParamSpecMissing": "O último tipo de argumento para \"Concatenate\" deve ser um ParamSpec ou \"...\"",
        "concatenateTypeArgsMissing": "\"Concatenate\" requer pelo menos dois argumentos de tipo",
        "conditionalOperandInvalid": "Operando condicional inválido do tipo \"{type}\"",
        "constantRedefinition": "\"{name}\" é constante (porque está em maiúsculas) e não pode ser redefinido",
        "constructorNoArgs": "Nenhum argumento esperado para o construtor \"{type}\"",
        "constructorParametersMismatch": "Incompatibilidade entre a assinatura de __new__ e __init__ na classe \"{classType}\"",
        "containmentAlwaysFalse": "A expressão sempre será avaliada como False, pois os tipos \"{leftType}\" e \"{rightType}\" não têm sobreposição",
        "containmentAlwaysTrue": "A expressão sempre será avaliada como True, pois os tipos \"{leftType}\" e \"{rightType}\" não têm sobreposição",
        "continueInFinally": "\"continue\" não pode ser usado em uma cláusula finally",
        "continueOutsideLoop": "\"continue\" só pode ser usado dentro de um loop",
        "coroutineInConditionalExpression": "A expressão condicional faz referência à corrotina, que sempre é avaliada como True",
        "dataClassBaseClassFrozen": "Uma classe não congelada não pode herdar de uma classe congelada",
        "dataClassBaseClassNotFrozen": "Uma classe congelada não pode herdar de uma classe que não está congelada",
        "dataClassConverterFunction": "O argumento do tipo \"{argType}\" não é um conversor válido para o campo \"{fieldName}\" do tipo \"{fieldType}\"",
        "dataClassConverterOverloads": "Nenhuma sobrecarga de \"{funcName}\" são conversores válidos para o campo \"{fieldName}\" do tipo \"{fieldType}\"",
        "dataClassFieldWithDefault": "Campos sem valores padrão não podem aparecer após campos com valores padrão",
        "dataClassFieldWithPrivateName": "O campo Dataclass não pode usar o nome privado",
        "dataClassFieldWithoutAnnotation": "O campo Dataclass sem anotação de tipo causará uma exceção de runtime",
        "dataClassPostInitParamCount": "Contagem de parâmetros de dataclasse __post_init__ incorreta. O número de campos InitVar é {expected}",
        "dataClassPostInitType": "Incompatibilidade de tipo de parâmetro de método de dataclasse __post_init__ para o campo \"{fieldName}\"",
        "dataClassSlotsOverwrite": "__slots__ já está definido na classe",
        "dataClassTransformExpectedBoolLiteral": "Expressão esperada que é avaliada estaticamente como True ou False",
        "dataClassTransformFieldSpecifier": "Esperava-se tupla de classes ou funções, mas recebeu o tipo \"{type}\"",
        "dataClassTransformPositionalParam": "Todos os argumentos para \"dataclass_transform\" devem ser argumentos de palavra-chave",
        "dataClassTransformUnknownArgument": "O argumento \"{name}\" dataclass_transform não é compatível",
        "dataProtocolInSubclassCheck": "Protocolos de dados (que incluem atributos que não são de método) não são permitidos em chamadas issubclass",
        "declaredReturnTypePartiallyUnknown": "O tipo de retorno declarado, \"{returnType}\", é parcialmente desconhecido",
        "declaredReturnTypeUnknown": "O tipo de retorno declarado é desconhecido",
        "defaultValueContainsCall": "Chamadas de função e objetos mutáveis não permitidos na expressão de valor padrão do parâmetro",
        "defaultValueNotAllowed": "O parâmetro com \"*\" ou \"**\" não pode ter valor padrão",
        "delTargetExpr": "A expressão não pode ser excluída",
        "deprecatedClass": "A classe \"{name}\" foi preterida",
        "deprecatedConstructor": "O construtor da classe \"{name}\" foi preterido",
        "deprecatedDescriptorDeleter": "O método \"__delete__\" para o descritor \"{name}\" está preterido",
        "deprecatedDescriptorGetter": "O método \"__get__\" para o descritor \"{name}\" está preterido",
        "deprecatedDescriptorSetter": "O método \"__set__\" para o descritor \"{name}\" está preterido",
        "deprecatedFunction": "A função \"{name}\" está obsoleta",
        "deprecatedMethod": "O método \"{name}\" na classe \"{className}\" está obsoleto",
        "deprecatedPropertyDeleter": "O excluídor da propriedade \"{name}\" foi preterido",
        "deprecatedPropertyGetter": "O getter da propriedade \"{name}\" foi preterido",
        "deprecatedPropertySetter": "O setter da propriedade \"{name}\" está preterido",
        "deprecatedType": "Este tipo foi preterido no Python {version}. Use \"{replacement}\" em vez disso",
        "dictExpandIllegalInComprehension": "Expansão de dicionário não permitida na compreensão",
        "dictInAnnotation": "Expressão de dicionário não permitida na anotação de tipo",
        "dictKeyValuePairs": "Entradas de dicionário devem conter pares chave/valor",
        "dictUnpackIsNotMapping": "Mapeamento esperado para o operador de desempacotamento de dicionário",
        "dunderAllSymbolNotPresent": "\"{name}\" está especificado no __all__ mas não está presente no módulo",
        "duplicateArgsParam": "Somente um parâmetro \"*\" permitido",
        "duplicateBaseClass": "Classe base duplicada não permitida",
        "duplicateCapturePatternTarget": "O destino de captura \"{name}\" não pode aparecer mais de uma vez dentro do mesmo padrão",
        "duplicateCatchAll": "Somente uma cláusula de exceção catch-all é permitida",
        "duplicateEnumMember": "O membro de enumeração \"{name}\" já está declarado",
        "duplicateGenericAndProtocolBase": "Somente uma classe base Generic[...] ou Protocol[...] é permitida",
        "duplicateImport": "\"{importName}\" foi importado mais de uma vez",
        "duplicateKeywordOnly": "Somente um separador \"*\" permitido",
        "duplicateKwargsParam": "Somente um parâmetro \"**\" é permitido",
        "duplicateParam": "Nome de parâmetro \"{name}\" duplicado",
        "duplicatePositionOnly": "Somente um parâmetro \"/\" permitido",
        "duplicateStarPattern": "Somente um padrão \"*\" permitido em uma sequência de padrões",
        "duplicateStarStarPattern": "Somente uma entrada \"**\" é permitida",
        "duplicateUnpack": "Somente uma operação unpack é permitida na lista",
        "ellipsisAfterUnpacked": "\"...\" não pode ser usado com um TypeVarTuple ou tupla descompactado",
        "ellipsisContext": "\"...\" não é permitido neste contexto",
        "ellipsisSecondArg": "\"...\" é permitido apenas como o segundo de dois argumentos",
        "enumClassOverride": "A classe Enum \"{name}\" é final e não pode ser subclasse",
        "exceptionGroupIncompatible": "A sintaxe do grupo de exceção (\"exceto*\") requer o Python 3.11 ou mais recente",
        "exceptionTypeIncorrect": "\"{type}\" não deriva de BaseException",
        "exceptionTypeNotClass": "\"{type}\" não é uma classe de exceção válida",
        "exceptionTypeNotInstantiable": "O construtor para o tipo de exceção \"{type}\" requer um ou mais argumentos",
        "expectedAfterDecorator": "Função ou declaração de classe esperada após o decorador",
        "expectedArrow": "Esperava-se \"->\" seguido pela anotação de tipo de retorno",
        "expectedAsAfterException": "Espera-se \"as\" após o tipo de exceção",
        "expectedAssignRightHandExpr": "Expressão esperada à direita de \"=\"",
        "expectedBinaryRightHandExpr": "Expressão esperada à direita do operador",
        "expectedBoolLiteral": "Espera-se True ou False",
        "expectedCase": "Instrução \"case\" esperada",
        "expectedClassName": "Nome de classe esperado",
        "expectedCloseBrace": "\"{\" não foi fechado",
        "expectedCloseBracket": "\"[\" não foi fechado",
        "expectedCloseParen": "\"(\" não foi fechado",
        "expectedColon": "Esperava-se \":\"",
        "expectedComplexNumberLiteral": "Literal de número complexo esperado para correspondência de padrões",
        "expectedDecoratorExpr": "Formulário de expressão sem suporte para decorador antes do Python 3.9",
        "expectedDecoratorName": "Nome do decorador esperado",
        "expectedDecoratorNewline": "Nova linha esperada no final do decorador",
        "expectedDelExpr": "Expressão esperada após \"del\"",
        "expectedElse": "Esperava-se #else",
        "expectedEquals": "Esperava-se \"=\"",
        "expectedExceptionClass": "Classe ou objeto de exceção inválido",
        "expectedExceptionObj": "Objeto de exceção esperado: classe de exceção ou None",
        "expectedExpr": "Expressão esperada",
        "expectedFunctionAfterAsync": "Definição de função esperada após \"assíncrona\"",
        "expectedFunctionName": "Nome da função esperado após \"def\"",
        "expectedIdentifier": "Identificador esperado",
        "expectedImport": "\"importação\" esperada",
        "expectedImportAlias": "Símbolo esperado após \"as\"",
        "expectedImportSymbols": "Esperado um ou mais nomes de símbolo após a importação",
        "expectedIn": "Esperava-se \"in\"",
        "expectedInExpr": "Expressão esperada após \"in\"",
        "expectedIndentedBlock": "Bloco recuado esperado",
        "expectedMemberName": "Nome de membro esperado após \".\"",
        "expectedModuleName": "Nome do módulo esperado",
        "expectedNameAfterAs": "Nome de símbolo esperado após \"as\"",
        "expectedNamedParameter": "O parâmetro de palavra-chave deve seguir \"*\"",
        "expectedNewline": "Nova linha esperada",
        "expectedNewlineOrSemicolon": "As instruções devem ser separadas por novas linhas ou ponto e vírgula",
        "expectedOpenParen": "Esperava-se \"(\"",
        "expectedParamName": "Nome do parâmetro esperado",
        "expectedPatternExpr": "Expressão padrão esperada",
        "expectedPatternSubjectExpr": "Expressão de assunto padrão esperada",
        "expectedPatternValue": "Expressão de valor padrão esperada da forma \"a.b\"",
        "expectedReturnExpr": "Expressão esperada após \"return\" ",
        "expectedSliceIndex": "Expressão de índice ou fatia esperada",
        "expectedTypeNotString": "Tipo esperado, mas recebeu um literal de cadeia de caracteres",
        "expectedTypeParameterName": "Nome do parâmetro de tipo esperado",
        "expectedYieldExpr": "Expressão esperada na instrução yield",
        "finalClassIsAbstract": "A classe \"{type}\" está marcada como final e deve implementar todos os símbolos abstratos",
        "finalContext": "\"Final\" não é permitido neste contexto",
        "finalMethodOverride": "O método \"{name}\" não pode substituir o método final definido na classe \"{className}\"",
        "finalNonMethod": "A função \"{name}\" não pode ser marcada como @final porque não é um método",
        "finalReassigned": "\"{name}\" está declarado como Final e não pode ser reatribuído",
        "finalRedeclaration": "\"{name}\" foi declarado anteriormente como Final",
        "finalRedeclarationBySubclass": "\"{name}\" não pode ser redeclarado porque a classe pai \"{className}\" a declara como Final",
        "finalTooManyArgs": "Argumento de tipo único esperado após \"Final\"",
        "finalUnassigned": "\"{name}\" está declarado como Final, mas o valor não foi atribuído",
        "formatStringBrace": "Chave de fechamento única não permitida no literal de cadeia de caracteres f. Usar chave de fechamento dupla",
        "formatStringBytes": "Literais de cadeia de caracteres de formato (cadeia de caracteres f) não podem ser binárias",
        "formatStringDebuggingIllegal": "O especificador de depuração de cadeia de caracteres f \"=\" requer o Python 3.8 ou mais recente",
        "formatStringEscape": "Sequência de escape (barra invertida) não permitida na parte de expressão da cadeia de caracteres f em versões anteriores ao Python 3.12",
        "formatStringExpectedConversion": "Esperava-se um especificador de conversão após \"!\" na cadeia de caracteres f",
        "formatStringIllegal": "Literais de cadeia de caracteres de formato (cadeias de caracteres f) exigem Python 3.6 ou mais recente",
        "formatStringInPattern": "Cadeia de caracteres de formato não permitida no padrão",
        "formatStringNestedFormatSpecifier": "Expressões aninhadas muito profundamente dentro do especificador de cadeia de caracteres de formato",
        "formatStringNestedQuote": "Cadeias de caracteres aninhadas em uma cadeia de caracteres f não podem usar o mesmo caractere de aspas que a cadeia de caracteres f antes do Python 3.12",
        "formatStringUnicode": "As literais de cadeia de caracteres de formato (f-strings) não podem ser unicode",
        "formatStringUnterminated": "Expressão não finalizada na cadeia de caracteres f. \"}\" era esperado",
        "functionDecoratorTypeUnknown": "Um decorador de função sem tipo obscurece o tipo de função. Ignorando o decorador",
        "functionInConditionalExpression": "Função de referências de expressão condicional que sempre é avaliada como True",
        "functionTypeParametersIllegal": "A sintaxe do parâmetro de tipo de função requer o Python 3.12 ou mais recente",
        "futureImportLocationNotAllowed": "As importações __future__ devem estar no início do arquivo",
        "generatorAsyncReturnType": "O tipo de retorno da função geradora assíncrona deve ser compatível com \"AsyncGenerator[{yieldType}, Any]\"",
        "generatorNotParenthesized": "As expressões de gerador devem estar entre parênteses se não forem argumentos exclusivos",
        "generatorSyncReturnType": "O tipo de retorno da função de gerador deve ser compatível com \"Generator[{yieldType}, Any, Any]\"",
        "genericBaseClassNotAllowed": "A classe base \"Generic\" não pode ser usada com sintaxe de parâmetro de tipo",
        "genericClassAssigned": "O tipo de classe genérica não pode ser atribuído",
        "genericClassDeleted": "O tipo de classe genérica não pode ser excluído",
        "genericInstanceVariableAccess": "O acesso à variável de instância genérica por meio da classe é ambíguo",
        "genericNotAllowed": "__arglist não é válido neste contexto",
        "genericTypeAliasBoundTypeVar": "O alias de tipo genérico dentro da classe não pode usar variáveis de tipo associado {names}",
        "genericTypeArgMissing": "\"Generic\" requer pelo menos um argumento de tipo",
        "genericTypeArgTypeVar": "O argumento de tipo para \"Generic\" deve ser uma variável de tipo",
        "genericTypeArgUnique": "Os argumentos de tipo para \"Genérico\" devem ser exclusivos",
        "globalReassignment": "\"{name}\" é atribuído antes da declaração global",
        "globalRedefinition": "\"{name}\" já foi declarado global",
        "implicitStringConcat": "Concatenação de cadeia de caracteres implícita não permitida",
        "importCycleDetected": "Ciclo detectado na cadeia de importação",
        "importDepthExceeded": "A profundidade da cadeia de importação excedeu {depth}",
        "importResolveFailure": "Não foi possível resolver a importação \"{importName}\"",
        "importSourceResolveFailure": "Não foi possível resolver a importação \"{importName}\" da origem",
        "importSymbolUnknown": "\"{name}\" é um símbolo de importação desconhecido",
        "incompatibleMethodOverride": "O método \"{name}\" substitui a classe \"{className}\" de maneira incompatível",
        "inconsistentIndent": "O valor de recuo não corresponde ao recuo anterior",
        "inconsistentTabs": "Uso inconsistente de guias e espaços no recuo",
        "initMustReturnNone": "O tipo de retorno de \"__init__\" deve ser None",
        "initSubclassCallFailed": "Argumentos de palavra-chave incorretos para o método __init_subclass__",
        "initSubclassClsParam": "A substituição __init_subclass__ deve usar um parâmetro \"cls\"",
        "initVarNotAllowed": "\"InitVar\" não é permitido neste contexto",
        "instanceMethodSelfParam": "Os métodos de instância devem usar um parâmetro \"self\"",
        "instanceVarOverridesClassVar": "A variável de instância \"{name}\" substitui a variável de classe de mesmo nome na classe \"{className}\"",
        "instantiateAbstract": "Não é possível instanciar a classe abstrata \"{type}\"",
        "instantiateProtocol": "Não é possível instanciar a classe de protocolo \"{type}\"",
        "internalBindError": "Erro interno ao associar o arquivo de associação \"{file}\": {message}",
        "internalParseError": "Ocorreu um erro interno ao analisar o arquivo \"{file}\": {message}",
        "internalTypeCheckingError": "Erro interno ao digitar o arquivo de verificação \"{file}\": {message}",
        "invalidIdentifierChar": "Caractere inválido no identificador",
        "invalidStubStatement": "A instrução não faz sentido dentro de um arquivo stub de tipo",
        "invalidTokenChars": "Caractere inválido \"{text}\" no token",
        "isInstanceInvalidType": "O segundo argumento para \"instance\" deve ser uma classe ou tupla de classes",
        "isSubclassInvalidType": "O segundo argumento para \"issubclass\" deve ser uma classe ou tupla de classes",
        "keyValueInSet": "Pares chave/valor não são permitidos em um conjunto",
        "keywordArgInTypeArgument": "Argumentos de palavra-chave não podem ser usados em listas de argumentos de tipo",
        "keywordOnlyAfterArgs": "Separador de argumento somente palavra-chave não permitido após o parâmetro \"*\"",
        "keywordParameterMissing": "Um ou mais parâmetros de palavra-chave devem seguir o parâmetro \"*\"",
        "keywordSubscriptIllegal": "Não há suporte para argumentos de palavra-chave em subscritos",
        "lambdaReturnTypePartiallyUnknown": "O tipo de retorno de lambda, \"{returnType}\", é parcialmente desconhecido",
        "lambdaReturnTypeUnknown": "O tipo de retorno de lambda é desconhecido",
        "listAssignmentMismatch": "A expressão com o tipo \"{type}\" não pode ser atribuída à lista de destino",
        "listInAnnotation": "Expressão de lista não permitida na anotação de tipo",
        "literalEmptyArgs": "Um ou mais argumentos de tipo esperados após \"Literal\"",
        "literalNotAllowed": "\"Literal\" não pode ser usado nesse contexto sem um argumento de tipo",
        "literalNotCallable": "O tipo literal não pode ser instanciado",
        "literalUnsupportedType": "Os argumentos de tipo para \"Literal\" devem ser None, um valor literal (int, bool, str ou bytes) ou um valor de enumeração",
        "matchIncompatible": "As instruções de correspondência exigem Python 3.10 ou mais recente",
        "matchIsNotExhaustive": "Os casos dentro da instrução match não lidam exaustivamente com todos os valores",
        "maxParseDepthExceeded": "Profundidade máxima de análise excedida. Divida a expressão em subexpressões menores",
        "memberAccess": "Não é possível acessar o membro \"{name}\" para o tipo \"{type}\"",
        "memberDelete": "Não é possível excluir o membro \"{name}\" para o tipo \"{type}\"",
        "memberSet": "Não é possível atribuir o membro \"{name}\" para o tipo \"{type}\"",
        "metaclassConflict": "A metaclasse de uma classe derivada deve ser uma subclasse das metaclasses de todas as suas classes base",
        "metaclassDuplicate": "Apenas uma metaclasse pode ser fornecida",
        "metaclassIsGeneric": "A metaclasse não pode ser genérica",
        "methodNotDefined": "Método \"{name}\" não definido",
        "methodNotDefinedOnType": "Método \"{name}\" não definido no tipo \"{type}\"",
        "methodOrdering": "Não é possível criar ordenação de método consistente",
        "methodOverridden": "\"{name}\" substitui o método de mesmo nome na classe \"{className}\" pelo tipo incompatível \"{type}\"",
        "methodReturnsNonObject": "O método \"{name}\" não retorna um objeto",
        "missingSuperCall": "O método \"{methodName}\" não chama o método do mesmo nome na classe pai",
        "moduleAsType": "O módulo não pode ser usado como um tipo.",
        "moduleNotCallable": "O módulo não pode ser chamado",
        "moduleUnknownMember": "\"{memberName}\" não é um membro conhecido do módulo \"{moduleName}\"",
        "namedExceptAfterCatchAll": "Uma cláusula except nomeada não pode aparecer após a cláusula catch-all except",
        "namedParamAfterParamSpecArgs": "O parâmetro de palavra-chave \"{name}\" não pode aparecer na assinatura após o parâmetro args ParamSpec",
        "namedTupleEmptyName": "Nomes dentro de uma tupla nomeada não podem ficar vazios",
        "namedTupleEntryRedeclared": "Não é possível substituir \"{name}\" porque a classe pai \"{className}\" é uma tupla nomeada",
        "namedTupleFirstArg": "Nome de classe de tupla nomeado esperado como primeiro argumento",
        "namedTupleMultipleInheritance": "Não há suporte para herança múltipla com NamedTuple",
        "namedTupleNameKeyword": "Os nomes dos campos não podem ser uma palavra-chave",
        "namedTupleNameType": "Tupla de duas entradas esperada especificando o nome e o tipo de entrada",
        "namedTupleNameUnique": "Os nomes dentro de uma tupla nomeada devem ser exclusivos",
        "namedTupleNoTypes": "\"namedtuple\" não fornece tipos para entradas de tupla. Em vez disso, use \"NamedTuple\"",
        "namedTupleSecondArg": "Lista de entrada de tupla nomeada esperada como segundo argumento",
        "newClsParam": "A substituição __new__ deve usar um parâmetro \"cls\"",
        "newTypeAnyOrUnknown": "O segundo argumento para NewType deve ser uma classe conhecida, não Qualquer ou Desconhecido",
        "newTypeBadName": "O primeiro argumento para NewType deve ser um literal de cadeia de caracteres",
        "newTypeLiteral": "NewType não pode ser usado com o tipo Literal",
        "newTypeNameMismatch": "NewType deve ser atribuído a uma variável com o mesmo nome",
        "newTypeNotAClass": "Classe esperada como segundo argumento para NewType",
        "newTypeParamCount": "NewType requer dois argumentos posicionais",
        "newTypeProtocolClass": "NewType não pode ser usado com tipo estrutural (um protocolo ou classe TypedDict)",
        "noOverload": "Nenhuma sobrecarga para \"{name}\" corresponde aos argumentos fornecidos",
        "noReturnContainsReturn": "A função com o tipo de retorno declarado \"NoReturn\" não pode incluir uma instrução return",
        "noReturnContainsYield": "A função com o tipo de retorno declarado \"NoReturn\" não pode incluir uma instrução yield",
        "noReturnReturnsNone": "Função com tipo de retorno declarado \"NoReturn\" não pode retornar \"None\"",
        "nonDefaultAfterDefault": "O argumento não padrão segue o argumento padrão",
        "nonLocalInModule": "Declaração não local não permitida no nível do módulo",
        "nonLocalNoBinding": "Nenhuma associação para \"{name}\" não local encontrada",
        "nonLocalReassignment": "\"{name}\" é atribuído antes da declaração não local",
        "nonLocalRedefinition": "\"{name}\" já foi declarado não local",
        "noneNotCallable": "O objeto do tipo \"None\" não pode ser chamado",
        "noneNotIterable": "O objeto do tipo \"None\" não pode ser usado como valor iterável",
        "noneNotSubscriptable": "O objeto do tipo \"None\" não é subscrito",
        "noneNotUsableWith": "O objeto do tipo \"None\" não pode ser usado com \"with\"",
        "noneOperator": "Operador \"{operator}\" incompatível com \"None\"",
        "noneUnknownMember": "\"{name}\" não é um membro conhecido de \"None\"",
        "notRequiredArgCount": "Argumento de tipo único esperado após \"NotRequired\"",
        "notRequiredNotInTypedDict": "\"NotRequired\" não é permitido neste contexto",
        "objectNotCallable": "O objeto do tipo \"{type}\" não pode ser chamado",
        "obscuredClassDeclaration": "A declaração de classe \"{name}\" está obscurecida por uma declaração de mesmo nome",
        "obscuredFunctionDeclaration": "A declaração de função \"{name}\" é obscurecida por uma declaração de mesmo nome",
        "obscuredMethodDeclaration": "A declaração de método \"{name}\" é obscurecida por uma declaração de mesmo nome",
        "obscuredParameterDeclaration": "A declaração de parâmetro \"{name}\" é obscurecida por uma declaração de mesmo nome",
        "obscuredTypeAliasDeclaration": "A declaração de alias de tipo \"{name}\" é obscurecida por uma declaração de mesmo nome",
        "obscuredVariableDeclaration": "A declaração \"{name}\" é obscurecida por uma declaração de mesmo nome",
        "operatorLessOrGreaterDeprecated": "O operador \"<>\" não é compatível no Python 3. Use \"!=\" em vez disso",
        "optionalExtraArgs": "Espera-se um argumento de tipo após \"Opcional\"",
        "orPatternIrrefutable": "Padrão irrefutável permitido somente como o último subpadrão em um padrão \"or\"",
        "orPatternMissingName": "Todos os subpadrões dentro de um padrão \"ou\" devem ter como destino os mesmos nomes",
        "overlappingKeywordArgs": "O dicionário digitado se sobrepõe ao parâmetro de palavra-chave: {names}",
        "overlappingOverload": "A sobrecarga {obscured} para \"{name}\" nunca será usada porque seus parâmetros se sobrepõem à sobrecarga {obscuredBy}",
        "overloadAbstractMismatch": "Os métodos sobrecarregados devem ser abstratos ou não",
        "overloadClassMethodInconsistent": "Sobrecargas para \"{name}\" usam @classmethod inconsistentemente",
        "overloadFinalInconsistencyImpl": "A sobrecarga para \"{name}\" está marcada como @final mas a implementação não está",
        "overloadFinalInconsistencyNoImpl": "A sobrecarga {index} para \"{name}\" está marcada como @final mas a sobrecarga 1 não está",
        "overloadImplementationMismatch": "A implementação sobrecarregada não é consistente com a assinatura da sobrecarga {index}",
        "overloadReturnTypeMismatch": "A sobrecarga {prevIndex} para \"{name}\" sobrepõe a sobrecarga {newIndex} e retorna um tipo incompatível",
        "overloadStaticMethodInconsistent": "Sobrecargas para \"{name}\" usam @staticmethod inconsistentemente",
        "overloadWithoutImplementation": "\"{name}\" está marcado como sobrecarga, mas nenhuma implementação foi fornecida",
        "overriddenMethodNotFound": "O método \"{name}\" está marcado como substituição, mas nenhum método base de mesmo nome está presente",
        "overrideDecoratorMissing": "O método \"{name}\" não está marcado como substituição, mas está substituindo um método na classe \"{className}\"",
        "paramAfterKwargsParam": "O parâmetro não pode seguir o parâmetro \"**\"",
        "paramAlreadyAssigned": "O parâmetro \"{name}\" já está atribuído",
        "paramAnnotationMissing": "A anotação de tipo está ausente para o parâmetro \"{name}\"",
        "paramAssignmentMismatch": "A expressão do tipo \"{sourceType}\" não pode ser atribuída ao parâmetro do tipo \"{paramType}\"",
        "paramNameMissing": "Nenhum parâmetro chamado \"{name}\"",
        "paramSpecArgsKwargsUsage": "Os membros \"args\" e \"kwargs\" de ParamSpec devem aparecer dentro de uma assinatura de função",
        "paramSpecArgsMissing": "Argumentos para ParamSpec \"{type}\" estão ausentes",
        "paramSpecArgsUsage": "O membro \"args\" de ParamSpec é válido somente quando usado com o parâmetro *args",
        "paramSpecAssignedName": "ParamSpec deve ser atribuído a uma variável chamada \"{name}\"",
        "paramSpecContext": "ParamSpec não é permitido neste contexto",
        "paramSpecDefaultNotTuple": "Reticências esperadas, uma expressão de tupla ou ParamSpec para o valor padrão de ParamSpec",
        "paramSpecFirstArg": "Nome esperado de ParamSpec como primeiro argumento",
        "paramSpecKwargsUsage": "O membro \"kwargs\" de ParamSpec é válido somente quando usado com o parâmetro **kwargs",
        "paramSpecNotUsedByOuterScope": "O ParamSpec \"{name}\" não tem significado neste contexto",
        "paramSpecScopedToReturnType": "ParamSpec \"{name}\" tem como escopo um chamador dentro do tipo de retorno e não pode ser referenciado no corpo da função",
        "paramSpecUnknownArg": "ParamSpec não é compatível com mais de um argumento",
        "paramSpecUnknownMember": "\"{name}\" não é um membro conhecido de ParamSpec",
        "paramSpecUnknownParam": "\"{name}\" é um parâmetro desconhecido para ParamSpec",
        "paramTypeCovariant": "Variável de tipo covariante não pode ser usada no tipo de parâmetro",
        "paramTypePartiallyUnknown": "O tipo de parâmetro \"{paramName}\" é parcialmente desconhecido",
        "paramTypeUnknown": "O tipo de parâmetro \"{paramName}\" é desconhecido",
        "parenthesizedContextManagerIllegal": "Parênteses dentro da instrução \"with\" exigem Python 3.9 ou mais recente",
        "patternNeverMatches": "O padrão nunca será correspondido para o tipo de assunto \"{type}\"",
        "positionArgAfterNamedArg": "O argumento posicional não pode aparecer após argumentos de palavra-chave",
        "positionOnlyAfterArgs": "Separador de parâmetro somente de posição não permitido após o parâmetro \"*\"",
        "positionOnlyAfterKeywordOnly": "O parâmetro \"/\" deve aparecer antes do parâmetro \"*\"",
        "positionOnlyAfterNon": "Parâmetro somente de posição não permitido após o parâmetro que não é somente posição",
        "positionOnlyFirstParam": "Separador de parâmetro somente de posição não permitido como primeiro parâmetro",
        "positionOnlyIncompatible": "O separador de parâmetro somente de posição requer o Python 3.8 ou mais recente",
        "privateImportFromPyTypedModule": "\"{name}\" não é exportado do módulo \"{module}\"",
        "privateUsedOutsideOfClass": "\"{name}\" é privado e usado fora da classe na qual é declarado",
        "privateUsedOutsideOfModule": "\"{name}\" é privado e usado fora do módulo no qual ele é declarado",
        "propertyOverridden": "\"{name}\" substitui incorretamente a propriedade de mesmo nome na classe \"{className}\"",
        "propertyStaticMethod": "Métodos estáticos não permitidos para as propriedades getter, setter ou deleter",
        "protectedUsedOutsideOfClass": "\"{name}\" está protegido e usado fora da classe na qual está declarado",
        "protocolBaseClass": "A classe de protocolo \"{classType}\" não pode derivar da classe \"{baseType}\" que não é de protocolo",
        "protocolBaseClassWithTypeArgs": "Argumentos de tipo não são permitidos com a classe Protocol ao usar a sintaxe de parâmetro de tipo",
        "protocolIllegal": "O uso de \"Protocol\" requer o Python 3.7 ou mais recente",
        "protocolNotAllowed": "\"Protocol\" não pode ser usado nesse contexto",
        "protocolUnsafeOverlap": "A classe se sobrepõe a \"{name}\" de forma não segura e pode produzir uma correspondência em runtime",
        "protocolVarianceContravariant": "A variável de tipo \"{variable}\" usada no protocolo genérico \"{class}\" deve ser contravariante",
        "protocolVarianceCovariant": "A variável de tipo \"{variable}\" usada no protocolo genérico \"{class}\" deve ser covariante",
        "protocolVarianceInvariant": "A variável de tipo \"{variable}\" usada no protocolo genérico \"{class}\" deve ser invariável",
        "pyrightCommentInvalidDiagnosticBoolValue": "A diretiva de comentário Pyright deve ser seguida por \"=\" e um valor true ou false",
        "pyrightCommentInvalidDiagnosticSeverityValue": "A diretiva de comentário Pyright deve ser seguida por \"=\" e um valor de true, false, error, warning, information ou none",
        "pyrightCommentMissingDirective": "O comentário pyright deve ser seguido por uma diretiva (básica ou estrita) ou uma regra de diagnóstico",
        "pyrightCommentNotOnOwnLine": "Comentários pyright usados para controlar as configurações de nível de arquivo devem aparecer em sua própria linha",
        "pyrightCommentUnknownDiagnosticRule": "\"{rule}\" é uma regra de diagnóstico desconhecida para o comentário pyright",
        "pyrightCommentUnknownDiagnosticSeverityValue": "\"{value}\" é um valor inválido para o comentário pyright. True, false, error, warning, information ou none esperados.",
        "pyrightCommentUnknownDirective": "\"{directive}\" é uma diretiva desconhecida para o comentário pyright. Esperava-se \"estrito\" ou \"básico\"",
        "readOnlyArgCount": "Argumento de tipo único esperado após \"ReadOnly\"",
        "readOnlyNotInTypedDict": "\"ReadOnly\" não é permitido neste contexto",
        "recursiveDefinition": "Não foi possível determinar o tipo de \"{name}\" porque ele refere-se a si mesmo",
        "relativeImportNotAllowed": "Importações relativas não podem ser usadas com o formulário \"import. a\". Use \"from . import a\" em vez disso",
        "requiredArgCount": "Argumento de tipo único esperado após \"Obrigatório\"",
        "requiredNotInTypedDict": "\"Obrigatório\" não é permitido neste contexto",
        "returnInAsyncGenerator": "A instrução return com valor não é permitida no gerador assíncrono",
        "returnMissing": "Função com tipo de retorno declarado \"{returnType}\" deve retornar valor em todos os caminhos de código",
        "returnOutsideFunction": "\"return\" só pode ser usado dentro de uma função",
        "returnTypeContravariant": "A variável de tipo contravariante não pode ser usada no tipo de retorno",
        "returnTypeMismatch": "A expressão do tipo \"{exprType}\" não pode ser atribuída ao tipo de retorno \"{returnType}\"",
        "returnTypePartiallyUnknown": "O tipo de retorno, \"{returnType}\", é parcialmente desconhecido",
        "returnTypeUnknown": "O tipo de retorno é desconhecido",
        "revealLocalsArgs": "Nenhum argumento esperado para a chamada \"reveal_locals\"",
        "revealLocalsNone": "Nenhum local neste escopo",
        "revealTypeArgs": "Esperava-se um único argumento posicional para a chamada \"reveal_type\"",
        "revealTypeExpectedTextArg": "O argumento \"expected_text\" para a função \"reveal_type\" deve ser um valor literal str",
        "revealTypeExpectedTextMismatch": "Tipo de incompatibilidade de texto. O esperado era \"{expected}\", mas recebeu \"{received}\"",
        "revealTypeExpectedTypeMismatch": "Incompatibilidade de tipo. Esperava-se \"{expected}\", mas recebeu \"{received}\"",
        "selfTypeContext": "\"Self\" não é válido neste contexto.",
        "selfTypeMetaclass": "\"Self\" não pode ser usado em uma metaclasse (uma subclasse de \"type\")",
        "selfTypeWithTypedSelfOrCls": "\"Self\" não pode ser usado em uma função com um parâmetro `self` ou `cls que tenha uma anotação de tipo diferente de \"Self\"",
        "setterGetterTypeMismatch": "O tipo de valor do setter da propriedade não é atribuível ao tipo de retorno getter",
        "singleOverload": "\"{name}\" está marcado como sobrecarga, mas sobrecargas adicionais estão ausentes",
        "slotsAttributeError": "\"{name}\" não está especificado em __slots__",
        "slotsClassVarConflict": "\"{name}\" está em conflito com a variável de instância declarada __slots__",
        "starPatternInAsPattern": "O padrão de estrela não pode ser usado com o destino \"as\"",
        "starPatternInOrPattern": "O padrão de estrela não pode ser ORed em outros padrões",
        "starStarWildcardNotAllowed": "** não pode ser usado com curinga \"_\"",
        "staticClsSelfParam": "Os métodos estáticos não devem usar um parâmetro \"self\" ou \"cls\"",
        "stdlibModuleOverridden": "\"{path}\" está substituindo o módulo stdlib \"{name}\"",
        "stringNonAsciiBytes": "Caractere não ASCII não permitido em literal de cadeia de caracteres de bytes",
        "stringNotSubscriptable": "A expressão de cadeia de caracteres não pode ser subscrito na anotação de tipo. Coloque a anotação inteira entre aspas",
        "stringUnsupportedEscape": "Sequência de escape sem suporte no literal de cadeia de caracteres",
        "stringUnterminated": "Literal de cadeia de caracteres não finalizado",
        "stubFileMissing": "Arquivo stub não encontrado para \"{importName}\"",
        "stubUsesGetAttr": "O arquivo stub de tipo está incompleto. \"__getattr__\" obscurece erros de tipo para o módulo",
        "sublistParamsIncompatible": "parâmetros de sublista não são suportados no Python 3.x",
        "superCallArgCount": "Não mais que dois argumentos eram esperados para a chamada \"super\"",
        "superCallFirstArg": "Tipo de classe esperado como o primeiro argumento para a chamada \"super\", mas recebeu \"{type}\"",
        "superCallSecondArg": "O segundo argumento para a chamada \"super\" deve ser objeto ou classe que deriva de \"{type}\"",
        "superCallZeroArgForm": "A forma de chamada \"super\" com argumento zero é válida apenas dentro de um método",
        "superCallZeroArgFormStaticMethod": "A forma de chamada \"super\" com argumento zero é válida apenas dentro de um método",
        "symbolIsPossiblyUnbound": "\"{name}\" possivelmente não está associado",
        "symbolIsUnbound": "\"{name}\" não está associado",
        "symbolIsUndefined": "\"{name}\" não está definido",
        "symbolOverridden": "\"{name}\" substitui o símbolo de mesmo nome na classe \"{className}\"",
        "ternaryNotAllowed": "Expressão de ternário não permitida na anotação de tipo",
        "totalOrderingMissingMethod": "A classe deve definir um dos \"__lt__\", \"__le__\", \"__gt__\" ou \"__ge__\" para usar total_ordering",
        "trailingCommaInFromImport": "A vírgula à direita não é permitida sem parênteses ao redor",
        "tryWithoutExcept": "A instrução Try deve ter pelo menos uma cláusula except ou finally",
        "tupleAssignmentMismatch": "A expressão com o tipo \"{type}\" não pode ser atribuída à tupla de destino",
        "tupleInAnnotation": "Expressão de tupla não permitida na anotação de tipo",
        "tupleIndexOutOfRange": "O índice {index} está fora do intervalo para o tipo {type}",
        "typeAliasIllegalExpressionForm": "Formulário de expressão inválido para definição de alias de tipo",
        "typeAliasIsRecursiveDirect": "O alias de tipo \"{name}\" não pode usar a si mesmo em sua definição",
        "typeAliasNotInModuleOrClass": "Um TypeAlias só pode ser definido dentro de um módulo ou escopo de classe",
        "typeAliasRedeclared": "\"{name}\" é declarado como um TypeAlias e só pode ser atribuído uma vez",
        "typeAliasStatementBadScope": "Uma instrução type só pode ser usada dentro de um módulo ou escopo de classe",
        "typeAliasStatementIllegal": "A instrução de alias de tipo requer o Python 3.12 ou mais recente",
        "typeAliasTypeBaseClass": "Um alias de tipo definido em uma instrução \"type\" não pode ser usado como uma classe base",
        "typeAliasTypeMustBeAssigned": "TypeAliasType deve ser atribuído a uma variável com o mesmo nome que o alias de tipo",
        "typeAliasTypeNameArg": "O primeiro argumento para TypeAliasType deve ser um literal de cadeia de caracteres que representa o nome do alias de tipo",
        "typeAliasTypeNameMismatch": "O nome do alias de tipo deve corresponder ao nome da variável à qual ela está atribuída",
        "typeAliasTypeParamInvalid": "A lista de parâmetros de tipo deve ser uma tupla contendo apenas TypeVar, TypeVarTuple ou ParamSpec",
        "typeAnnotationCall": "Expressão de chamada não permitida na expressão de tipo",
        "typeAnnotationVariable": "Variável não permitida na expressão de tipo",
        "typeAnnotationWithCallable": "O argumento de tipo para \"type\" deve ser uma classe; não há suporte para callables",
        "typeArgListExpected": "ParamSpec, reticências ou lista de tipos esperados",
        "typeArgListNotAllowed": "Expressão de lista não permitida para este argumento de tipo",
        "typeArgsExpectingNone": "Nenhum argumento de tipo era esperado para a classe \"{name}\"",
        "typeArgsMismatchOne": "Esperava-se um argumento de tipo, mas recebeu {received}",
        "typeArgsMissingForAlias": "Argumentos de tipo esperados para o alias de tipo genérico \"{name}\"",
        "typeArgsMissingForClass": "Argumentos de tipo esperados para a classe genérica \"{name}\"",
        "typeArgsTooFew": "Poucos argumentos de tipo fornecidos para \"{name}\". Esperava-se {expected}, mas recebeu {received}",
        "typeArgsTooMany": "Muitos argumentos de tipo fornecidos para \"{name}\". Esperava-se {expected}, mas recebeu {received}",
        "typeAssignmentMismatch": "A expressão do tipo \"{sourceType}\" não pode ser atribuída ao tipo declarado \"{destType}\"",
        "typeAssignmentMismatchWildcard": "O símbolo de importação \"{name}\" tem o tipo \"{sourceType}\", que não pode ser atribuído ao tipo declarado \"{destType}\"",
        "typeCallNotAllowed": "A chamada type() não deve ser usada na anotação de tipo",
        "typeCheckOnly": "\"{name}\" está marcado como @type_check_only e pode ser usado apenas em anotações de tipo",
        "typeCommentDeprecated": "O uso de comentários de tipo foi preterido. Use anotação de tipo em vez disso",
        "typeExpectedClass": "Expressão de tipo esperada, mas recebeu \"{type}\"",
        "typeGuardArgCount": "Argumento de tipo único esperado após \"TypeGuard\" ou \"TypeIs\"",
        "typeGuardParamCount": "Funções e métodos de proteção de tipo definidos pelo usuário devem ter pelo menos um parâmetro de entrada",
        "typeIsReturnType": "O tipo de retorno de TypeIs (\"{returnType}\") não é consistente com o tipo de parâmetro de valor (\"{type}\")",
        "typeNotAwaitable": "\"{type}\" não é previsível",
        "typeNotIntantiable": "\"{type}\" não pode ser instanciado",
        "typeNotIterable": "\"{type}\" não é iterável",
        "typeNotSpecializable": "Não foi possível especializar o tipo \"{type}\"",
        "typeNotSubscriptable": "O objeto do tipo \"{type}\" não é subscrito",
        "typeNotSupportBinaryOperator": "Operador \"{operator}\" sem suporte para os tipos \"{leftType}\" e \"{rightType}\"",
        "typeNotSupportBinaryOperatorBidirectional": "O operador \"{operator}\" não tem suporte para os tipos \"{leftType}\" e \"{rightType}\" quando o tipo esperado é \"{expectedType}\"",
        "typeNotSupportUnaryOperator": "Operador \"{operator}\" sem suporte para o tipo \"{type}\"",
        "typeNotSupportUnaryOperatorBidirectional": "O operador \"{operator}\" não tem suporte para o tipo \"{type}\" quando o tipo esperado é \"{expectedType}\"",
        "typeNotUsableWith": "O objeto do tipo \"{type}\" não pode ser usado com \"with\" porque não implementa {method}",
        "typeParameterBoundNotAllowed": "Associação ou restrição não pode ser usada com um parâmetro de tipo variadic ou ParamSpec",
        "typeParameterConstraintTuple": "A restrição de parâmetro de tipo deve ser uma tupla de dois ou mais tipos",
        "typeParameterExistingTypeParameter": "O parâmetro de tipo \"{name}\" já está em uso",
        "typeParameterNotDeclared": "O parâmetro de tipo \"{name}\" não está incluído na lista de parâmetros de tipo para \"{container}\"",
        "typeParametersMissing": "Pelo menos um parâmetro de tipo deve ser especificado",
        "typePartiallyUnknown": "O tipo de \"{name}\" é parcialmente desconhecido",
        "typeUnknown": "O tipo de \"{name}\" é desconhecido",
        "typeVarAssignedName": "TypeVar deve ser atribuído a uma variável chamada \"{name}\"",
        "typeVarAssignmentMismatch": "O tipo \"{type}\" não pode ser atribuído à variável de tipo \"{name}\"",
        "typeVarBoundAndConstrained": "TypeVar não pode ser associado e restrito",
        "typeVarBoundGeneric": "O tipo associado TypeVar não pode ser genérico",
        "typeVarConstraintGeneric": "O tipo de restrição TypeVar não pode ser genérico",
        "typeVarDefaultBoundMismatch": "O tipo padrão TypeVar deve ser um subtipo do tipo associado",
        "typeVarDefaultConstraintMismatch": "O tipo padrão TypeVar deve ser um dos tipos restritos",
        "typeVarDefaultIllegal": "Tipos padrão de variável de tipo exigem Python 3.13 ou mais recente",
        "typeVarDefaultInvalidTypeVar": "O parâmetro de tipo \"{name}\" tem um tipo padrão que se refere a uma ou mais variáveis de tipo que estão fora do escopo",
        "typeVarFirstArg": "Nome esperado de TypeVar como primeiro argumento",
        "typeVarNoMember": "TypeVar \"{type}\" não tem membro \"{name}\"",
        "typeVarNotSubscriptable": "Não é possível subscrever TypeVar \"{type}\"",
        "typeVarNotUsedByOuterScope": "A variável de tipo \"{name}\" não tem significado neste contexto",
        "typeVarPossiblyUnsolvable": "A variável de tipo \"{name}\" pode ficar sem resolução se o chamador não fornecer nenhum argumento para o parâmetro \"{param}\"",
        "typeVarScopedToReturnType": "A variável de tipo \"{name}\" tem como escopo um chamador dentro do tipo de retorno e não pode ser referenciada no corpo da função",
        "typeVarSingleConstraint": "TypeVar deve ter pelo menos dois tipos restritos",
        "typeVarTupleConstraints": "TypeVarTuple não pode ter restrições de valor",
        "typeVarTupleContext": "TypeVarTuple não é permitido neste contexto",
        "typeVarTupleDefaultNotUnpacked": "O tipo padrão TypeVarTuple deve ser uma tupla desempacotamento ou TypeVarTuple",
        "typeVarTupleMustBeUnpacked": "O operador Unpack é necessário para o valor TypeVarTuple",
        "typeVarTupleUnknownParam": "\"{name}\" é um parâmetro desconhecido para TypeVarTuple",
        "typeVarUnknownParam": "\"{name}\" é um parâmetro desconhecido para TypeVar",
        "typeVarUsedByOuterScope": "TypeVar \"{name}\" já está em uso por um escopo externo",
        "typeVarUsedOnlyOnce": "TypeVar \"{name}\" aparece apenas uma vez na assinatura de função genérica",
        "typeVarVariance": "TypeVar não pode ser covariante e contravariante",
        "typeVarWithDefaultFollowsVariadic": "O TypeVar \"{typeVarName}\" tem um valor padrão e não pode seguir TypeVarTuple \"{variadicName}\"",
        "typeVarWithoutDefault": "\"{name}\" não pode aparecer após \"{other}\" na lista de parâmetros de tipo porque não tem nenhum tipo padrão",
        "typeVarsNotInGenericOrProtocol": "Generic[] ou Protocol[] deve incluir todas as variáveis de tipo",
        "typedDictAccess": "Não foi possível acessar o item em TypedDict",
        "typedDictAssignedName": "TypedDict deve ser atribuído a uma variável chamada \"{name}\"",
        "typedDictBadVar": "As classes TypedDict podem conter apenas anotações de tipo",
        "typedDictBaseClass": "Todas as classes base para classes TypedDict também devem ser classes TypedDict",
        "typedDictBoolParam": "Esperava-se que o parâmetro \"{name}\" tivesse um valor True ou False",
        "typedDictClosedExtras": "A classe base \"{name}\" é um TypedDict fechado; itens extras devem ser do tipo \"{type}\"",
        "typedDictClosedNoExtras": "A classe base \"{name}\" é um TypedDict fechado; itens extras não são permitidos",
        "typedDictDelete": "Não foi possível excluir o item em TypedDict",
        "typedDictEmptyName": "Os nomes dentro de um TypedDict não podem estar vazios",
        "typedDictEntryName": "Literal de cadeia de caracteres esperado para o nome da entrada do dicionário",
        "typedDictEntryUnique": "Os nomes dentro de um dicionário devem ser exclusivos",
        "typedDictExtraArgs": "Argumentos TypedDict extras são incompatíveis",
        "typedDictFieldNotRequiredRedefinition": "O item TypedDict \"{name}\" não pode ser redefinido como NotRequired",
        "typedDictFieldReadOnlyRedefinition": "O item TypedDict \"{name}\" não pode ser redefinido como ReadOnly",
        "typedDictFieldRequiredRedefinition": "O item TypedDict \"{name}\" não pode ser redefinido como Obrigatório",
        "typedDictFirstArg": "Nome da classe TypedDict esperado como primeiro argumento",
        "typedDictInitsubclassParameter": "TypedDict não dá suporte ao parâmetro __init_subclass__ \"{name}\"",
        "typedDictNotAllowed": "\"TypedDict\" não pode ser usado neste contexto",
        "typedDictSecondArgDict": "Parâmetro dict ou de palavra-chave esperado como segundo parâmetro",
        "typedDictSecondArgDictEntry": "Entrada de dicionário simples esperada",
        "typedDictSet": "Não foi possível atribuir o item em TypedDict",
        "unaccessedClass": "A classe \"{name}\" não foi acessada",
        "unaccessedFunction": "A função \"{name}\" não foi acessada",
        "unaccessedImport": "A importação \"{name}\" não foi acessada",
        "unaccessedSymbol": "\"{name}\" não foi acessado",
        "unaccessedVariable": "A variável \"{name}\" não foi acessada",
        "unannotatedFunctionSkipped": "A análise da função \"{name}\" foi ignorada porque não foi anotada",
        "unaryOperationNotAllowed": "Operador unário não permitido na anotação de tipo",
        "unexpectedAsyncToken": "Esperado \"def\", \"with\" ou \"for\" para acompanhar \"async\"",
        "unexpectedExprToken": "Token inesperado no final da expressão",
        "unexpectedIndent": "Recuo inesperado",
        "unexpectedUnindent": "Recuo não esperado",
        "unhashableDictKey": "A chave do dicionário deve ser hash",
        "unhashableSetEntry": "A entrada set deve ser permitir hash",
        "uninitializedAbstractVariables": "As variáveis definidas na classe base abstrata não são inicializadas na classe final \"{classType}\"",
        "uninitializedInstanceVariable": "A variável de instância \"{name}\" não foi inicializada no corpo da classe ou no método __init__",
        "unionForwardReferenceNotAllowed": "A sintaxe de união não pode ser usada com operando de cadeia de caracteres. Use aspas em toda a expressão",
        "unionSyntaxIllegal": "A sintaxe alternativa para uniões requer o Python 3.10 ou mais recente",
        "unionTypeArgCount": "A união requer dois ou mais argumentos de tipo",
        "unionUnpackedTuple": "A união não pode incluir uma tupla desempacotada",
        "unionUnpackedTypeVarTuple": "A união não pode incluir um TypeVarTuple desempacotado",
        "unnecessaryCast": "Chamada \"cast\" desnecessária. O tipo já é \"{type}\"",
        "unnecessaryIsInstanceAlways": "Chamada de iinstância desnecessária. \"{testType}\" é sempre uma instância de \"{classType}\"",
        "unnecessaryIsSubclassAlways": "Chamada issubclass desnecessária. \"{testType}\" é sempre uma subclasse de \"{classType}\"",
        "unnecessaryPyrightIgnore": "Comentário desnecessário \"# pyright: ignore\"",
        "unnecessaryPyrightIgnoreRule": "Regra desnecessária \"# pyright: ignore\": \"{name}\"",
        "unnecessaryTypeIgnore": "Comentário \"# type: ignore\" desnecessário",
        "unpackArgCount": "Argumento de tipo único esperado após \"Unpack\"",
        "unpackExpectedTypeVarTuple": "TypeVarTuple ou tupla esperado como argumento de tipo para Unpack",
        "unpackExpectedTypedDict": "Argumento de tipo TypedDict esperado para Desempacotar",
        "unpackIllegalInComprehension": "Operação de desempacotamento não permitida na compreensão",
        "unpackInAnnotation": "Operador Desempacotar não permitido na anotação de tipo",
        "unpackInDict": "Operação de desempacotamento não permitida em dicionários",
        "unpackInSet": "Operador unpack não permitido em um conjunto",
        "unpackNotAllowed": "Descompactar não é permitido neste contexto",
        "unpackOperatorNotAllowed": "A operação de descompactação não é permitida neste contexto",
        "unpackTuplesIllegal": "Operação de desempacotamento não permitida em tuplas anteriores ao Python 3.8",
        "unpackedArgInTypeArgument": "Argumentos desempacotamento não podem ser usados em listas de argumentos de tipo",
        "unpackedArgWithVariadicParam": "O argumento desempacotado não pode ser usado para o parâmetro TypeVarTuple",
        "unpackedDictArgumentNotMapping": "A expressão de argumento após ** deve ser um mapeamento com um tipo de chave \"str\"",
        "unpackedDictSubscriptIllegal": "O operador de desempacotamento de dicionário no subscrito não é permitido",
        "unpackedSubscriptIllegal": "O operador Unpack no subscrito requer o Python 3.11 ou mais recente",
        "unpackedTypeVarTupleExpected": "Esperava-se TypeVarTuple desempacotada. Use Unpack[{name1}] ou *{name2}",
        "unpackedTypedDictArgument": "Não é possível corresponder o argumento TypedDict desempacotado aos parâmetros",
        "unreachableCode": "O código está inacessível.",
        "unreachableExcept": "A cláusula Except está inacessível porque a exceção já foi tratada",
        "unsupportedDunderAllOperation": "A operação em \"__all__\" não é compatível, portanto, a lista de símbolos exportada pode estar incorreta",
        "unusedCallResult": "O resultado da expressão de chamada é do tipo \"{type}\" e não é usado. Atribua à variável \"_\" se isso for intencional",
        "unusedCoroutine": "O resultado da chamada de função assíncrona não foi usado. Use \"await\" ou atribua o resultado à variável",
        "unusedExpression": "O valor da expressão não é usado",
        "varAnnotationIllegal": "As anotações de tipo para variáveis exigem Python 3.6 ou mais recente. Use comentário de tipo para compatibilidade com versões anteriores",
        "variableFinalOverride": "A variável \"{name}\" está marcada como Final e substitui a variável não final de mesmo nome na classe \"{className}\"",
        "variadicTypeArgsTooMany": "A lista de argumentos de tipo pode ter no máximo um TypeVarTuple ou tupla descompactado",
        "variadicTypeParamTooManyAlias": "O alias de tipo pode ter no máximo um parâmetro de tipo TypeVarTuple, mas recebeu vários ({names})",
        "variadicTypeParamTooManyClass": "A classe genérica pode ter no máximo um parâmetro de tipo TypeVarTuple, mas recebeu vários ({names})",
        "walrusIllegal": "O operador \":=\" requer o Python 3.8 ou mais recente",
        "walrusNotAllowed": "Operador \":=\" não é permitido neste contexto sem parênteses",
        "wildcardInFunction": "Importação de curinga não permitida em uma classe ou função",
        "wildcardLibraryImport": "Importação de curinga de uma biblioteca não permitida",
        "wildcardPatternTypePartiallyUnknown": "O tipo capturado pelo padrão curinga é parcialmente desconhecido",
        "wildcardPatternTypeUnknown": "O tipo capturado pelo padrão curinga é desconhecido",
        "yieldFromIllegal": "O uso de \"yield from\" requer o Python 3.3 ou mais recente",
        "yieldFromOutsideAsync": "\"yield from\" não é permitido em uma função assíncrona",
        "yieldOutsideFunction": "\"yield\" não permitido fora de uma função ou lambda",
        "yieldWithinListCompr": "\"yield\" não é permitido dentro de uma compreensão de lista",
        "zeroCaseStatementsFound": "A instrução Match deve incluir pelo menos uma instrução case",
        "zeroLengthTupleNotAllowed": "Tupla de comprimento zero não é permitida neste contexto"
    },
    "DiagnosticAddendum": {
        "annotatedNotAllowed": "O formulário especial \"Anotado\" não pode ser usado com verificações de instância e classe",
        "argParam": "O argumento corresponde ao parâmetro \"{paramName}\"",
        "argParamFunction": "O argumento corresponde ao parâmetro \"{paramName}\" na função \"{functionName}\"",
        "argsParamMissing": "O parâmetro \"*{paramName}\" não tem nenhum parâmetro correspondente",
        "argsPositionOnly": "Incompatibilidade de parâmetro somente de posição; esperava-se {expected}, mas recebeu {received}",
        "argumentType": "O tipo de argumento é \"{type}\"",
        "argumentTypes": "Tipos de argumento: ({types})",
        "assignToNone": "O tipo não pode ser atribuído ao tipo \"None\"",
        "asyncHelp": "Você quis dizer \"async with\"?",
        "baseClassIncompatible": "A classe base \"{baseClass}\" é incompatível com o tipo \"{type}\"",
        "baseClassIncompatibleSubclass": "A classe base \"{baseClass}\" deriva de \"{subclass}\" que é incompatível com o tipo \"{type}\"",
        "baseClassOverriddenType": "A classe base \"{baseClass}\" fornece o tipo \"{type}\", que é substituído",
        "baseClassOverridesType": "A classe base \"{baseClass}\" substitui pelo tipo \"{type}\"",
        "bytesTypePromotions": "Defina disableBytesTypePromotions como false para habilitar o comportamento de promoção de tipo para \"bytearray\" e \"memoryview\"",
        "conditionalRequiresBool": "O método __bool__ para o tipo \"{operandType}\" retorna o tipo \"{boolReturnType}\" em vez de \"bool\"",
        "dataClassFieldLocation": "Declaração de campo",
        "dataClassFrozen": "\"{name}\" está congelado",
        "dataProtocolUnsupported": "\"{name}\" é um protocolo de dados",
        "descriptorAccessBindingFailed": "Falha ao associar o método \"{name}\" para a classe de descritor \"{className}\"",
        "descriptorAccessCallFailed": "Falha ao chamar o método \"{name}\" para a classe de descritor \"{className}\"",
        "finalMethod": "Método final",
        "functionParamDefaultMissing": "O parâmetro \"{name}\" não tem um argumento padrão",
        "functionParamName": "Incompatibilidade de nome de parâmetro: \"{destName}\" versus \"{srcName}\"",
        "functionParamPositionOnly": "Incompatibilidade de parâmetro somente posição; o parâmetro \"{name}\" não é somente posição",
        "functionReturnTypeMismatch": "O tipo de retorno de função \"{sourceType}\" é incompatível com o tipo \"{destType}\"",
        "functionTooFewParams": "A função aceita poucos parâmetros posicionais. Esperava-se {expected}, mas recebeu {received}",
        "functionTooManyParams": "A função aceita muitos parâmetros posicionais. Esperava-se {expected}, mas recebeu {received}",
        "genericClassNotAllowed": "Tipo genérico com argumentos de tipo não permitidos para verificações de instância ou de classe",
        "incompatibleDeleter": "O método de exclusão de propriedade é incompatível",
        "incompatibleGetter": "O método getter de propriedade é incompatível",
        "incompatibleSetter": "O método setter de propriedade é incompatível",
        "initMethodLocation": "O método __init__ é definido na classe \"{type}\"",
        "initMethodSignature": "A assinatura de __init__ é \"{type}\"",
        "initSubclassLocation": "O método __init_subclass__ é definido na classe \"{name}\"",
        "invariantSuggestionDict": "Considere alternar de \"dict\" para \"Mapping\", que é covariante no tipo de valor",
        "invariantSuggestionList": "Considere alternar de \"list\" para \"Sequence\", que é covariante",
        "invariantSuggestionSet": "Considere alternar de \"set\" para \"Container\", que é covariante",
        "keyNotRequired": "\"{name}\" não é uma chave necessária em \"{type}\", portanto, o acesso pode resultar em exceção de runtime",
        "keyReadOnly": "\"{name}\" é uma chave somente leitura em \"{type}\"",
        "keyRequiredDeleted": "\"{name}\" é uma chave obrigatória e não pode ser excluída",
        "keyUndefined": "\"{name}\" não é uma chave definida em \"{type}\"",
        "kwargsParamMissing": "O parâmetro \"**{paramName}\" não tem nenhum parâmetro correspondente",
        "listAssignmentMismatch": "O tipo \"{type}\" é incompatível com a lista de destino",
        "literalAssignmentMismatch": "\"{sourceType}\" não pode ser atribuído ao tipo \"{destType}\"",
        "matchIsNotExhaustiveHint": "Se não pretende usar a manipulação exaustiva, adicione \"case _: pass\"",
        "matchIsNotExhaustiveType": "Tipo sem tratamento: \"{type}\"",
        "memberAssignment": "A expressão do tipo \"{type}\" não pode ser atribuída ao membro \"{name}\" da classe \"{classType}\"",
        "memberIsAbstract": "\"{type}.{name}\" não está implementado",
        "memberIsAbstractMore": "e mais {count}...",
        "memberIsClassVarInProtocol": "\"{name}\" é definido como um ClassVar no protocolo",
        "memberIsFinalInProtocol": "\"{name}\" está marcado como Final no protocolo",
        "memberIsInitVar": "O membro \"{name}\" é um campo somente inicialização",
        "memberIsInvariant": "\"{name}\" é invariável porque é mutável",
        "memberIsNotClassVarInClass": "\"{name}\" deve ser definido como um ClassVar para ser compatível com o protocolo",
        "memberIsNotClassVarInProtocol": "\"{name}\" não está definido como um ClassVar no protocolo",
        "memberIsNotFinalInProtocol": "\"{name}\" não está marcado como Final no protocolo",
        "memberIsWritableInProtocol": "\"{name}\" é gravável no protocolo",
        "memberSetClassVar": "O membro \"{name}\" não pode ser atribuído por meio de uma instância de classe porque é um ClassVar",
        "memberTypeMismatch": "\"{name}\" é um tipo incompatível",
        "memberUnknown": "O membro \"{name}\" é desconhecido",
        "metaclassConflict": "A metaclasse \"{metaclass1}\" entra em conflito com \"{metaclass2}\"",
        "missingDeleter": "O método de exclusão de propriedade está ausente",
        "missingGetter": "O método getter da propriedade está ausente",
        "missingSetter": "O método setter da propriedade está ausente",
        "namedParamMissingInDest": "O parâmetro de palavra-chave \"{name}\" está ausente no destino",
        "namedParamMissingInSource": "O parâmetro de palavra-chave \"{name}\" está ausente na origem",
        "namedParamTypeMismatch": "O parâmetro de palavra-chave \"{name}\" do tipo \"{sourceType}\" não pode ser atribuído ao tipo \"{destType}\"",
        "namedTupleNotAllowed": "NamedTuple não pode ser usado para verificações de instância ou de classe",
        "newMethodLocation": "O método __new__ é definido na classe \"{type}\"",
        "newMethodSignature": "A assinatura de__new__ é \"{type}\"",
        "newTypeClassNotAllowed": "A classe criada com NewType não pode ser usada com verificações de instância e classe",
        "noOverloadAssignable": "Nenhuma função sobrecarregada corresponde ao tipo \"{type}\"",
        "noneNotAllowed": "Nenhum não pode ser usado para verificações de instância ou de classe",
        "orPatternMissingName": "Nomes ausentes: {name}",
        "overloadIndex": "Sobrecarga {index} é a correspondência mais próxima",
        "overloadNotAssignable": "Uma ou mais sobrecargas de \"{name}\" não podem ser atribuídas",
        "overloadSignature": "A assinatura de sobrecarga é definida aqui",
        "overriddenMethod": "Método substituído",
        "overriddenSymbol": "Símbolo substituído",
        "overrideInvariantMismatch": "O tipo da substituição \"{overrideType}\" não é o mesmo do tipo básico \"{baseType}\"",
        "overrideIsInvariant": "A variável é mutável, então seu tipo é invariável",
        "overrideNoOverloadMatches": "Nenhuma assinatura de sobrecarga na substituição é compatível com o método base",
        "overrideNotClassMethod": "O método base é declarado como um classmethod, mas a substituição não é",
        "overrideNotInstanceMethod": "O método base é declarado como um método de instância, mas a substituição não é",
        "overrideNotStaticMethod": "O método base é declarado como staticmethod, mas a substituição não é",
        "overrideOverloadNoMatch": "Override não lida com todas as sobrecargas do método base",
        "overrideOverloadOrder": "As sobrecargas para o método de substituição devem estar na mesma ordem que o método base",
        "overrideParamKeywordNoDefault": "Incompatibilidade de parâmetro de palavra-chave \"{name}\": o parâmetro base tem valor de argumento padrão, o parâmetro de substituição não",
        "overrideParamKeywordType": "Incompatibilidade de tipo de parâmetro de palavra-chave \"{name}\": o parâmetro base é do tipo \"{baseType}\", o parâmetro de substituição é do tipo \"{overrideType}\"",
        "overrideParamName": "Incompatibilidade de nome de parâmetro {index}: o parâmetro base é denominado \"{baseName}\", o parâmetro de substituição é denomidado \"{overrideName}\"",
        "overrideParamNameExtra": "O parâmetro \"{name}\" está ausente na base",
        "overrideParamNameMissing": "O parâmetro \"{name}\" está ausente na substituição",
        "overrideParamNamePositionOnly": "Incompatibilidade de parâmetro {index}: o parâmetro base \"{baseName}\" é o parâmetro de palavra-chave, o parâmetro de substituição é somente posição",
        "overrideParamNoDefault": "Parâmetro {index} incompatível: o parâmetro base tem valor de argumento padrão, o parâmetro de substituição não",
        "overrideParamType": "Incompatibilidade de tipo de parâmetro {index}: o parâmetro base é do tipo \"{baseType}\", o parâmetro de substituição é do tipo \"{overrideType}\"",
        "overridePositionalParamCount": "Incompatibilidade de contagem de parâmetros posicionais. O método base tem {baseCount}, mas a substituição tem {overrideCount}",
        "overrideReturnType": "Incompatibilidade de tipo de retorno: o método base retorna o tipo \"{baseType}\", a substituição retorna o tipo \"{overrideType}\"",
        "overrideType": "A classe base define o tipo como \"{type}\"",
        "paramAssignment": "Parâmetro {index}: o tipo \"{sourceType}\" não pode ser atribuído ao tipo \"{destType}\"",
        "paramSpecMissingInOverride": "Os parâmetros ParamSpec estão ausentes no método de substituição",
        "paramType": "O tipo de parâmetro é \"{paramType}\"",
        "privateImportFromPyTypedSource": "Em vez disso, importe de \"{module}\"",
        "propertyAccessFromProtocolClass": "Uma propriedade definida dentro de uma classe de protocolo não pode ser acessada como uma variável de classe",
        "propertyMethodIncompatible": "O método de propriedade \"{name}\" é incompatível",
        "propertyMethodMissing": "O método de propriedade \"{name}\" está ausente na substituição",
        "propertyMissingDeleter": "A propriedade \"{name}\" não tem nenhum excluidor definido",
        "propertyMissingSetter": "A propriedade \"{name}\" não tem um setter definido",
        "protocolIncompatible": "\"{sourceType}\" é incompatível com o protocolo \"{destType}\"",
        "protocolMemberMissing": "\"{name}\" não está presente",
        "protocolRequiresRuntimeCheckable": "A classe do protocolo deve ser @runtime_checkable para ser usada com verificações de instância e de classe",
        "protocolSourceIsNotConcrete": "\"{sourceType}\" não é um tipo de classe concreta e não pode ser atribuído ao tipo \"{destType}\"",
        "protocolUnsafeOverlap": "Os atributos de \"{name}\" têm os mesmos nomes que o protocolo",
        "pyrightCommentIgnoreTip": "Use \"# pyright: ignore[<diagnostic rules>] para suprimir o diagnóstico de uma única linha",
        "readOnlyAttribute": "O atributo \"{name}\" é somente leitura",
        "seeClassDeclaration": "Consulte a declaração de classe",
        "seeDeclaration": "Consulte a declaração",
        "seeFunctionDeclaration": "Ver declaração de função",
        "seeMethodDeclaration": "Consulte a declaração de método",
        "seeParameterDeclaration": "Consulte a declaração de parâmetro",
        "seeTypeAliasDeclaration": "Ver declaração de alias de tipo",
        "seeVariableDeclaration": "Consulte a declaração de variável",
        "tupleAssignmentMismatch": "O tipo \"{type}\" é incompatível com a tupla de destino",
        "tupleEntryTypeMismatch": "A entrada de tupla {entry} é do tipo incorreto",
        "tupleSizeIndeterminateSrc": "Incompatibilidade de tamanho de tupla; esperado {expected} mas recebido indeterminado",
        "tupleSizeIndeterminateSrcDest": "Incompatibilidade de tamanho de tupla; {expected} ou mais esperado, mas indeterminado recebido",
        "tupleSizeMismatch": "Incompatibilidade de tamanho de tupla; esperado {expected} mas recebido {received}",
        "tupleSizeMismatchIndeterminateDest": "Incompatibilidade de tamanho de tupla; {expected} ou mais esperado, mas {received} recebido",
        "typeAliasInstanceCheck": "O alias de tipo criado com a instrução \"type\" não pode ser usado com verificações de instância e de classe",
        "typeAssignmentMismatch": "O tipo \"{sourceType}\" não pode ser atribuído ao tipo \"{destType}\"",
        "typeBound": "O tipo \"{sourceType}\" é incompatível com o tipo associado \"{destType}\" para a variável de tipo \"{name}\"",
        "typeConstrainedTypeVar": "O tipo \"{type}\" é incompatível com a variável de tipo restrita \"{name}\"",
        "typeIncompatible": "\"{sourceType}\" é incompatível com \"{destType}\"",
        "typeNotClass": "\"{type}\" não é uma classe.",
        "typeNotStringLiteral": "\"{type}\" não é um literal de cadeia de caracteres",
        "typeOfSymbol": "O tipo de \"{name}\" é \"{type}\"",
        "typeParamSpec": "O tipo \"{type}\" é incompatível com ParamSpec \"{name}\"",
        "typeUnsupported": "O tipo \"{type}\" é incompatível",
        "typeVarDefaultOutOfScope": "A variável de tipo \"{name}\" não está no escopo",
        "typeVarIsContravariant": "O parâmetro de tipo \"{name}\" é contravariante, mas \"{sourceType}\" não é um supertipo de \"{destType}\"",
        "typeVarIsCovariant": "O parâmetro de tipo \"{name}\" é covariante, mas \"{sourceType}\" não é um subtipo de \"{destType}\"",
        "typeVarIsInvariant": "O parâmetro de tipo \"{name}\" é invariável, mas \"{sourceType}\" não é o mesmo que \"{destType}\"",
        "typeVarNotAllowed": "TypeVar não permitido para verificações de instância ou de classe",
        "typeVarTupleRequiresKnownLength": "TypeVarTuple não pode ser associado a uma tupla de comprimento desconhecido",
        "typeVarUnnecessarySuggestion": "Use {type} em vez disso",
        "typeVarUnsolvableRemedy": "Forneça uma sobrecarga que especifica o tipo de retorno quando o argumento não é fornecido",
        "typeVarsMissing": "Variáveis de tipo ausentes: {names}",
        "typedDictBaseClass": "A classe \"{type}\" não é um TypedDict",
        "typedDictClassNotAllowed": "A classe TypedDict não é permitida para verificações de instância ou classe",
        "typedDictClosedExtraNotAllowed": "Não é possível adicionar o item \"{name}\"",
        "typedDictClosedExtraTypeMismatch": "Não é possível adicionar o item \"{name}\" com o tipo \"{type}\"",
        "typedDictClosedFieldNotRequired": "Não é possível adicionar o item \"{name}\" porque ele deve ser NotRequired",
        "typedDictExtraFieldNotAllowed": "\"{name}\" não está presente em \"{type}\"",
        "typedDictExtraFieldTypeMismatch": "O tipo de \"{name}\" é incompatível com o tipo de \"__extra_items__\" em \"{type}\"",
        "typedDictFieldMissing": "\"{name}\" está ausente de \"{type}\"",
        "typedDictFieldNotReadOnly": "\"{name}\" não é somente leitura em \"{type}\"",
        "typedDictFieldNotRequired": "\"{name}\" não é obrigatório em \"{type}\"",
        "typedDictFieldRequired": "\"{name}\" é necessário em \"{type}\"",
        "typedDictFieldTypeMismatch": "O tipo \"{type}\" não é atribuível ao item \"{name}\"",
        "typedDictFieldUndefined": "\"{name}\" é um item indefinido no tipo \"{type}\"",
        "typedDictFinalMismatch": "\"{sourceType}\" é incompatível com \"{destType}\" devido a uma @final incompatível",
        "typedDictNotAllowed": "TypedDict não pode ser usado para verificações de instância ou de classe",
        "unhashableType": "O tipo \"{type}\" não é pode fazer hash",
        "uninitializedAbstractVariable": "A variável de instância \"{name}\" está definida na classe base abstrata \"{classType}\", mas não foi inicializada",
        "unreachableExcept": "\"{exceptionType}\" é uma subclasse de \"{parentType}\"",
        "useDictInstead": "Use Dict[T1, T2] para indicar um tipo de dicionário",
        "useListInstead": "Use List[T] para indicar um tipo de lista ou Union[T1, T2] para indicar um tipo de união",
        "useTupleInstead": "Use tuple[T1, ..., Tn] para indicar um tipo de tupla ou Union[T1, T2] para indicar um tipo de união",
        "useTypeInstead": "Use Type[T] em vez disso",
        "varianceMismatchForClass": "A variação do argumento de tipo \"{typeVarName}\" é incompatível com a classe base \"{className}\"",
        "varianceMismatchForTypeAlias": "A variação do argumento de tipo \"{typeVarName}\" é incompatível com \"{typeAliasParam}\""
    }
}
