{
    "CodeAction": {
        "createTypeStub": "型スタブの作成",
        "createTypeStubFor": "\"{moduleName}\" の型スタブを作成する",
        "executingCommand": "コマンドの実行中",
        "filesToAnalyzeCount": "分析する {count} 個のファイル",
        "filesToAnalyzeOne": "分析する 1 つのファイル",
        "findingReferences": "参照を検索しています",
        "organizeImports": "インポートを整理",
        "renameShadowedFile": "\"{oldFile}\" の名前を \"{newFile}\" に変更します"
    },
    "Completion": {
        "autoImportDetail": "自動インポート",
        "indexValueDetail": "インデックス値"
    },
    "Diagnostic": {
        "abstractMethodInvocation": "メソッド \"{method}\" は抽象メソッドであり、実装されていないため、呼び出すことができません",
        "annotatedParamCountMismatch": "パラメーター注釈数の不一致: {expected} が必要ですが、{received} を受信しました",
        "annotatedTypeArgMissing": "\"Annotationed\" には 1 つの型引数と 1 つ以上の注釈が必要です",
        "annotationFormatString": "型注釈では、書式指定文字列リテラル (f 文字列) を使用できません",
        "annotationNotSupported": "このステートメントでは型注釈はサポートされていません",
        "annotationSpansStrings": "型注釈を複数の文字列リテラルにまたがることはできません",
        "annotationStringEscape": "型注釈にエスケープ文字を含めることはできません",
        "argAssignment": "型 \"{argType}\" の引数を型 \"{paramType}\" のパラメーターに割り当てることはできません",
        "argAssignmentFunction": "型 \"{argType}\" の引数を関数 \"{functionName}\" の型 \"{paramType}\" のパラメーターに割り当てることはできません",
        "argAssignmentParam": "型 \"{argType}\" の引数を型 \"{paramType}\" のパラメーター \"{paramName}\" に割り当てることはできません",
        "argAssignmentParamFunction": "型 \"{argType}\" の引数を、関数 \"{functionName}\" の型 \"{paramType}\" のパラメーター \"{paramName}\" に割り当てることはできません",
        "argMissingForParam": "パラメーター {name} に引数がありません",
        "argMissingForParams": "パラメーター {names} に引数がありません",
        "argMorePositionalExpectedCount": "さらに {expected} 個の位置引数が必要です",
        "argMorePositionalExpectedOne": "さらに 1 つの位置引数が必要です",
        "argPositional": "必要な位置引数",
        "argPositionalExpectedCount": "{expected} 個の位置引数が必要です",
        "argPositionalExpectedOne": "1 個の位置引数が必要です",
        "argTypePartiallyUnknown": "引数の型が部分的に不明です",
        "argTypeUnknown": "引数の型が不明です",
        "assertAlwaysTrue": "Assert 式は常に true に評価されます",
        "assertTypeArgs": "\"assert_type\" には 2 つの位置引数が必要です",
        "assertTypeTypeMismatch": "\"assert_type\" の不一致: \"{expected}\" が必要ですが、\"{received}\" を受信しました",
        "assignmentExprComprehension": "代入式のターゲット \"{name}\" は、ターゲットの理解と同じ名前を使用できません",
        "assignmentExprContext": "代入式は、モジュール、関数、またはラムダ内に存在する必要があります",
        "assignmentExprInSubscript": "下付き文字内の代入式は、Python 3.10 以降でのみサポートされます",
        "assignmentInProtocol": "Protocol クラス内のインスタンス変数またはクラス変数は、クラス本体内で明示的に宣言する必要があります",
        "assignmentTargetExpr": "式を代入先にすることはできません",
        "asyncNotInAsyncFunction": "非同期関数の外部では \"async\" の使用は許可されていません",
        "awaitIllegal": "\"await\" を使用するには Python 3.5 以降が必要です",
        "awaitNotAllowed": "型の注釈で \"await\" は使用できません",
        "awaitNotInAsync": "\"await\" は非同期関数内でのみ許可されます",
        "backticksIllegal": "バッククォートで囲まれた式は、Python 3.x ではサポートされていません。代わりに repr を使用してください",
        "baseClassCircular": "クラス自体から派生することはできません",
        "baseClassFinal": "基底クラス \"{type}\" は final とマークされており、サブクラス化できません",
        "baseClassIncompatible": "{type} の基底クラスは相互に互換性がありません",
        "baseClassInvalid": "クラスへの引数は基底クラスである必要があります",
        "baseClassMethodTypeIncompatible": "\"{classType}\" の基底クラスは、互換性のない方法でメソッド \"{name}\" を定義します",
        "baseClassUnknown": "基底クラスの型が不明で、派生クラスの型が不明です",
        "baseClassVariableTypeIncompatible": "クラス \"{classType}\" の基底クラスは、互換性のない方法で変数 \"{name}\" を定義します",
        "binaryOperationNotAllowed": "型の注釈で 2 項演算子は使用できません",
        "bindTypeMismatch": "\"{type}\" がパラメーター \"{paramName}\" に割り当てできないため、メソッド \"{methodName}\" をバインドできませんでした",
        "breakOutsideLoop": "\"break\" はループ内でのみ使用できます",
        "callableExtraArgs": "\"Callable\" に必要な型引数は 2 つだけです",
        "callableFirstArg": "パラメーターの型リストまたは \"...\" が必要です。",
        "callableNotInstantiable": "型 \"{type}\" をインスタンス化できません",
        "callableSecondArg": "\"Callable\" の 2 番目の型引数として戻り値の型が必要です",
        "casePatternIsIrrefutable": "参照不可能なパターンは、最後の case ステートメントに対してのみ許可されます",
        "classAlreadySpecialized": "型 \"{type}\" は既に特殊化されています",
        "classDecoratorTypeUnknown": "型指定されていないクラス デコレーターはクラスの型を隠します。デコレーターを無視する",
        "classDefinitionCycle": "\"{name}\" のクラス定義は、それ自体に依存します",
        "classGetItemClsParam": "__class_getitem__ override は \"cls\" パラメーターを受け取る必要があります",
        "classMethodClsParam": "クラス メソッドは \"cls\" パラメーターを受け取る必要があります",
        "classNotRuntimeSubscriptable": "クラス \"{name}\" の添字はランタイム例外を生成します。型の注釈を引用符で囲む",
        "classPatternBuiltInArgPositional": "クラス パターンは位置指定サブパターンのみを受け入れます",
        "classPatternPositionalArgCount": "クラス \"{type}\" の位置指定パターンが多すぎます。{expected} が必要ですが、{received} を受信しました",
        "classPatternTypeAlias": "\"{type}\" は特殊な型エイリアスであるため、クラス パターンでは使用できません",
        "classPropertyDeprecated": "クラス プロパティは Python 3.11 では非推奨であり、Python 3.13 ではサポートされなくなります",
        "classTypeParametersIllegal": "クラス型パラメーターの構文には Python 3.12 以降が必要です",
        "classVarFirstArgMissing": "\"ClassVar\" の後に型引数が必要です",
        "classVarNotAllowed": "\"ClassVar\" はこのコンテキストでは許可されていません",
        "classVarOverridesInstanceVar": "クラス変数 \"{name}\" は、クラス \"{className}\" の同じ名前のインスタンス変数をオーバーライドします",
        "classVarTooManyArgs": "\"ClassVar\" の後に必要な型引数は 1 つだけです",
        "classVarWithTypeVar": "\"ClassVar\" 型に型変数を含めることはできません",
        "clsSelfParamTypeMismatch": "パラメーター \"{name}\" の型は、そのクラス \"{classType}\" のスーパータイプである必要があります",
        "codeTooComplexToAnalyze": "コードが複雑すぎるため、分析できません。サブルーチンにリファクタリングするか、条件付きコード パスを減らすことで複雑さを軽減してください",
        "collectionAliasInstantiation": "型 \"{type}\" はインスタンス化できません。代わりに \"{alias}\" を使用してください",
        "comparisonAlwaysFalse": "型 \"{leftType}\" と \"{rightType}\" に重複がないため、条件は常に False に評価されます",
        "comparisonAlwaysTrue": "型 \"{leftType}\" と \"{rightType}\" に重複がないため、条件は常に True に評価されます",
        "comprehensionInDict": "他の辞書エントリと共に理解することはできません",
        "comprehensionInSet": "他のセット エントリと共に理解を使用することはできません",
        "concatenateContext": "\"Concatenate\" はこのコンテキストで許可されていません",
        "concatenateParamSpecMissing": "\"Concatenate\" の最後の型引数は ParamSpec または \"...\" である必要があります",
        "concatenateTypeArgsMissing": "\"連結\" には少なくとも 2 つの型引数が必要です",
        "conditionalOperandInvalid": "型 \"{type}\" の条件オペランドが無効です",
        "constantRedefinition": "\"{name}\" は定数であり (大文字であるため)、再定義できません",
        "constructorNoArgs": "\"{type}\" コンストラクターに引数が必要ありません",
        "constructorParametersMismatch": "クラス \"{classType}\" の__new__と__init__のシグネチャの不一致",
        "containmentAlwaysFalse": "型 \"{leftType}\" と \"{rightType}\" に重複がないため、式は常に False に評価されます",
        "containmentAlwaysTrue": "型 \"{leftType}\" と \"{rightType}\" に重複がないため、式は常に True に評価されます",
        "continueInFinally": "finally 句内では \"continue\" を使用できません",
        "continueOutsideLoop": "\"continue\" はループ内でのみ使用できます",
        "coroutineInConditionalExpression": "常に True に評価される条件式参照コルーチン",
        "dataClassBaseClassFrozen": "固定されていないクラスは、固定されているクラスから継承できません",
        "dataClassBaseClassNotFrozen": "固定されたクラスは、固定されていないクラスから継承できません",
        "dataClassConverterFunction": "型 \"{argType}\" の引数は、型 \"{fieldType}\" のフィールド \"{fieldName}\" の有効なコンバーターではありません",
        "dataClassConverterOverloads": "{funcName}\" のオーバーロードは、型 \"{fieldType}\" のフィールド \"{fieldName}\" に対して有効なコンバーターではありません",
        "dataClassFieldWithDefault": "既定値のないフィールドは、既定値を持つフィールドの後に表示できません",
        "dataClassFieldWithPrivateName": "データクラス フィールドはプライベート名を使用できません",
        "dataClassFieldWithoutAnnotation": "型注釈のないデータクラス フィールドが原因でランタイム例外が発生する",
        "dataClassPostInitParamCount": "Dataclass __post_init__ パラメーター数が正しくありません。InitVar フィールドの数は {expected} です",
        "dataClassPostInitType": "フィールド \"{fieldName}\" の Dataclass __post_init__ メソッド パラメーターの型が一致しません",
        "dataClassSlotsOverwrite": "__slots__はクラスで既に定義されています",
        "dataClassTransformExpectedBoolLiteral": "静的に True または False に評価される式が必要です",
        "dataClassTransformFieldSpecifier": "クラスまたは関数のタプルが必要ですが、型 \"{type}\" を受け取りました",
        "dataClassTransformPositionalParam": "\"dataclass_transform\" に対するすべての引数はキーワード引数である必要があります",
        "dataClassTransformUnknownArgument": "引数 \"{name}\" はdataclass_transform でサポートされていません",
        "dataProtocolInSubclassCheck": "データ プロトコル (メソッド以外の属性を含む) は、issubclass 呼び出しで使用できません",
        "declaredReturnTypePartiallyUnknown": "宣言された戻り値の型 \"{returnType}\" は部分的に不明です",
        "declaredReturnTypeUnknown": "宣言された戻り値の型が不明です",
        "defaultValueContainsCall": "パラメーターの既定値の式内では、関数呼び出しと変更可能なオブジェクトは許可されません",
        "defaultValueNotAllowed": "\"*\" または \"**\" のパラメーターに既定値を指定することはできません",
        "delTargetExpr": "式を削除できません",
        "deprecatedClass": "クラス \"{name}\" は非推奨です",
        "deprecatedConstructor": "クラス \"{name}\" のコンストラクターは非推奨です",
        "deprecatedDescriptorDeleter": "記述子 \"{name}\" の \"__delete__\" メソッドは非推奨です",
        "deprecatedDescriptorGetter": "記述子 \"{name}\" の \"__get__\" メソッドは非推奨です",
        "deprecatedDescriptorSetter": "記述子 \"{name}\" の \"__set__\" メソッドは非推奨です",
        "deprecatedFunction": "関数 \"{name}\" は非推奨です",
        "deprecatedMethod": "クラス \"{className}\" のメソッド \"{name}\" は非推奨です",
        "deprecatedPropertyDeleter": "プロパティ \"{name}\" の削除子は非推奨です",
        "deprecatedPropertyGetter": "プロパティ \"{name}\" のゲッターは非推奨です",
        "deprecatedPropertySetter": "プロパティ \"{name}\" のセッターは非推奨です",
        "deprecatedType": "この型は Python {version} では非推奨です。代わりに\"{replacement}\"を使用してください",
        "dictExpandIllegalInComprehension": "辞書の展開は理解できません",
        "dictInAnnotation": "辞書式は型注釈では使用できません",
        "dictKeyValuePairs": "辞書エントリにはキー/値のペアが含まれている必要があります",
        "dictUnpackIsNotMapping": "ディクショナリ アンパック演算子に必要なマッピング",
        "dunderAllSymbolNotPresent": "\"{name}\" は __all__ で指定されていますが、モジュールには存在しません",
        "duplicateArgsParam": "許可される \"*\" パラメーターは 1 つだけです",
        "duplicateBaseClass": "重複する基底クラスは許可されていません",
        "duplicateCapturePatternTarget": "Capture ターゲット \"{name}\" を同じパターン内に複数回出現させることはできません",
        "duplicateCatchAll": "許可される catch-all except 句は 1 つだけです",
        "duplicateEnumMember": "列挙型メンバー \"{name}\" は既に宣言されています",
        "duplicateGenericAndProtocolBase": "許可される Generic[...] または Protocol[...] 基底クラスは 1 つだけです",
        "duplicateImport": "\"{importName}\" が複数回インポートされています",
        "duplicateKeywordOnly": "\"*\" 区切り記号を 1 つだけ使用できます",
        "duplicateKwargsParam": "許可される \"**\" パラメーターは 1 つだけです",
        "duplicateParam": "パラメーター \"{name}\" が重複しています",
        "duplicatePositionOnly": "許可される \"/\" パラメーターは 1 つだけです",
        "duplicateStarPattern": "パターン シーケンスで使用できる \"*\" パターンは 1 つだけです",
        "duplicateStarStarPattern": "許可されている \"**\" エントリは 1 つだけです",
        "duplicateUnpack": "リストで許可されているアンパック操作は 1 つだけです",
        "ellipsisAfterUnpacked": "\"...\" はアンパックされた TypeVarTuple または tuple と共に使用することはできません",
        "ellipsisContext": "\"...\" はこのコンテキストでは許可されていません",
        "ellipsisSecondArg": "\"...\" は2 つの引数の 2 番目の引数としてのみ使用できます",
        "enumClassOverride": "列挙型クラス \"{name}\" は最終的なクラスであり、サブクラス化できません",
        "exceptionGroupIncompatible": "例外グループの構文 (\"except*\") には Python 3.11 以降が必要です",
        "exceptionTypeIncorrect": "\"{type}\" は BaseException から派生していません",
        "exceptionTypeNotClass": "\"{type}\" は有効な例外クラスではありません",
        "exceptionTypeNotInstantiable": "例外の種類 \"{type}\" のコンストラクターには 1 つ以上の引数が必要です",
        "expectedAfterDecorator": "デコレーターの後に必要な関数またはクラス宣言",
        "expectedArrow": "\"->\" の後に戻り値の型注釈が続く必要があります",
        "expectedAsAfterException": "例外の種類の後に \"as\" が必要です",
        "expectedAssignRightHandExpr": "\"=\" の右側に式が必要です",
        "expectedBinaryRightHandExpr": "演算子の右側に式が必要です",
        "expectedBoolLiteral": "True または False が必要です",
        "expectedCase": "\"case\" ステートメントが必要です",
        "expectedClassName": "必要なクラス名",
        "expectedCloseBrace": "\"{\" は閉じられていません",
        "expectedCloseBracket": "\"[\" は閉じられていません",
        "expectedCloseParen": "\"(\" が閉じられませんでした",
        "expectedColon": "\":\" が必要です",
        "expectedComplexNumberLiteral": "パターン マッチングに必要な複素数リテラル",
        "expectedDecoratorExpr": "Python 3.9 より前のデコレーターでは、式フォームはサポートされていません",
        "expectedDecoratorName": "デコレーター名が必要です",
        "expectedDecoratorNewline": "デコレーターの末尾に新しい行が必要です",
        "expectedDelExpr": "\"del\" の後に式が必要です",
        "expectedElse": "\"else\" が必要です",
        "expectedEquals": "\"=\" が必要です",
        "expectedExceptionClass": "例外クラスまたはオブジェクトが無効です",
        "expectedExceptionObj": "例外オブジェクト、例外クラス、または None が必要です",
        "expectedExpr": "式が必要です",
        "expectedFunctionAfterAsync": "\"async\" の後に必要な関数定義",
        "expectedFunctionName": "\"def\" の後に関数名が必要です",
        "expectedIdentifier": "必要な識別子",
        "expectedImport": "\"import\" が必要です",
        "expectedImportAlias": "\"as\" の後にシンボルが必要です",
        "expectedImportSymbols": "インポート後に 1 つ以上のシンボル名が必要です",
        "expectedIn": "'in' が必要です",
        "expectedInExpr": "\"in\" の後に式が必要です",
        "expectedIndentedBlock": "インデントされたブロックが必要です",
        "expectedMemberName": "\".\" の後にメンバー名が必要です。",
        "expectedModuleName": "必要なモジュール名",
        "expectedNameAfterAs": "\"as\" の後にシンボル名が必要です",
        "expectedNamedParameter": "キーワード パラメーターは \"*\" の後に続く必要があります",
        "expectedNewline": "改行が必要です",
        "expectedNewlineOrSemicolon": "ステートメントは改行またはセミコロンで区切る必要があります",
        "expectedOpenParen": "\"(\" が必要です",
        "expectedParamName": "必要なパラメーター名",
        "expectedPatternExpr": "必要なパターン式",
        "expectedPatternSubjectExpr": "必要なパターンの件名の式",
        "expectedPatternValue": "\"a.b\" 形式のパターン値式が必要です",
        "expectedReturnExpr": "\"return\" の後に式が必要です",
        "expectedSliceIndex": "インデックスまたはスライス式が必要です",
        "expectedTypeNotString": "必要な型ですが、文字列リテラルを受け取りました",
        "expectedTypeParameterName": "必要な型パラメーター名",
        "expectedYieldExpr": "yield ステートメントで必要な式",
        "finalClassIsAbstract": "クラス \"{type}\" は final とマークされており、すべての抽象なシンボルを実装する必要があります",
        "finalContext": "\"Final\" はこのコンテキストでは許可されていません",
        "finalMethodOverride": "メソッド \"{name}\" は、クラス \"{className}\" で定義されている最終的なメソッドをオーバーライドできません",
        "finalNonMethod": "関数 \"{name}\" はメソッドではないため、@final としてマークできません",
        "finalReassigned": "\"{name}\" は Final として宣言されており、再割り当てできません",
        "finalRedeclaration": "\"{name}\" は以前に Final として宣言されました",
        "finalRedeclarationBySubclass": "親クラス \"{className}\" が Final として宣言しているため、\"{name}\" を再宣言できません",
        "finalTooManyArgs": "\"Final\" の後に 1 つの型引数が必要です",
        "finalUnassigned": "\"{name}\" は Final と宣言されていますが、値は割り当てされていません",
        "formatStringBrace": "f-string リテラル内では、1 つの閉じかっこは使用できません。二重閉じかっこを使用してください",
        "formatStringBytes": "書式指定文字列リテラル (f 文字列) をバイナリにすることはできません",
        "formatStringDebuggingIllegal": "F-string デバッグ指定子 \"=\" には Python 3.8 以降が必要です",
        "formatStringEscape": "Python 3.12 より前の f-string の式部分ではエスケープ シーケンス (バックスラッシュ) は使用できません",
        "formatStringExpectedConversion": "f-string の \"!\" の後に変換指定子が必要です",
        "formatStringIllegal": "書式文字列リテラル (f 文字列) には Python 3.6 以降が必要です",
        "formatStringInPattern": "書式指定文字列はパターンでは使用できません",
        "formatStringNestedFormatSpecifier": "書式指定子内で入れ子になった式が深すぎます",
        "formatStringNestedQuote": "f-string 内で入れ子になった文字列は、Python 3.12 より前の f-string と同じ引用符文字を使用できません",
        "formatStringUnicode": "書式指定文字列リテラル (f 文字列) を Unicode にすることはできません",
        "formatStringUnterminated": "f-string の式が終了していません。\"}\" が必要です",
        "functionDecoratorTypeUnknown": "型指定されていない関数デコレーターは、関数の型を隠します。デコレーターを無視しています",
        "functionInConditionalExpression": "常に True に評価される条件式参照関数",
        "functionTypeParametersIllegal": "関数型パラメーターの構文には Python 3.12 以降が必要です",
        "futureImportLocationNotAllowed": "__future__ からのインポートは、ファイルの先頭にある必要があります",
        "generatorAsyncReturnType": "非同期ジェネレーター関数の戻り値の型は、\"AsyncGenerator[{yieldType}, Any]\" と互換性がある必要があります",
        "generatorNotParenthesized": "ジェネレーター式は、唯一の引数でない場合はかっこで囲む必要があります",
        "generatorSyncReturnType": "ジェネレーター関数の戻り値の型は、\"Generator[{yieldType}, Any, Any]\" と互換性がある必要があります",
        "genericBaseClassNotAllowed": "\"Generic\" 基底クラスを型パラメーター構文と共に使用することはできません",
        "genericClassAssigned": "ジェネリック クラス型を割り当てることはできません",
        "genericClassDeleted": "ジェネリック クラス型を削除できません",
        "genericInstanceVariableAccess": "クラスを介したジェネリック インスタンス変数へのアクセスがあいまいです",
        "genericNotAllowed": "\"Generic\" はこのコンテキストでは無効です",
        "genericTypeAliasBoundTypeVar": "クラス内のジェネリック型エイリアスはバインドされた型変数 {names} を使用できません",
        "genericTypeArgMissing": "\"Generic\" には少なくとも 1 つの型引数が必要です",
        "genericTypeArgTypeVar": "\"Generic\" の型引数は型変数である必要があります",
        "genericTypeArgUnique": "\"Generic\" の型引数は一意である必要があります",
        "globalReassignment": "\"{name}\" はグローバル宣言の前に割り当てられます",
        "globalRedefinition": "\"{name}\" は既にグローバルに宣言されています",
        "implicitStringConcat": "暗黙的な文字列連結は許可されていません",
        "importCycleDetected": "インポート チェーンで循環が検出されました",
        "importDepthExceeded": "インポート チェーンの深さが {depth} を超えました",
        "importResolveFailure": "インポート \"{importName}\" を解決できませんでした",
        "importSourceResolveFailure": "インポート \"{importName}\" をソースから解決できませんでした",
        "importSymbolUnknown": "\"{name}\" は不明なインポート シンボルです",
        "incompatibleMethodOverride": "メソッド \"{name}\" は互換性のない方法でクラス \"{className}\" をオーバーライドします",
        "inconsistentIndent": "元のサイズが前のインデントと一致しません",
        "inconsistentTabs": "インデントでのタブとスペースの一貫性のない使用",
        "initMustReturnNone": "\"__init__\" の戻り値の型は None でなければなりません",
        "initSubclassCallFailed": "__init_subclass__ メソッドのキーワード引数が正しくありません",
        "initSubclassClsParam": "__class_getitem__ override は \"cls\" パラメーターを受け取る必要があります",
        "initVarNotAllowed": "\"InitVar\" はこのコンテキストでは許可されていません",
        "instanceMethodSelfParam": "インスタンス メソッドは \"self\" パラメーターを受け取る必要があります",
        "instanceVarOverridesClassVar": "インスタンス変数 \"{name}\" は、クラス \"{className}\" の同じ名前のクラス変数をオーバーライドします",
        "instantiateAbstract": "抽象クラス \"{type}\" をインスタンス化できません",
        "instantiateProtocol": "プロトコル クラス \"{type}\" をインスタンス化できません",
        "internalBindError": "ファイル \"{file}\" のバインド中に内部エラーが発生しました: {message}",
        "internalParseError": "ファイル \"{file}\" の解析中に内部エラーが発生しました: {message}",
        "internalTypeCheckingError": "ファイル \"{file}\" の種類チェック中に内部エラーが発生しました: {message}",
        "invalidIdentifierChar": "識別子の無効な文字",
        "invalidStubStatement": "ステートメントは型スタブ ファイル内では意味がありません",
        "invalidTokenChars": "トークン内の無効な文字 \"{text}\"",
        "isInstanceInvalidType": "\"isinstance\" の 2 番目の引数は、クラスのクラスまたはタプルである必要があります",
        "isSubclassInvalidType": "\"issubclass\" の 2 番目の引数は、クラスまたはクラスのタプルである必要があります",
        "keyValueInSet": "キー/値のペアはセット内では使用できません",
        "keywordArgInTypeArgument": "キーワード引数は型引数リストでは使用できません",
        "keywordOnlyAfterArgs": "キーワードのみの引数の区切り記号は、\"*\" パラメーターの後には使用できません",
        "keywordParameterMissing": "1 つ以上のキーワード パラメーターが \"*\" パラメーターの後に続く必要があります",
        "keywordSubscriptIllegal": "添字内のキーワード引数はサポートされていません",
        "lambdaReturnTypePartiallyUnknown": "ラムダの戻り値の型、\"{returnType}\" が部分的に不明です",
        "lambdaReturnTypeUnknown": "ラムダの戻り値の型が不明です",
        "listAssignmentMismatch": "型 \"{type}\" の式をターゲット リストに割り当てることはできません",
        "listInAnnotation": "型注釈ではリスト式は使用できません",
        "literalEmptyArgs": "\"Literal\" の後に 1 つ以上の型引数が必要です",
        "literalNotAllowed": "\"Literal\" は、型引数なしでこのコンテキストでは使用できません",
        "literalNotCallable": "リテラル型をインスタンス化できません",
        "literalUnsupportedType": "\"Literal\" の型引数は None、リテラル値 (int、bool、str、または bytes)、または列挙型の値である必要があります",
        "matchIncompatible": "Match ステートメントには Python 3.10 以降が必要です",
        "matchIsNotExhaustive": "match ステートメント内のケースでは、すべての値が完全に処理されるわけではありません",
        "maxParseDepthExceeded": "解析の最大深さを超えました。式を小さい部分式に分割する",
        "memberAccess": "型 \"{type}\" のメンバー \"{name}\" にアクセスできません",
        "memberDelete": "型 \"{type}\" のメンバー \"{name}\" を削除できません",
        "memberSet": "型 \"{type}\" にメンバー \"{name}\" を割り当てることができません",
        "metaclassConflict": "派生クラスのメタクラスは、そのすべての基底クラスのメタクラスのサブクラスである必要があります",
        "metaclassDuplicate": "指定できるメタクラスは 1 つだけです",
        "metaclassIsGeneric": "メタクラスをジェネリックにすることはできません",
        "methodNotDefined": "\"{name}\" メソッドが定義されていません",
        "methodNotDefinedOnType": "型 \"{type}\" に \"{name}\" メソッドが定義されていません",
        "methodOrdering": "一貫性のあるメソッドの順序を作成できません",
        "methodOverridden": "\"{name}\" は、クラス \"{className}\" の同じ名前のメソッドを互換性のない型 \"{type}\" でオーバーライドします",
        "methodReturnsNonObject": "\"{name}\" メソッドはオブジェクトを返しません",
        "missingSuperCall": "メソッド \"{methodName}\" は親クラスで同じ名前のメソッドを呼び出しません",
        "moduleAsType": "モジュールを型として使用することはできません",
        "moduleNotCallable": "モジュールは呼び出し可能ではありません",
        "moduleUnknownMember": "\"{memberName}\" はモジュール \"{moduleName}\" の既知のメンバーではありません",
        "namedExceptAfterCatchAll": "名前付き except 句は、catch-all except 句の後には使用できません",
        "namedParamAfterParamSpecArgs": "ParamSpec args パラメーターの後にキーワード パラメーター \"{name}\" をシグネチャに含めることはできません",
        "namedTupleEmptyName": "名前付きタプル内の名前を空にすることはできません",
        "namedTupleEntryRedeclared": "親クラス \"{className}\" が名前付きタプルであるため、\"{name}\" をオーバーライドできません",
        "namedTupleFirstArg": "最初の引数として名前付きタプル クラス名が必要です",
        "namedTupleMultipleInheritance": "NamedTuple による複数の継承はサポートされていません",
        "namedTupleNameKeyword": "フィールド名をキーワードにすることはできません",
        "namedTupleNameType": "エントリ名と型を指定する 2 エントリタプルが必要です",
        "namedTupleNameUnique": "名前付きタプル内の名前は一意である必要があります",
        "namedTupleNoTypes": "\"namedtuple\" はタプル エントリに型を提供しません。代わりに \"NamedTuple\" を使用してください",
        "namedTupleSecondArg": "2 番目の引数として名前付きタプル エントリ リストが必要です",
        "newClsParam": "__new__ override は \"cls\" パラメーターを受け取る必要があります",
        "newTypeAnyOrUnknown": "NewType の 2 番目の引数は、Any や Unknown ではなく、既知のクラスでなければなりません",
        "newTypeBadName": "NewType の最初の引数は文字列リテラルである必要があります",
        "newTypeLiteral": "NewType はリテラル型では使用できません",
        "newTypeNameMismatch": "NewType は同じ名前の変数に割り当てる必要があります",
        "newTypeNotAClass": "NewType の 2 番目の引数としてクラスが必要です",
        "newTypeParamCount": "NewType には 2 つの位置引数が必要です",
        "newTypeProtocolClass": "NewType は構造型 (プロトコルまたは TypedDict クラス) では使用できません",
        "noOverload": "指定された引数に一致する \"{name}\" のオーバーロードがありません",
        "noReturnContainsReturn": "戻り値の型が \"NoReturn\" として宣言されている関数に return ステートメントを含めることはできません",
        "noReturnContainsYield": "戻り値の型 \"NoReturn\" を宣言した関数に yield ステートメントを含めることはできません",
        "noReturnReturnsNone": "戻り値の型が \"NoReturn\" として宣言されている関数は \"None\" を返すことができません",
        "nonDefaultAfterDefault": "既定以外の引数は既定の引数の後に続きます",
        "nonLocalInModule": "モジュール レベルでは非ローカル宣言は許可されません",
        "nonLocalNoBinding": "非ローカル \"{name}\" のバインドが見つかりません",
        "nonLocalReassignment": "\"{name}\" は非ローカル宣言の前に割り当てられます",
        "nonLocalRedefinition": "\"{name}\" は既に非ローカルとして宣言されています",
        "noneNotCallable": "\"None\" 型のオブジェクトを呼び出すことはできません",
        "noneNotIterable": "型 \"None\" のオブジェクトを反復可能な値として使用することはできません",
        "noneNotSubscriptable": "\"None\" 型のオブジェクトは添字可能ではありません",
        "noneNotUsableWith": "\"None\" 型のオブジェクトを \"with\" と共に使用することはできません",
        "noneOperator": "演算子 \"{operator}\" は \"None\" ではサポートされていません",
        "noneUnknownMember": "\"{name}\" は \"None\" の既知のメンバーではありません",
        "notRequiredArgCount": "\"NotRequired\" の後に 1 つの型引数が必要です",
        "notRequiredNotInTypedDict": "\"NotRequired\" はこのコンテキストでは許可されていません",
        "objectNotCallable": "型 \"{type}\" のオブジェクトは呼び出し可能ではありません",
        "obscuredClassDeclaration": "クラス宣言 \"{name}\" は、同じ名前の宣言によって隠されています",
        "obscuredFunctionDeclaration": "関数宣言 \"{name}\" は、同じ名前の宣言によって隠されています",
        "obscuredMethodDeclaration": "メソッド宣言 \"{name}\" は、同じ名前の宣言によって隠されています",
        "obscuredParameterDeclaration": "パラメーター宣言 \"{name}\" は、同じ名前の宣言によって隠されています",
        "obscuredTypeAliasDeclaration": "型エイリアス宣言 \"{name}\" は、同じ名前の宣言によって隠されています",
        "obscuredVariableDeclaration": "宣言 \"{name}\" は、同じ名前の宣言によって隠されています",
        "operatorLessOrGreaterDeprecated": "演算子 \"<>\" は Python 3 ではサポートされていません。代わりに \"!=\" を使用してください",
        "optionalExtraArgs": "\"Optional\" の後に 1 つの型引数が必要です",
        "orPatternIrrefutable": "参照不可能なパターンは、\"or\" パターンの最後のサブパターンとしてのみ許可されます",
        "orPatternMissingName": "\"or\" パターン内のすべてのサブパターンは、同じ名前をターゲットにする必要があります",
        "overlappingKeywordArgs": "入力された辞書はキーワード パラメーターと重複しています: {names}",
        "overlappingOverload": "パラメーターがオーバーロード {obscuredBy} と重複しているため、\"{name}\" のオーバーロード {obscured} は使用されません",
        "overloadAbstractMismatch": "オーバーロードされたメソッドはすべて抽象である必要があります。",
        "overloadClassMethodInconsistent": "\"{name}\" のオーバーロードでは、@classmethod を不整合に使用します",
        "overloadFinalInconsistencyImpl": "\"{name}\" のオーバーロードは @final としてマークされていますが、実装は @final としてマークされていません",
        "overloadFinalInconsistencyNoImpl": "\"{name}\" のオーバーロード {index} は @final としてマークされていますが、オーバーロード 1 は @final としてマークされていません",
        "overloadImplementationMismatch": "オーバーロードされた実装がオーバーロード {index} のシグネチャと一致しません",
        "overloadReturnTypeMismatch": "\"{name}\" のオーバーロード {prevIndex} はオーバーロード {newIndex} と重複し、互換性のない型を返します",
        "overloadStaticMethodInconsistent": "\"{name}\" のオーバーロードでは、@staticmethod を不整合に使用します",
        "overloadWithoutImplementation": "\"{name}\" はオーバーロードとしてマークされていますが、実装は提供されていません",
        "overriddenMethodNotFound": "メソッド \"{name}\" はオーバーライドとしてマークされていますが、同じ名前の基本メソッドが存在しません",
        "overrideDecoratorMissing": "メソッド \"{name}\" はオーバーライドとしてマークされていませんが、クラス \"{className}\" のメソッドをオーバーライドしています",
        "paramAfterKwargsParam": "パラメーターは \"**\" パラメーターの後に続けることはできません",
        "paramAlreadyAssigned": "パラメーター \"{name}\" は既に割り当て済みです",
        "paramAnnotationMissing": "パラメーター \"{name}\" に型注釈がありません",
        "paramAssignmentMismatch": "型 \"{sourceType}\" の式を型 \"{paramType}\" のパラメーターに割り当てることはできません",
        "paramNameMissing": "\"{name}\" という名前のパラメーターがありません",
        "paramSpecArgsKwargsUsage": "ParamSpec の \"args\" メンバーと \"kwargs\" メンバーの両方が関数シグネチャ内に含まれている必要があります",
        "paramSpecArgsMissing": "ParamSpec \"{type}\" の引数がありません",
        "paramSpecArgsUsage": "ParamSpec の \"args\" メンバーは、*args パラメーターと共に使用する場合にのみ有効です",
        "paramSpecAssignedName": "ParamSpec は 、\"{name}\" という名前の変数に割り当てる必要があります",
        "paramSpecContext": "ParamSpec はこのコンテキストでは許可されていません",
        "paramSpecDefaultNotTuple": "ParamSpec の既定値には、省略記号、タプル式、または ParamSpec が必要です",
        "paramSpecFirstArg": "最初の引数として ParamSpec の名前が必要です",
        "paramSpecKwargsUsage": "ParamSpec の \"kwargs\" メンバーは、**kwargs パラメーターと共に使用する場合にのみ有効です",
        "paramSpecNotUsedByOuterScope": "ParamSpec \"{name}\" はこのコンテキストでは意味がありません",
        "paramSpecScopedToReturnType": "ParamSpec \"{name}\" は、戻り値の型内の呼び出し可能なスコープであり、関数本体では参照できません",
        "paramSpecUnknownArg": "ParamSpec は複数の引数をサポートしていません",
        "paramSpecUnknownMember": "\"{name}\" は ParamSpec の既知のメンバーではありません",
        "paramSpecUnknownParam": "\"{name}\" は ParamSpec に対する不明なパラメーターです",
        "paramTypeCovariant": "共変の型変数はパラメーター型では使用できません",
        "paramTypePartiallyUnknown": "パラメーター \"{paramName}\" の型が部分的に不明です",
        "paramTypeUnknown": "パラメーター \"{paramName}\" の型が不明です",
        "parenthesizedContextManagerIllegal": "\"with\" ステートメント内のかっこには Python 3.9 以降が必要です",
        "patternNeverMatches": "サブジェクトの種類 \"{type}\" のパターンは一致しません",
        "positionArgAfterNamedArg": "キーワード引数の後に位置引数を指定することはできません",
        "positionOnlyAfterArgs": "\"*\" パラメーターの後に位置のみのパラメーターの区切り文字を使用することはできません",
        "positionOnlyAfterKeywordOnly": "\"/\" パラメーターは 、\"*\" パラメーターの前に指定する必要があります",
        "positionOnlyAfterNon": "位置のみのパラメーターの後に位置のみのパラメーターを指定することはできません",
        "positionOnlyFirstParam": "位置のみのパラメーターの区切り記号を最初のパラメーターとして使用することはできません",
        "positionOnlyIncompatible": "位置のみのパラメーターの区切り文字には Python 3.8 以降が必要です",
        "privateImportFromPyTypedModule": "\"{name}\" はモジュール \"{module}\" からエクスポートされていません",
        "privateUsedOutsideOfClass": "\"{name}\" はプライベートであり、宣言されているクラスの外部で使用されます",
        "privateUsedOutsideOfModule": "\"{name}\" はプライベートであり、それが宣言されているモジュールの外部で使用されています",
        "propertyOverridden": "\"{name}\" は、クラス \"{className}\" の同じ名前のプロパティを誤ってオーバーライドします",
        "propertyStaticMethod": "静的メソッドは、プロパティ getter、setter、または deleter では許可されていません",
        "protectedUsedOutsideOfClass": "\"{name}\" は保護され、宣言されているクラスの外部で使用されます",
        "protocolBaseClass": "プロトコル クラス \"{classType}\" は非プロトコル クラス \"{baseType}\" から派生できません",
        "protocolBaseClassWithTypeArgs": "型パラメーター構文を使用する場合、Protocol クラスでは型引数を使用できません",
        "protocolIllegal": "\"Protocol\" を使用するには Python 3.7 以降が必要です",
        "protocolNotAllowed": "\"Protocol\" はこのコンテキストでは使用できません",
        "protocolUnsafeOverlap": "クラスが安全でない方法で \"{name}\" と重複しており、実行時に一致する可能性があります",
        "protocolVarianceContravariant": "ジェネリック プロトコル \"{class}\" で使用される型変数 \"{variable}\" は反変である必要があります",
        "protocolVarianceCovariant": "ジェネリック プロトコル \"{class}\" で使用される型変数 \"{variable}\" は共変である必要があります",
        "protocolVarianceInvariant": "ジェネリック プロトコル \"{class}\" で使用される型変数 \"{variable}\" は不変である必要があります",
        "pyrightCommentInvalidDiagnosticBoolValue": "Pyright コメント ディレクティブの後には \"=\" と値 true または false を指定する必要があります",
        "pyrightCommentInvalidDiagnosticSeverityValue": "Pyright コメント ディレクティブの後に \"=\" を指定し、true、false、エラー、警告、情報、または none の値を指定する必要があります",
        "pyrightCommentMissingDirective": "Pyright コメントの後にはディレクティブ (基本または厳格) または診断規則を指定する必要があります",
        "pyrightCommentNotOnOwnLine": "ファイル レベルの設定を制御するために使用する Pyright コメントは、独自の行に表示する必要があります",
        "pyrightCommentUnknownDiagnosticRule": "\"{rule}\" は、azureight コメントの不明な診断規則です",
        "pyrightCommentUnknownDiagnosticSeverityValue": "\"{value}\" は、pyright コメントに対して無効な値です。true、false、エラー、警告、情報、またはなしが必要です",
        "pyrightCommentUnknownDirective": "\"{directive}\" は、pyright コメントの不明なディレクティブです。\"strict\" または \"basic\" が必要です",
        "readOnlyArgCount": "\"ReadOnly\" の後に 1 つの型引数が必要です",
        "readOnlyNotInTypedDict": "\"ReadOnly\" はこのコンテキストでは許可されていません",
        "recursiveDefinition": "\"{name}\" の型は、それ自体を参照しているため、特定できませんでした",
        "relativeImportNotAllowed": "相対インポートは、\"import .a\" フォームでは使用できません。代わりに \"from . import a\" を使用します。",
        "requiredArgCount": "\"Required\" の後に 1 つの型引数が必要です",
        "requiredNotInTypedDict": "このコンテキストでは\"必須\" は許可されていません",
        "returnInAsyncGenerator": "値を持つ return ステートメントは、非同期ジェネレーターでは使用できません",
        "returnMissing": "戻り値の型が \"{returnType}\" として宣言されている関数は、すべてのコード パスで値を返す必要があります",
        "returnOutsideFunction": "\"return\" は関数内でのみ使用できます",
        "returnTypeContravariant": "反変の型変数は戻り値の型では使用できません",
        "returnTypeMismatch": "型 \"{exprType}\" の式を戻り値の型 \"{returnType}\" に割り当てることはできません",
        "returnTypePartiallyUnknown": "戻り値の型 \"{returnType}\" は部分的に不明です",
        "returnTypeUnknown": "戻り値の型が不明です",
        "revealLocalsArgs": "\"reveal_locals\" 呼び出しに引数が必要ありません",
        "revealLocalsNone": "このスコープにはローカルがありません",
        "revealTypeArgs": "\"reveal_type\" 呼び出しに 1 つの位置引数が必要です",
        "revealTypeExpectedTextArg": "関数 \"reveal_type\" の \"expected_text\" 引数は、str リテラル値である必要があります",
        "revealTypeExpectedTextMismatch": "入力テキストの不一致;\"{expected}\" が必要ですが、\"{received}\" を受信しました",
        "revealTypeExpectedTypeMismatch": "型が一致しません。\"{expected}\" が必要ですが、\"{received}\" を受信しました",
        "selfTypeContext": "\"Self\" はこのコンテキストでは無効です",
        "selfTypeMetaclass": "\"Self\" はメタクラス (\"type\" のサブクラス) 内では使用できません",
        "selfTypeWithTypedSelfOrCls": "\"Self\" は、\"Self\" 以外の型注釈を持つ 'self' または 'cls' パラメーターを持つ関数では使用できません",
        "setterGetterTypeMismatch": "プロパティ セッター値の型は、getter の戻り値の型に割り当てできません",
        "singleOverload": "\"{name}\" はオーバーロードとしてマークされていますが、追加のオーバーロードがありません",
        "slotsAttributeError": "__slots__で \"{name}\" が指定されていません",
        "slotsClassVarConflict": "\"{name}\" が __slots__ で宣言されたインスタンス変数と競合しています",
        "starPatternInAsPattern": "スター パターンを \"as\" ターゲットと共に使用することはできません",
        "starPatternInOrPattern": "スター パターンを他のパターン内で OR 化することはできません",
        "starStarWildcardNotAllowed": "** はワイルドカード \"_\" と共に使用できません",
        "staticClsSelfParam": "静的メソッドに \"self\" または \"cls\" パラメーターを指定することはできません",
        "stdlibModuleOverridden": "\"{path}\" は stdlib モジュール \"{name}\" をオーバーライドしています",
        "stringNonAsciiBytes": "非 ASCII 文字はバイト文字列リテラルでは使用できません",
        "stringNotSubscriptable": "型注釈では文字列式を添字にすることはできません。注釈全体を引用符で囲んでください",
        "stringUnsupportedEscape": "文字列リテラルでサポートされていないエスケープ シーケンス",
        "stringUnterminated": "文字列リテラルが未終了です",
        "stubFileMissing": "\"{importName}\" のスタブ ファイルが見つかりません",
        "stubUsesGetAttr": "スタブ ファイルの種類が不完全です。\"__getattr__\" はモジュールの型エラーを隠します",
        "sublistParamsIncompatible": "Python 3.x ではサブリスト パラメーターはサポートされていません",
        "superCallArgCount": "\"super\" 呼び出しには 2 つ以下の引数が必要です",
        "superCallFirstArg": "\"super\" 呼び出しの最初の引数としてクラス型が必要ですが、\"{type}\" を受け取りました",
        "superCallSecondArg": "\"super\" 呼び出しの 2 番目の引数は、\"{type}\" から派生したオブジェクトまたはクラスである必要があります",
        "superCallZeroArgForm": "\"super\" 呼び出しの 0 引数形式は、メソッド内でのみ有効です",
        "superCallZeroArgFormStaticMethod": "\"super\" 呼び出しの 0 引数形式は、静的メソッド内では有効ではありません",
        "symbolIsPossiblyUnbound": "\"{name}\" はバインドされていない可能性があります",
        "symbolIsUnbound": "\"{name}\" はバインドされていません",
        "symbolIsUndefined": "\"{name}\" が定義されていません",
        "symbolOverridden": "\"{name}\" はクラス \"{className}\" の同じ名前のシンボルをオーバーライドします",
        "ternaryNotAllowed": "型の注釈で 3 項式 は使用できません",
        "totalOrderingMissingMethod": "total_orderingを使用するには、クラスで \"__lt__\"、\"__le__\"、\"__gt__\"、または \"__ge__\" のいずれかを定義する必要があります",
        "trailingCommaInFromImport": "末尾のコンマはかっこで囲まずには使用できません",
        "tryWithoutExcept": "Try ステートメントには、少なくとも 1 つの except 句または finally 句が必要です",
        "tupleAssignmentMismatch": "型 \"{type}\" の式をターゲット タプルに割り当てることはできません",
        "tupleInAnnotation": "タプル式は型注釈では使用できません",
        "tupleIndexOutOfRange": "インデックス {index} が型 {type} の範囲外です",
        "typeAliasIllegalExpressionForm": "型エイリアス定義の式フォームが無効です",
        "typeAliasIsRecursiveDirect": "型エイリアス \"{name}\" は、その定義でそれ自体を使用できません",
        "typeAliasNotInModuleOrClass": "TypeAlias は、モジュールまたはクラススコープ内でのみ定義できます",
        "typeAliasRedeclared": "\"{name}\" は TypeAlias として宣言されており、1 回だけ割り当てることができます",
        "typeAliasStatementBadScope": "type ステートメントは、モジュールまたはクラススコープ内でのみ使用できます",
        "typeAliasStatementIllegal": "型エイリアス ステートメントには Python 3.12 以降が必要です",
        "typeAliasTypeBaseClass": "\"type\" ステートメントで定義された型エイリアスを基底クラスとして使用することはできません",
        "typeAliasTypeMustBeAssigned": "TypeAliasType は、型エイリアスと同じ名前の変数に割り当てる必要があります",
        "typeAliasTypeNameArg": "TypeAliasType の最初の引数は、型エイリアスの名前を表す文字列リテラルである必要があります",
        "typeAliasTypeNameMismatch": "型エイリアスの名前は、それが割り当てられている変数の名前と一致する必要があります",
        "typeAliasTypeParamInvalid": "型パラメーター リストは、TypeVar、TypeVarTuple、または ParamSpec のみを含むタプルである必要があります",
        "typeAnnotationCall": "型式では呼び出し式を使用できません",
        "typeAnnotationVariable": "型式では変数を使用できません",
        "typeAnnotationWithCallable": "\"type\" の型引数はクラスである必要があります。呼び出し可能関数はサポートされていません",
        "typeArgListExpected": "ParamSpec、省略記号、または型の一覧が必要です",
        "typeArgListNotAllowed": "この型引数にはリスト式を使用できません",
        "typeArgsExpectingNone": "クラス \"{name}\" に型引数が必要ありません",
        "typeArgsMismatchOne": "1 つの型引数が必要ですが、{received} を受け取りました",
        "typeArgsMissingForAlias": "ジェネリック型エイリアス \"{name}\" に必要な型引数",
        "typeArgsMissingForClass": "ジェネリック クラス \"{name}\" に必要な型引数",
        "typeArgsTooFew": "\"{name}\" に指定された型引数が少なすぎます。{expected} が必要ですが、{received} を受信しました",
        "typeArgsTooMany": "\"{name}\" に指定された型引数が多すぎます。{expected} が必要ですが、{received} を受信しました",
        "typeAssignmentMismatch": "型 \"{sourceType}\" の式を宣言された型 \"{destType}\" に割り当てることはできません",
        "typeAssignmentMismatchWildcard": "宣言された型 \"{destType}\" に割り当てできないシンボル \"{name}\" のインポートに型 \"{sourceType}\" があります",
        "typeCallNotAllowed": "type() 呼び出しは型注釈で使用しないでください",
        "typeCheckOnly": "\"{name}\" は@type_check_onlyとしてマークされており、型注釈でのみ使用できます",
        "typeCommentDeprecated": "型コメントの使用は非推奨です。代わりに型注釈を使用してください",
        "typeExpectedClass": "型式が必要ですが、\"{type}\" を受け取りました",
        "typeGuardArgCount": "\"TypeGuard\" または \"TypeIs\" の後に 1 つの型引数が必要です",
        "typeGuardParamCount": "ユーザー定義型ガード関数とメソッドには、少なくとも 1 つの入力パラメーターが必要です",
        "typeIsReturnType": "TypeIs の戻り値の型 (\"{returnType}\") と値パラメーターの型 (\"{type}\") が一致しません",
        "typeNotAwaitable": "\"{type}\" は待機できません",
        "typeNotIntantiable": "\"{type}\" をインスタンス化できません",
        "typeNotIterable": "\"{type}\" は反復できません",
        "typeNotSpecializable": "型 \"{type}\" を特殊化できませんでした",
        "typeNotSubscriptable": "型 \"{type}\" のオブジェクトは添字可能ではありません",
        "typeNotSupportBinaryOperator": "演算子 \"{operator}\" は型 \"{leftType}\" と \"{rightType}\" ではサポートされていません",
        "typeNotSupportBinaryOperatorBidirectional": "型 \"{leftType}\" と \"{rightType}\" に対して演算子 \"{operator}\" はサポートされていません。予期された型が \"{expectedType}\" の場合",
        "typeNotSupportUnaryOperator": "演算子 \"{operator}\" は型 \"{type}\" ではサポートされていません",
        "typeNotSupportUnaryOperatorBidirectional": "型 \"{type}\" が \"{expectedType}\" の場合、演算子 \"{operator}\" はサポートされていません",
        "typeNotUsableWith": "型 \"{type}\" のオブジェクトは 、{method} を実装していないため、\"with\" と共に使用できません",
        "typeParameterBoundNotAllowed": "バインドまたは制約を可変個引数型パラメーターまたは ParamSpec と共に使用することはできません",
        "typeParameterConstraintTuple": "型パラメーター制約は、2 つ以上の型のタプルである必要があります",
        "typeParameterExistingTypeParameter": "型パラメーター \"{name}\" は既に使用されています",
        "typeParameterNotDeclared": "型パラメーター \"{name}\" は、\"{container}\" の型パラメーターリストに含まれていません",
        "typeParametersMissing": "少なくとも 1 つの型パラメーターを指定する必要があります",
        "typePartiallyUnknown": "\"{name}\" の種類が部分的に不明です",
        "typeUnknown": "\"{name}\" の種類が不明です",
        "typeVarAssignedName": "TypeVar は 、\"{name}\" という名前の変数に割り当てる必要があります",
        "typeVarAssignmentMismatch": "型 \"{type}\" を型変数 \"{name}\" に割り当てることはできません",
        "typeVarBoundAndConstrained": "TypeVar をバインドと制約の両方にすることはできません",
        "typeVarBoundGeneric": "TypeVar バインド型をジェネリックにすることはできません",
        "typeVarConstraintGeneric": "TypeVar 制約型をジェネリックにすることはできません",
        "typeVarDefaultBoundMismatch": "TypeVar の既定の型はバインドされた型のサブタイプである必要があります",
        "typeVarDefaultConstraintMismatch": "TypeVar の既定の型は、制約付き型のいずれかである必要があります",
        "typeVarDefaultIllegal": "型変数の既定の型には Python 3.13 以降が必要です",
        "typeVarDefaultInvalidTypeVar": "型パラメーター \"{name}\" には、スコープ外の 1 つ以上の型変数を参照する既定の型があります",
        "typeVarFirstArg": "最初の引数として TypeVar の名前が必要です",
        "typeVarNoMember": "TypeVar \"{type}\" にはメンバー \"{name}\" がありません",
        "typeVarNotSubscriptable": "TypeVar \"{type}\" は添字可能ではありません",
        "typeVarNotUsedByOuterScope": "型変数 \"{name}\" は、このコンテキストでは意味がありません",
        "typeVarPossiblyUnsolvable": "呼び出し元がパラメーター \"{param}\" に引数を指定しない場合、型変数 \"{name}\" は解決されない可能性があります",
        "typeVarScopedToReturnType": "型変数 \"{name}\" のスコープは戻り値の型内の呼び出し可能な変数であり、関数本体では参照できません",
        "typeVarSingleConstraint": "TypeVar には少なくとも 2 つの制約付き型が必要です",
        "typeVarTupleConstraints": "TypeVarTuple に値制約を持たせることはできません",
        "typeVarTupleContext": "TypeVarTuple はこのコンテキストでは許可されていません",
        "typeVarTupleDefaultNotUnpacked": "TypeVarTuple の既定の型は、アンパックされたタプルまたは TypeVarTuple である必要があります",
        "typeVarTupleMustBeUnpacked": "TypeVarTuple 値にはアンパック演算子が必要です",
        "typeVarTupleUnknownParam": "\"{name}\" は TypeVarTuple に対する不明なパラメーターです",
        "typeVarUnknownParam": "\"{name}\" は TypeVar に対する不明なパラメーターです",
        "typeVarUsedByOuterScope": "TypeVar \"{name}\" は外部スコープで既に使用されています",
        "typeVarUsedOnlyOnce": "TypeVar \"{name}\" はジェネリック関数シグネチャに 1 回だけ出現します",
        "typeVarVariance": "TypeVar を共変と反変の両方にすることはできません",
        "typeVarWithDefaultFollowsVariadic": "TypeVar \"{typeVarName}\" には既定値があり、TypeVarTuple \"{variadicName}\" の後に続けることはできません",
        "typeVarWithoutDefault": "\"{name}\" は既定の型がないため、型パラメーター リストの \"{other}\" の後に表示できません",
        "typeVarsNotInGenericOrProtocol": "Generic[] または Protocol[] には、すべての型変数を含める必要があります",
        "typedDictAccess": "TypedDict の項目にアクセスできませんでした",
        "typedDictAssignedName": "TypedDict は \"{name}\" という名前の変数に割り当てる必要があります",
        "typedDictBadVar": "TypedDict クラスには型注釈のみを含めることができます",
        "typedDictBaseClass": "TypedDict クラスのすべての基底クラスも TypedDict クラスである必要があります",
        "typedDictBoolParam": "\"{name}\" パラメーターの値は True または False である必要があります",
        "typedDictClosedExtras": "基底クラス \"{name}\" は終了した TypedDict です。余分な項目は型 \"{type}\" である必要があります",
        "typedDictClosedNoExtras": "基底クラス \"{name}\" は終了した TypedDict です。追加のアイテムは許可されていません",
        "typedDictDelete": "TypedDict の項目を削除できませんでした",
        "typedDictEmptyName": "TypedDict 内の名前を空にすることはできません",
        "typedDictEntryName": "辞書エントリ名に文字列リテラルが必要です",
        "typedDictEntryUnique": "ディクショナリ内の名前は一意である必要があります",
        "typedDictExtraArgs": "追加の TypedDict 引数はサポートされていません",
        "typedDictFieldNotRequiredRedefinition": "TypedDict アイテム \"{name}\" を NotRequired として再定義することはできません",
        "typedDictFieldReadOnlyRedefinition": "TypedDict アイテム \"{name}\" を ReadOnly として再定義することはできません",
        "typedDictFieldRequiredRedefinition": "TypedDict アイテム \"{name}\" を Required として再定義することはできません",
        "typedDictFirstArg": "最初の引数として TypedDict クラス名が必要です",
        "typedDictInitsubclassParameter": "TypedDict は __init_subclass__パラメーター \"{name}\" をサポートしていません",
        "typedDictNotAllowed": "\"TypedDict\" はこのコンテキストでは使用できません",
        "typedDictSecondArgDict": "2 番目のパラメーターとして dict パラメーターまたはキーワード パラメーターが必要です",
        "typedDictSecondArgDictEntry": "単純な辞書エントリが必要です",
        "typedDictSet": "TypedDict で項目を割り当てることができませんでした",
        "unaccessedClass": "クラス \"{name}\" にアクセスできません",
        "unaccessedFunction": "関数 \"{name}\" にアクセスできません",
        "unaccessedImport": "インポート \"{name}\" にアクセスできません",
        "unaccessedSymbol": "\"{name}\" にアクセスできません",
        "unaccessedVariable": "変数 \"{name}\" にアクセスできません",
        "unannotatedFunctionSkipped": "関数 \"{name}\" の分析は、表示されないためスキップされます",
        "unaryOperationNotAllowed": "型の注釈で単項演算子は使用できません",
        "unexpectedAsyncToken": "\"def\"、\"with\"、または \"for\" が \"async\" の後に続く必要があります",
        "unexpectedExprToken": "式の最後に予期しないトークンが含まれています",
        "unexpectedIndent": "予期しないインデント",
        "unexpectedUnindent": "インデント解除は予期されていません",
        "unhashableDictKey": "辞書キーはハッシュ可能である必要があります",
        "unhashableSetEntry": "設定エントリはハッシュ可能である必要があります",
        "uninitializedAbstractVariables": "抽象基底クラスで定義された変数は、最終クラス \"{classType}\" で初期化されません",
        "uninitializedInstanceVariable": "インスタンス変数 \"{name}\" は、クラス本体または__init__ メソッドで初期化されていません",
        "unionForwardReferenceNotAllowed": "共用体構文を文字列オペランドと共に使用することはできません。式全体を引用符で囲んでください",
        "unionSyntaxIllegal": "共用体の代替構文には Python 3.10 以降が必要です",
        "unionTypeArgCount": "共用体には 2 つ以上の型引数が必要です",
        "unionUnpackedTuple": "アンパックされたタプルを union に含めることはできません",
        "unionUnpackedTypeVarTuple": "アンパックされた TypeVarTuple を union に含めることはできません",
        "unnecessaryCast": "不要な \"キャスト\" 呼び出し。型は既に \"{type}\" です",
        "unnecessaryIsInstanceAlways": "不要な isinstance 呼び出し。\"{testType}\" は常に \"{classType}\" のインスタンスです",
        "unnecessaryIsSubclassAlways": "不要な issubclass 呼び出し。\"{testType}\" は常に \"{classType}\" のサブクラスです",
        "unnecessaryPyrightIgnore": "不要な \"#ight: ignore\" コメント",
        "unnecessaryPyrightIgnoreRule": "不要な \"# pyright: ignore\" ルール: \"{name}\"",
        "unnecessaryTypeIgnore": "不要な \"# type: ignore\" コメント",
        "unpackArgCount": "\"Unpack\" の後に 1 つの型引数が必要です",
        "unpackExpectedTypeVarTuple": "Unpack の型引数として TypeVarTuple または tuple が必要です",
        "unpackExpectedTypedDict": "Unpack に必要な TypedDict 型引数",
        "unpackIllegalInComprehension": "アンパック操作は理解できません",
        "unpackInAnnotation": "型注釈ではアンパック演算子は使用できません",
        "unpackInDict": "アンパック操作はディクショナリで許可されていません",
        "unpackInSet": "アンパック演算子はセット内では使用できません",
        "unpackNotAllowed": "アンパックはこのコンテキストでは許可されていません",
        "unpackOperatorNotAllowed": "このコンテキストではアンパック操作は許可されていません",
        "unpackTuplesIllegal": "Python 3.8 より前のタプルではアンパック操作は許可されていません",
        "unpackedArgInTypeArgument": "アンパックされた引数は、型引数リストでは使用できません",
        "unpackedArgWithVariadicParam": "アンパックされた引数は TypeVarTuple パラメーターには使用できません",
        "unpackedDictArgumentNotMapping": "** の後の引数式は、\"str\" キー型のマッピングである必要があります",
        "unpackedDictSubscriptIllegal": "下付き文字の辞書アンパック演算子は使用できません",
        "unpackedSubscriptIllegal": "下付き文字の Unpack 演算子には Python 3.11 以降が必要です",
        "unpackedTypeVarTupleExpected": "アンパックされた TypeVarTuple が必要です。Unpack[{name1}] または *{name2} を使用してください",
        "unpackedTypedDictArgument": "アンパックされた TypedDict 引数をパラメーターと一致させることはできません",
        "unreachableCode": "コードに到達できません",
        "unreachableExcept": "例外が既に処理されているため、Except 句に到達できません",
        "unsupportedDunderAllOperation": "\"__all__\" に対する操作はサポートされていないため、エクスポートされたシンボル リストが正しくない可能性があります",
        "unusedCallResult": "呼び出し式の結果は \"{type}\" 型であり、使用されません。これが意図的な場合は変数 \"_\" に代入する",
        "unusedCoroutine": "非同期関数呼び出しの結果は使用されません。\"await\" を使用するか、結果を変数に代入してください",
        "unusedExpression": "式の値が使用されていません",
        "varAnnotationIllegal": "変数の型注釈には Python 3.6 以降が必要です。以前のバージョンとの互換性のために型コメントを使用する",
        "variableFinalOverride": "変数 \"{name}\" は Final とマークされ、クラス \"{className}\" の同じ名前の Final 以外の変数をオーバーライドします",
        "variadicTypeArgsTooMany": "型引数リストには、アンパックされた TypeVarTuple または tuple を最大 1 つ含めることができます",
        "variadicTypeParamTooManyAlias": "型エイリアスには TypeVarTuple 型パラメーターを最大 1 つ含めることができますが、複数の ({names}) を受け取りました",
        "variadicTypeParamTooManyClass": "ジェネリック クラスには最大 1 つの TypeVarTuple 型パラメーターを指定できますが、複数の ({names}) を受け取りました",
        "walrusIllegal": "演算子 \":=\" には Python 3.8 以降が必要です",
        "walrusNotAllowed": "演算子 \":=\" は、かっこを囲まないこのコンテキストでは使用できません",
        "wildcardInFunction": "ワイルドカードのインポートは、クラスまたは関数内では許可されていません",
        "wildcardLibraryImport": "ライブラリからのワイルドカードインポートは許可されていません",
        "wildcardPatternTypePartiallyUnknown": "ワイルドカード パターンによってキャプチャされた型は部分的に不明です",
        "wildcardPatternTypeUnknown": "ワイルドカード パターンによってキャプチャされた型が不明です",
        "yieldFromIllegal": "\"yield from\" を使用するには Python 3.3 以降が必要です",
        "yieldFromOutsideAsync": "非同期関数では \"yield from\" は使用できません",
        "yieldOutsideFunction": "関数またはラムダの外部では \"yield\" は許可されません",
        "yieldWithinListCompr": "\"yield\" はリスト理解内では使用できません",
        "zeroCaseStatementsFound": "Match ステートメントには、少なくとも 1 つの case ステートメントを含める必要があります",
        "zeroLengthTupleNotAllowed": "このコンテキストでは長さ 0 のタプルは使用できません"
    },
    "DiagnosticAddendum": {
        "annotatedNotAllowed": "\"注釈付き\" 特殊フォームは、インスタンスおよびクラスのチェックでは使用できません",
        "argParam": "引数はパラメーター \"{paramName}\" に対応します",
        "argParamFunction": "引数は関数 \"{functionName}\" のパラメーター \"{paramName}\" に対応します",
        "argsParamMissing": "パラメーター \"*{paramName}\" に対応するパラメーターがありません",
        "argsPositionOnly": "位置のみのパラメーターの不一致。{expected} が必要ですが、{received} を受信しました",
        "argumentType": "引数の型は \"{type}\" です",
        "argumentTypes": "引数の型: ({types})",
        "assignToNone": "型を \"None\" 型に割り当てることはできません",
        "asyncHelp": "\"async with\" を意味しましたか?",
        "baseClassIncompatible": "基底クラス \"{baseClass}\" は型 \"{type}\" と互換性がありません",
        "baseClassIncompatibleSubclass": "基底クラス \"{baseClass}\" は、型 \"{type}\" と互換性のない \"{subclass}\" から派生しています",
        "baseClassOverriddenType": "基底クラス \"{baseClass}\" は、オーバーライドされる型 \"{type}\" を提供します",
        "baseClassOverridesType": "基底クラス \"{baseClass}\" は型 \"{type}\" でオーバーライドします",
        "bytesTypePromotions": "disableBytesTypePromotions を false に設定して、\"bytearray\" と \"memoryview\" の型昇格動作を有効にします",
        "conditionalRequiresBool": "型 \"{operandType}\" のメソッド __bool__は、\"bool\" ではなく型 \"{boolReturnType}\" を返します",
        "dataClassFieldLocation": "フィールド宣言",
        "dataClassFrozen": "\"{name}\" は固定されています",
        "dataProtocolUnsupported": "\"{name}\" はデータ プロトコルです",
        "descriptorAccessBindingFailed": "記述子クラス \"{className}\" のメソッド \"{name}\" をバインドできませんでした",
        "descriptorAccessCallFailed": "記述子クラス \"{className}\" のメソッド \"{name}\" を呼び出せませんでした",
        "finalMethod": "最終的なメソッド",
        "functionParamDefaultMissing": "パラメーター \"{name}\" に既定の引数がありません",
        "functionParamName": "パラメーター名の不一致: \"{destName}\" と \"{srcName}\"",
        "functionParamPositionOnly": "位置のみのパラメーターの不一致; パラメーター \"{name}\" は位置のみではありません",
        "functionReturnTypeMismatch": "関数の戻り値の型 \"{sourceType}\" は型 \"{destType}\" と互換性がありません",
        "functionTooFewParams": "関数が受け入れる位置指定パラメーターが少なすぎます。{expected} が必要ですが、{received} を受信しました",
        "functionTooManyParams": "関数が受け入れる位置指定パラメーターが多すぎます。{expected} が必要ですが、{received} を受信しました",
        "genericClassNotAllowed": "インスタンスまたはクラスのチェックでは、型引数を含むジェネリック型は使用できません",
        "incompatibleDeleter": "プロパティ削除子メソッドに互換性がありません",
        "incompatibleGetter": "プロパティ getter メソッドに互換性がありません",
        "incompatibleSetter": "プロパティ セッター メソッドに互換性がありません",
        "initMethodLocation": "__init__ メソッドはクラス \"{type}\" で定義されています",
        "initMethodSignature": "__init__の署名は \"{type}\" です",
        "initSubclassLocation": "__init_subclass__ メソッドはクラス \"{name}\" で定義されています",
        "invariantSuggestionDict": "\"dict\" から値の型の共変である \"Mapping\" への切り替えを検討してください",
        "invariantSuggestionList": "\"list\" から共変である \"Sequence\" への切り替えを検討してください",
        "invariantSuggestionSet": "\"set\" から共変である \"Container\" への切り替えを検討してください",
        "keyNotRequired": "\"{name}\" は \"{type}\" の必須キーではないため、アクセスすると実行時例外が発生する可能性があります",
        "keyReadOnly": "\"{name}\" は \"{type}\" の読み取り専用キーです",
        "keyRequiredDeleted": "\"{name}\" は必須キーであり、削除できません",
        "keyUndefined": "\"{name}\" は \"{type}\" で定義されたキーではありません",
        "kwargsParamMissing": "パラメーター \"**{paramName}\" に対応するパラメーターがありません",
        "listAssignmentMismatch": "型 \"{type}\" はターゲット リストと互換性がありません",
        "literalAssignmentMismatch": "\"{sourceType}\" を型 \"{destType}\" に割り当てることはできません",
        "matchIsNotExhaustiveHint": "完全な処理が意図されていない場合は、\"case _: pass\" を追加します",
        "matchIsNotExhaustiveType": "ハンドルされない型: \"{type}\"",
        "memberAssignment": "型 \"{type}\" の式をクラス \"{classType}\" のメンバー \"{name}\" に割り当てることはできません",
        "memberIsAbstract": "\"{type}.{name}\" は実装されていません",
        "memberIsAbstractMore": "その他 {count} 件...",
        "memberIsClassVarInProtocol": "\"{name}\" はプロトコルで ClassVar として定義されています",
        "memberIsFinalInProtocol": "\"{name}\" はプロトコルで Final とマークされています",
        "memberIsInitVar": "メンバー \"{name}\" は init 専用フィールドです",
        "memberIsInvariant": "\"{name}\" は変更可能であるため、不変です",
        "memberIsNotClassVarInClass": "プロトコルと互換性を持たせるには、\"{name}\" を ClassVar として定義する必要があります",
        "memberIsNotClassVarInProtocol": "\"{name}\" はプロトコルで ClassVar として定義されていません",
        "memberIsNotFinalInProtocol": "\"{name}\" はプロトコルで Final としてマークされていません",
        "memberIsWritableInProtocol": "\"{name}\" はプロトコルで書き込み可能です",
        "memberSetClassVar": "メンバー \"{name}\" は ClassVar であるため、クラス インスタンスを介して割り当てることはできません",
        "memberTypeMismatch": "\"{name}\" は互換性のない型です",
        "memberUnknown": "メンバー \"{name}\" が不明です",
        "metaclassConflict": "メタクラス \"{metaclass1}\" が \"{metaclass2}\" と競合しています",
        "missingDeleter": "プロパティ削除メソッドがありません",
        "missingGetter": "プロパティ getter メソッドがありません",
        "missingSetter": "プロパティ セッター メソッドがありません",
        "namedParamMissingInDest": "キーワード パラメーター \"{name}\" が変換先に見つかりません",
        "namedParamMissingInSource": "キーワード パラメーター \"{name}\" がソースに見つかりません",
        "namedParamTypeMismatch": "型 \"{sourceType}\" のキーワード パラメーター \"{name}\" を型 \"{destType}\" に割り当てることはできません",
        "namedTupleNotAllowed": "NamedTuple はインスタンスまたはクラスのチェックには使用できません",
        "newMethodLocation": "__new__ メソッドはクラス \"{type}\" で定義されています",
        "newMethodSignature": "__new__の署名は \"{type}\" です",
        "newTypeClassNotAllowed": "NewType で作成されたクラスは、インスタンスおよびクラスのチェックでは使用できません",
        "noOverloadAssignable": "型 \"{type}\" に一致するオーバーロードされた関数はありません",
        "noneNotAllowed": "インスタンスまたはクラスのチェックには何も使用できません",
        "orPatternMissingName": "名前がありません: {name}",
        "overloadIndex": "オーバーロード {index} が最も近い一致です",
        "overloadNotAssignable": "\"{name}\" の 1 つ以上のオーバーロードが割り当て可能ではありません",
        "overloadSignature": "オーバーロードシグネチャはここで定義されています",
        "overriddenMethod": "オーバーライドされたメソッド",
        "overriddenSymbol": "オーバーライドされたシンボル",
        "overrideInvariantMismatch": "オーバーライドの型 \"{overrideType}\" が基本データ型 \"{baseType}\" と同じではありません",
        "overrideIsInvariant": "変数は変更可能であるため、その型は不変です",
        "overrideNoOverloadMatches": "オーバーライドのオーバーロード シグネチャが基本メソッドと互換性がありません",
        "overrideNotClassMethod": "基本メソッドは classmethod として宣言されていますが、オーバーライドはされていません",
        "overrideNotInstanceMethod": "基本メソッドはインスタンス メソッドとして宣言されていますが、オーバーライドは宣言されていません",
        "overrideNotStaticMethod": "基本メソッドは staticmethod として宣言されていますが、オーバーライドは宣言されていません",
        "overrideOverloadNoMatch": "オーバーライドは基本メソッドのすべてのオーバーロードを処理しません",
        "overrideOverloadOrder": "オーバーライド メソッドのオーバーロードは、基本メソッドと同じ順序にする必要があります",
        "overrideParamKeywordNoDefault": "キーワード パラメーター \"{name}\" の不一致: 基本パラメーターに既定の引数値があり、オーバーライド パラメーターにはありません",
        "overrideParamKeywordType": "キーワード パラメーター \"{name}\" の型が一致しません: 基本パラメーターは型 \"{baseType}\"、オーバーライド パラメーターは型 \"{overrideType}\" です",
        "overrideParamName": "パラメーター {index} 名が一致しません: ベース パラメーターの名前は \"{baseName}\"、オーバーライド パラメーターは \"{overrideName}\" です",
        "overrideParamNameExtra": "パラメーター \"{name}\" が ベース に見つかりません",
        "overrideParamNameMissing": "パラメーター \"{name}\" がオーバーライドに見つかりません",
        "overrideParamNamePositionOnly": "パラメーター {index} の不一致: ベース パラメーター \"{baseName}\" はキーワード パラメーターで、オーバーライド パラメーターは位置のみです",
        "overrideParamNoDefault": "パラメーター {index} の不一致: 基本パラメーターに既定の引数値があり、オーバーライド パラメーターが指定されていません",
        "overrideParamType": "パラメーター {index} の型が一致しません: 基本パラメーターは型 \"{baseType}\"、オーバーライド パラメーターは型 \"{overrideType}\" です",
        "overridePositionalParamCount": "位置指定パラメーター数が一致しません。基本メソッドには {baseCount} がありますが、オーバーライドには {overrideCount} があります",
        "overrideReturnType": "戻り値の型の不一致: 基本メソッドは型 \"{baseType}\" を返し、オーバーライドは型 \"{overrideType}\" を返します",
        "overrideType": "基底クラスは型を \"{type}\" として定義します",
        "paramAssignment": "パラメーター {index}: 型 \"{sourceType}\" を型 \"{destType}\" に割り当てることはできません",
        "paramSpecMissingInOverride": "ParamSpec パラメーターが override メソッドに見つかりません",
        "paramType": "パラメーターの型は \"{paramType}\" です",
        "privateImportFromPyTypedSource": "代わりに \"{module}\" からインポートする",
        "propertyAccessFromProtocolClass": "プロトコル クラス内で定義されたプロパティにクラス変数としてアクセスできない",
        "propertyMethodIncompatible": "プロパティ メソッド \"{name}\" は互換性がありません",
        "propertyMethodMissing": "プロパティ メソッド \"{name}\" がオーバーライドに見つかりません",
        "propertyMissingDeleter": "プロパティ \"{name}\" に定義済みの削除子がありません",
        "propertyMissingSetter": "プロパティ \"{name}\" に定義済みのセッターがありません",
        "protocolIncompatible": "\"{sourceType}\" はプロトコル \"{destType}\" と互換性がありません",
        "protocolMemberMissing": "\"{name}\" が存在しません",
        "protocolRequiresRuntimeCheckable": "インスタンスとクラスのチェックで使用するには、プロトコル クラスは @runtime_checkable である必要があります",
        "protocolSourceIsNotConcrete": "\"{sourceType}\" は具象クラス型ではないため、型 \"{destType}\" に割り当てることはできません",
        "protocolUnsafeOverlap": "\"{name}\" の属性の名前がプロトコルの名前と同じです",
        "pyrightCommentIgnoreTip": "\"#ight: ignore[<diagnostic rules>] を使用して 1 行の診断を抑制する",
        "readOnlyAttribute": "属性 \"{name}\" は読み取り専用です",
        "seeClassDeclaration": "クラス宣言を参照してください",
        "seeDeclaration": "宣言を参照してください",
        "seeFunctionDeclaration": "関数の宣言を参照してください",
        "seeMethodDeclaration": "メソッド宣言を参照してください",
        "seeParameterDeclaration": "パラメーター宣言を参照してください",
        "seeTypeAliasDeclaration": "型のエイリアス宣言を参照してください",
        "seeVariableDeclaration": "変数宣言を参照してください",
        "tupleAssignmentMismatch": "型 \"{type}\" はターゲット タプルと互換性がありません",
        "tupleEntryTypeMismatch": "タプル エントリ {entry} の型が正しくありません",
        "tupleSizeIndeterminateSrc": "タプル サイズが一致しません。{expected} が必要ですが、受け取りは不確定です",
        "tupleSizeIndeterminateSrcDest": "タプル サイズが一致しません。{expected} 以上が必要ですが、受け取りは不確定です",
        "tupleSizeMismatch": "タプルのサイズが一致しません。{expected} が必要ですが、{received} を受信しました",
        "tupleSizeMismatchIndeterminateDest": "タプルのサイズが一致しません。{expected} 以上が必要ですが、{received} を受信しました",
        "typeAliasInstanceCheck": "\"type\" ステートメントで作成された型エイリアスは、インスタンスとクラスのチェックでは使用できません",
        "typeAssignmentMismatch": "型 \"{sourceType}\" を型 \"{destType}\" に割り当てることはできません",
        "typeBound": "型 \"{sourceType}\" は、型変数 \"{name}\" のバインドされた型 \"{destType}\" と互換性がありません",
        "typeConstrainedTypeVar": "型 \"{type}\" は制約付き型変数 \"{name}\" と互換性がありません",
        "typeIncompatible": "\"{sourceType}\" は \"{destType}\" と互換性がありません",
        "typeNotClass": "\"{type}\" はクラスではありません",
        "typeNotStringLiteral": "\"{type}\" は文字列リテラルではありません",
        "typeOfSymbol": "\"{name}\" の型は \"{type}\" です",
        "typeParamSpec": "型 \"{type}\" は ParamSpec \"{name}\" と互換性がありません",
        "typeUnsupported": "型 \"{type}\" はサポートされていません",
        "typeVarDefaultOutOfScope": "型変数 \"{name}\" はスコープ内にありません",
        "typeVarIsContravariant": "型パラメーター \"{name}\" は反変ですが、\"{sourceType}\" は \"{destType}\" のスーパータイプではありません",
        "typeVarIsCovariant": "型パラメーター \"{name}\" は共変ですが、\"{sourceType}\" は \"{destType}\" のサブタイプではありません",
        "typeVarIsInvariant": "型パラメーター \"{name}\" は不変ですが、\"{sourceType}\" は \"{destType}\" と同じではありません",
        "typeVarNotAllowed": "TypeVar は、インスタンスまたはクラスのチェックには使用できません",
        "typeVarTupleRequiresKnownLength": "TypeVarTuple を不明な長さのタプルにバインドすることはできません",
        "typeVarUnnecessarySuggestion": "代わりに {type} を使用してください",
        "typeVarUnsolvableRemedy": "引数が指定されていない場合に戻り値の型を指定するオーバーロードを指定します",
        "typeVarsMissing": "型変数がありません: {names}",
        "typedDictBaseClass": "クラス \"{type}\" は TypedDict ではありません",
        "typedDictClassNotAllowed": "TypedDict クラスはインスタンスまたはクラスのチェックには使用できません",
        "typedDictClosedExtraNotAllowed": "アイテム \"{name}\" を追加できません",
        "typedDictClosedExtraTypeMismatch": "型 \"{type}\" のアイテム \"{name}\" を追加できません",
        "typedDictClosedFieldNotRequired": "アイテム \"{name}\" を追加できません。これは NotRequired である必要があるためです。",
        "typedDictExtraFieldNotAllowed": "\"{name}\" は \"{type}\" に存在しません",
        "typedDictExtraFieldTypeMismatch": "\"{name}\" の型は、\"{type}\" の \"__extra_items__\" 型と互換性がありません",
        "typedDictFieldMissing": "\"{name}\" が \"{type}\" に見つかりません",
        "typedDictFieldNotReadOnly": "\"{name}\" は \"{type}\" では読み取り専用ではありません",
        "typedDictFieldNotRequired": "\"{name}\" は \"{type}\" には必要ありません",
        "typedDictFieldRequired": "\"{name}\" は \"{type}\" に必要です",
        "typedDictFieldTypeMismatch": "型 \"{type}\" は、アイテム \"{name}\" に割り当てできません",
        "typedDictFieldUndefined": "\"{name}\" は型 \"{type}\" の未定義のアイテムです",
        "typedDictFinalMismatch": "@final が一致しないため、\"{sourceType}\" は \"{destType}\" と互換性がありません",
        "typedDictNotAllowed": "TypedDict はインスタンスまたはクラスのチェックには使用できません",
        "unhashableType": "型 \"{type}\" はハッシュ可能ではありません",
        "uninitializedAbstractVariable": "インスタンス変数 \"{name}\" は抽象基本クラス \"{classType}\" で定義されていますが、初期化されていません",
        "unreachableExcept": "\"{exceptionType}\" は \"{parentType}\" のサブクラスです",
        "useDictInstead": "辞書の種類を示すには、Dict[T1, T2] を使用します",
        "useListInstead": "List[T] を使用してリストの種類を指定するか、Union[T1, T2] を使用して共用体の型を示す",
        "useTupleInstead": "tuple[T1, ..., Tn] を使用してタプル型を示すか、Union[T1, T2] を使用して共用体型を示します",
        "useTypeInstead": "代わりに Type[T] を使用する",
        "varianceMismatchForClass": "型引数 \"{typeVarName}\" の分散は、基底クラス \"{className}\" と互換性がありません",
        "varianceMismatchForTypeAlias": "型引数 \"{typeVarName}\" の分散は \"{typeAliasParam}\" と互換性がありません"
    }
}
