{
    "CodeAction": {
        "createTypeStub": "型 Stub を作成する",
        "createTypeStubFor": "\"{moduleName}\" の型 Stub を作成する",
        "executingCommand": "コマンドの実行中",
        "filesToAnalyzeCount": "分析する {count} 個のファイル",
        "filesToAnalyzeOne": "分析する 1 つのファイル",
        "findingReferences": "参照を検索しています",
        "organizeImports": "インポートを整理",
        "renameShadowedFile": "\"{oldFile}\" の名前を \"{newFile}\" に変更します"
    },
    "Completion": {
        "autoImportDetail": "自動インポート",
        "indexValueDetail": "インデックス値"
    },
    "Diagnostic": {
        "abstractMethodInvocation": "メソッド \"{method}\" は抽象メソッドであり、実装されていないため、呼び出すことができません",
        "annotatedMetadataInconsistent": "注釈付きのメタデータ型 \"{metadataType}\" は型 \"{type}\" と互換性がありません",
        "annotatedParamCountMismatch": "パラメーター注釈数の不一致: {expected} が必要ですが、{received} を受信しました",
        "annotatedTypeArgMissing": "\"Annotated\" には 1 つの型引数と 1 つ以上の注釈が必要です",
        "annotationBytesString": "型式では、バイト文字列リテラルは使用できません",
        "annotationFormatString": "型式では、書式指定文字列リテラル (f 文字列) を使用できません",
        "annotationNotSupported": "このステートメントでは型注釈はサポートされていません",
        "annotationRawString": "型式では、生文字列リテラルは使用できません",
        "annotationSpansStrings": "型式は複数の文字列リテラルにまたがることはできません",
        "annotationStringEscape": "型式にエスケープ文字を含めることはできません",
        "argAssignment": "型 \"{argType}\" の引数を型 \"{paramType}\" のパラメーターに割り当てることはできません",
        "argAssignmentFunction": "型 \"{argType}\" の引数を関数 \"{functionName}\" の型 \"{paramType}\" のパラメーターに割り当てることはできません",
        "argAssignmentParam": "型 \"{argType}\" の引数を型 \"{paramType}\" のパラメーター \"{paramName}\" に割り当てることはできません",
        "argAssignmentParamFunction": "型 \"{argType}\" の引数を、関数 \"{functionName}\" の型 \"{paramType}\" のパラメーター \"{paramName}\" に割り当てることはできません",
        "argMissingForParam": "パラメーター {name} に引数がありません",
        "argMissingForParams": "パラメーター {names} に引数がありません",
        "argMorePositionalExpectedCount": "さらに {expected} 個の位置引数が必要です",
        "argMorePositionalExpectedOne": "さらに 1 つの位置引数が必要です",
        "argPositional": "必要な位置引数",
        "argPositionalExpectedCount": "{expected} 個の位置引数が必要です",
        "argPositionalExpectedOne": "1 個の位置引数が必要です",
        "argTypePartiallyUnknown": "引数の型が部分的に不明です",
        "argTypeUnknown": "引数の型が不明です",
        "assertAlwaysTrue": "Assert 式は常に true に評価されます",
        "assertTypeArgs": "\"assert_type\" には 2 つの位置引数が必要です",
        "assertTypeTypeMismatch": "\"assert_type\" の不一致: \"{expected}\" が必要ですが、\"{received}\" を受信しました",
        "assignmentExprComprehension": "代入式のターゲット \"{name}\" は、ターゲットの理解と同じ名前を使用できません",
        "assignmentExprContext": "代入式は、モジュール、関数、またはラムダ内に存在する必要があります",
        "assignmentExprInSubscript": "下付き文字内の代入式は、Python 3.10 以降でのみサポートされます",
        "assignmentInProtocol": "Protocol クラス内のインスタンス変数またはクラス変数は、クラス本体内で明示的に宣言する必要があります",
        "assignmentTargetExpr": "式を代入先にすることはできません",
        "asyncNotInAsyncFunction": "async 関数の外部では \"async\" の使用は許可されていません",
        "awaitIllegal": "\"await\" を使用するには Python 3.5 以降が必要です",
        "awaitNotAllowed": "型式では、\"await\" は使用できません",
        "awaitNotInAsync": "\"await\" は async 関数内でのみ許可されます",
        "backticksIllegal": "バッククォートで囲まれた式は、Python 3.x ではサポートされていません。代わりに repr を使用してください",
        "baseClassCircular": "クラス自体から派生することはできません",
        "baseClassFinal": "基底クラス \"{type}\" は final とマークされており、サブクラス化できません",
        "baseClassIncompatible": "{type} の基底クラスは相互に互換性がありません",
        "baseClassInvalid": "クラスへの引数は基底クラスである必要があります",
        "baseClassMethodTypeIncompatible": "\"{classType}\" の基底クラスは、互換性のない方法でメソッド \"{name}\" を定義します",
        "baseClassUnknown": "基底クラスの型が不明で、派生クラスの型が不明です",
        "baseClassVariableTypeIncompatible": "クラス \"{classType}\" の基底クラスは、互換性のない方法で変数 \"{name}\" を定義します",
        "binaryOperationNotAllowed": "2 項演算子は型式では使用できません",
        "bindParamMissing": "\"self\" または \"cls\" パラメーターがないため、メソッド \"{methodName}\" をバインドできませんでした",
        "bindTypeMismatch": "\"{type}\" がパラメーター \"{paramName}\" に割り当てできないため、メソッド \"{methodName}\" をバインドできませんでした",
        "breakInExceptionGroup": "\"except*\" ブロックでは \"break\" を使用できません",
        "breakOutsideLoop": "\"break\" はループ内でのみ使用できます",
        "bytesUnsupportedEscape": "bytes リテラルでサポートされていないエスケープ シーケンス",
        "callableExtraArgs": "\"Callable\" に必要な型引数は 2 つだけです",
        "callableFirstArg": "パラメーターの型リストまたは \"...\" が必要です。",
        "callableNotInstantiable": "型 \"{type}\" をインスタンス化できません",
        "callableSecondArg": "\"Callable\" の 2 番目の型引数として戻り値の型が必要です",
        "casePatternIsIrrefutable": "参照不可能なパターンは、最後の case ステートメントに対してのみ許可されます",
        "classAlreadySpecialized": "型 \"{type}\" は既に特殊化されています",
        "classDecoratorTypeUnknown": "型指定されていないクラス デコレーターはクラスの型を隠します。デコレーターを無視する",
        "classDefinitionCycle": "\"{name}\" のクラス定義は、それ自体に依存します",
        "classGetItemClsParam": "__class_getitem__ override は \"cls\" パラメーターを受け取る必要があります",
        "classMethodClsParam": "クラス メソッドは \"cls\" パラメーターを受け取る必要があります",
        "classNotRuntimeSubscriptable": "クラス \"{name}\" の添字はランタイム例外を生成します。型式を引用符で囲んでください",
        "classPatternBuiltInArgPositional": "クラス パターンは位置指定サブパターンのみを受け入れます",
        "classPatternPositionalArgCount": "クラス \"{type}\" の位置指定パターンが多すぎます。{expected} が必要ですが、{received} を受信しました",
        "classPatternTypeAlias": "\"{type}\" は特殊な型エイリアスであるため、クラス パターンでは使用できません",
        "classPropertyDeprecated": "クラス プロパティは Python 3.11 では非推奨であり、Python 3.13 ではサポートされなくなります",
        "classTypeParametersIllegal": "クラス型パラメーターの構文には Python 3.12 以降が必要です",
        "classVarFirstArgMissing": "\"ClassVar\" の後に型引数が必要です",
        "classVarNotAllowed": "\"ClassVar\" はこのコンテキストでは許可されていません",
        "classVarOverridesInstanceVar": "クラス変数 \"{name}\" は、クラス \"{className}\" の同じ名前のインスタンス変数をオーバーライドします",
        "classVarTooManyArgs": "\"ClassVar\" の後に必要な型引数は 1 つだけです",
        "classVarWithTypeVar": "\"ClassVar\" 型に型変数を含めることはできません",
        "clsSelfParamTypeMismatch": "パラメーター \"{name}\" の型は、そのクラス \"{classType}\" のスーパータイプである必要があります",
        "codeTooComplexToAnalyze": "コードが複雑すぎるため、分析できません。サブルーチンにリファクタリングするか、条件付きコード パスを減らすことで複雑さを軽減してください",
        "collectionAliasInstantiation": "型 \"{type}\" はインスタンス化できません。代わりに \"{alias}\" を使用してください",
        "comparisonAlwaysFalse": "型 \"{leftType}\" と \"{rightType}\" に重複がないため、条件は常に False に評価されます",
        "comparisonAlwaysTrue": "型 \"{leftType}\" と \"{rightType}\" に重複がないため、条件は常に True に評価されます",
        "comprehensionInDict": "他の辞書エントリと共に理解することはできません",
        "comprehensionInSet": "読解は他の set エントリと併用できません。",
        "concatenateContext": "\"Concatenate\" はこのコンテキストで許可されていません",
        "concatenateParamSpecMissing": "\"Concatenate\" の最後の型引数は ParamSpec または \"...\" である必要があります",
        "concatenateTypeArgsMissing": "\"Concatenate\" には少なくとも 2 つの型引数が必要です",
        "conditionalOperandInvalid": "型 \"{type}\" の条件オペランドが無効です",
        "constantRedefinition": "\"{name}\" は定数であり (大文字であるため)、再定義できません",
        "constructorParametersMismatch": "クラス \"{classType}\" の__new__と__init__のシグネチャの不一致",
        "containmentAlwaysFalse": "型 \"{leftType}\" と \"{rightType}\" に重複がないため、式は常に False に評価されます",
        "containmentAlwaysTrue": "型 \"{leftType}\" と \"{rightType}\" に重複がないため、式は常に True に評価されます",
        "continueInExceptionGroup": "\"except*\" ブロックでは \"continue\" を使用できません",
        "continueOutsideLoop": "\"continue\" はループ内でのみ使用できます",
        "coroutineInConditionalExpression": "常に True に評価される条件式参照コルーチン",
        "dataClassBaseClassFrozen": "固定されていないクラスは、固定されているクラスから継承できません",
        "dataClassBaseClassNotFrozen": "固定されたクラスは、固定されていないクラスから継承できません",
        "dataClassConverterFunction": "型 \"{argType}\" の引数は、型 \"{fieldType}\" のフィールド \"{fieldName}\" の有効なコンバーターではありません",
        "dataClassConverterOverloads": "{funcName}\" のオーバーロードは、型 \"{fieldType}\" のフィールド \"{fieldName}\" に対して有効なコンバーターではありません",
        "dataClassFieldInheritedDefault": "\"{fieldName}\" は同じ名前のフィールドをオーバーライドしますが、既定値がありません",
        "dataClassFieldWithDefault": "既定値のないフィールドは、既定値を持つフィールドの後に表示できません",
        "dataClassFieldWithPrivateName": "データクラス フィールドはプライベート名を使用できません",
        "dataClassFieldWithoutAnnotation": "型注釈のないデータクラス フィールドが原因でランタイム例外が発生する",
        "dataClassPostInitParamCount": "Dataclass __post_init__ パラメーター数が正しくありません。InitVar フィールドの数は {expected} です",
        "dataClassPostInitType": "フィールド \"{fieldName}\" の Dataclass __post_init__ メソッド パラメーターの型が一致しません",
        "dataClassSlotsOverwrite": "__slots__はクラスで既に定義されています",
        "dataClassTransformExpectedBoolLiteral": "静的に True または False に評価される式が必要です",
        "dataClassTransformFieldSpecifier": "クラスまたは関数の tuple が必要ですが、型 \"{type}\" を受け取りました",
        "dataClassTransformPositionalParam": "\"dataclass_transform\" に対するすべての引数はキーワード引数である必要があります",
        "dataClassTransformUnknownArgument": "引数 \"{name}\" はdataclass_transform でサポートされていません",
        "dataProtocolInSubclassCheck": "データ プロトコル (メソッド以外の属性を含む) は、issubclass 呼び出しで使用できません",
        "declaredReturnTypePartiallyUnknown": "宣言された戻り値の型 \"{returnType}\" は部分的に不明です",
        "declaredReturnTypeUnknown": "宣言された戻り値の型が不明です",
        "defaultValueContainsCall": "パラメーターの既定値の式内では、関数呼び出しと変更可能なオブジェクトは許可されません",
        "defaultValueNotAllowed": "\"*\" または \"**\" のパラメーターに既定値を指定することはできません",
        "delTargetExpr": "式を削除できません",
        "deprecatedClass": "クラス \"{name}\" は非推奨です",
        "deprecatedConstructor": "クラス \"{name}\" のコンストラクターは非推奨です",
        "deprecatedDescriptorDeleter": "記述子 \"{name}\" の \"__delete__\" メソッドは非推奨です",
        "deprecatedDescriptorGetter": "記述子 \"{name}\" の \"__get__\" メソッドは非推奨です",
        "deprecatedDescriptorSetter": "記述子 \"{name}\" の \"__set__\" メソッドは非推奨です",
        "deprecatedFunction": "関数 \"{name}\" は非推奨です",
        "deprecatedMethod": "クラス \"{className}\" のメソッド \"{name}\" は非推奨です",
        "deprecatedPropertyDeleter": "The deleter for property \"{name}\" is deprecated",
        "deprecatedPropertyGetter": "The getter for property \"{name}\" is deprecated",
        "deprecatedPropertySetter": "The setter for property \"{name}\" is deprecated",
        "deprecatedType": "この型は Python {version} では非推奨です。代わりに\"{replacement}\"を使用してください",
        "dictExpandIllegalInComprehension": "辞書の展開は理解できません",
        "dictInAnnotation": "辞書式は型式では使用できません",
        "dictKeyValuePairs": "辞書エントリにはキー/値のペアが含まれている必要があります",
        "dictUnpackIsNotMapping": "ディクショナリ アンパック演算子に必要なマッピング",
        "dunderAllSymbolNotPresent": "\"{name}\" は __all__ で指定されていますが、モジュールには存在しません",
        "duplicateArgsParam": "許可される \"*\" パラメーターは 1 つだけです",
        "duplicateBaseClass": "重複する基底クラスは許可されていません",
        "duplicateCapturePatternTarget": "Capture ターゲット \"{name}\" を同じパターン内に複数回出現させることはできません",
        "duplicateCatchAll": "許可される catch-all except 句は 1 つだけです",
        "duplicateEnumMember": "Enum メンバー \"{name}\" は既に宣言されています",
        "duplicateGenericAndProtocolBase": "許可される Generic[...] または Protocol[...] 基底クラスは 1 つだけです",
        "duplicateImport": "\"{importName}\" が複数回インポートされています",
        "duplicateKeywordOnly": "\"*\" 区切り記号を 1 つだけ使用できます",
        "duplicateKwargsParam": "許可される \"**\" パラメーターは 1 つだけです",
        "duplicateParam": "パラメーター \"{name}\" が重複しています",
        "duplicatePositionOnly": "許可される \"/\" パラメーターは 1 つだけです",
        "duplicateStarPattern": "パターン シーケンスで使用できる \"*\" パターンは 1 つだけです",
        "duplicateStarStarPattern": "許可されている \"**\" エントリは 1 つだけです",
        "duplicateUnpack": "list 内で許可されるアンパック操作は 1 つのみです",
        "ellipsisAfterUnpacked": "\"...\" はアンパックされた TypeVarTuple または tuple と共に使用することはできません",
        "ellipsisContext": "\"...\" はこのコンテキストでは許可されていません",
        "ellipsisSecondArg": "\"...\" は2 つの引数の 2 番目の引数としてのみ使用できます",
        "enumClassOverride": "Enum クラス \"{name}\" は final であり、サブクラス化できません",
        "enumMemberDelete": "Enum メンバー \"{name}\" を削除できません",
        "enumMemberSet": "Enum メンバー \"{name}\" を割り当てることはできません",
        "enumMemberTypeAnnotation": "Type annotations are not allowed for enum members",
        "exceptGroupMismatch": "Try ステートメントに \"except\" と \"except*\" の両方を含めることはできません",
        "exceptGroupRequiresType": "例外グループ構文 (\"except*\") には例外の種類が必要です",
        "exceptionGroupIncompatible": "例外グループの構文 (\"except*\") には Python 3.11 以降が必要です",
        "exceptionGroupTypeIncorrect": "except* の例外型は BaseGroupException から派生できません",
        "exceptionTypeIncorrect": "\"{type}\" は BaseException から派生していません",
        "exceptionTypeNotClass": "\"{type}\" は有効な例外クラスではありません",
        "exceptionTypeNotInstantiable": "例外の種類 \"{type}\" のコンストラクターには 1 つ以上の引数が必要です",
        "expectedAfterDecorator": "デコレーターの後に必要な関数またはクラス宣言",
        "expectedArrow": "\"->\" の後に戻り値の型注釈が続く必要があります",
        "expectedAsAfterException": "例外の種類の後に \"as\" が必要です",
        "expectedAssignRightHandExpr": "\"=\" の右側に式が必要です",
        "expectedBinaryRightHandExpr": "演算子の右側に式が必要です",
        "expectedBoolLiteral": "True または False が必要です",
        "expectedCase": "\"case\" ステートメントが必要です",
        "expectedClassName": "必要なクラス名",
        "expectedCloseBrace": "\"{\" は閉じられていません",
        "expectedCloseBracket": "\"[\" は閉じられていません",
        "expectedCloseParen": "\"(\" が閉じられませんでした",
        "expectedColon": "\":\" が必要です",
        "expectedComplexNumberLiteral": "パターン マッチングに必要な複素数リテラル",
        "expectedDecoratorExpr": "Python 3.9 より前のデコレーターでは、式フォームはサポートされていません",
        "expectedDecoratorName": "デコレーター名が必要です",
        "expectedDecoratorNewline": "デコレーターの末尾に新しい行が必要です",
        "expectedDelExpr": "\"del\" の後に式が必要です",
        "expectedElse": "\"else\" が必要です",
        "expectedEquals": "\"=\" が必要です",
        "expectedExceptionClass": "例外クラスまたはオブジェクトが無効です",
        "expectedExceptionObj": "例外オブジェクト、例外クラス、または None が必要です",
        "expectedExpr": "式が必要です",
        "expectedFunctionAfterAsync": "\"async\" の後に必要な関数定義",
        "expectedFunctionName": "\"def\" の後に関数名が必要です",
        "expectedIdentifier": "必要な識別子",
        "expectedImport": "\"import\" が必要です",
        "expectedImportAlias": "\"as\" の後にシンボルが必要です",
        "expectedImportSymbols": "\"import\" の後に 1 つ以上のシンボル名が必要です",
        "expectedIn": "'in' が必要です",
        "expectedInExpr": "\"in\" の後に式が必要です",
        "expectedIndentedBlock": "インデントされたブロックが必要です",
        "expectedMemberName": "\"\" の後に属性名が必要です。",
        "expectedModuleName": "必要なモジュール名",
        "expectedNameAfterAs": "\"as\" の後にシンボル名が必要です",
        "expectedNamedParameter": "キーワード パラメーターは \"*\" の後に続く必要があります",
        "expectedNewline": "改行が必要です",
        "expectedNewlineOrSemicolon": "ステートメントは改行またはセミコロンで区切る必要があります",
        "expectedOpenParen": "\"(\" が必要です",
        "expectedParamName": "必要なパラメーター名",
        "expectedPatternExpr": "必要なパターン式",
        "expectedPatternSubjectExpr": "必要なパターンの件名の式",
        "expectedPatternValue": "\"a.b\" 形式のパターン値式が必要です",
        "expectedReturnExpr": "\"return\" の後に式が必要です",
        "expectedSliceIndex": "インデックスまたはスライス式が必要です",
        "expectedTypeNotString": "必要な型ですが、文字列リテラルを受け取りました",
        "expectedTypeParameterName": "必要な型パラメーター名",
        "expectedYieldExpr": "yield ステートメントで必要な式",
        "finalClassIsAbstract": "クラス \"{type}\" は final とマークされており、すべての抽象なシンボルを実装する必要があります",
        "finalContext": "\"Final\" はこのコンテキストでは許可されていません",
        "finalInLoop": "\"Final\" 変数をループ内で割り当てることはできません",
        "finalMethodOverride": "メソッド \"{name}\" は、クラス \"{className}\" で定義されている final メソッドをオーバーライドできません",
        "finalNonMethod": "関数 \"{name}\" はメソッドではないため、@final としてマークできません",
        "finalReassigned": "\"{name}\" は Final として宣言されており、再割り当てできません",
        "finalRedeclaration": "\"{name}\" は以前に Final として宣言されました",
        "finalRedeclarationBySubclass": "親クラス \"{className}\" が Final として宣言しているため、\"{name}\" を再宣言できません",
        "finalTooManyArgs": "\"Final\" の後に 1 つの型引数が必要です",
        "finalUnassigned": "\"{name}\" は Final と宣言されていますが、値は割り当てされていません",
        "finallyBreak": "\"break\" を使用して \"finally\" ブロックを終了することはできません",
        "finallyContinue": "\"continue\" を使用して \"finally\" ブロックを終了することはできません",
        "finallyReturn": "\"return\" を使用して \"finally\" ブロックを終了することはできません",
        "formatStringBrace": "f-string リテラル内では、1 つの閉じかっこは使用できません。二重閉じかっこを使用してください",
        "formatStringBytes": "書式指定文字列リテラル (f 文字列) をバイナリにすることはできません",
        "formatStringDebuggingIllegal": "F-string デバッグ指定子 \"=\" には Python 3.8 以降が必要です",
        "formatStringEscape": "Python 3.12 より前の f-string の式部分ではエスケープ シーケンス (バックスラッシュ) は使用できません",
        "formatStringExpectedConversion": "f-string の \"!\" の後に変換指定子が必要です",
        "formatStringIllegal": "書式文字列リテラル (f 文字列) には Python 3.6 以降が必要です",
        "formatStringInPattern": "書式指定文字列はパターンでは使用できません",
        "formatStringNestedFormatSpecifier": "書式指定子内で入れ子になった式が深すぎます",
        "formatStringNestedQuote": "f-string 内で入れ子になった文字列は、Python 3.12 より前の f-string と同じ引用符文字を使用できません",
        "formatStringUnicode": "書式指定文字列リテラル (f 文字列) を Unicode にすることはできません",
        "formatStringUnterminated": "f-string の式が終了していません。\"}\" が必要です",
        "functionDecoratorTypeUnknown": "型指定されていない関数デコレーターは、関数の型を隠します。デコレーターを無視しています",
        "functionInConditionalExpression": "常に True に評価される条件式参照関数",
        "functionTypeParametersIllegal": "関数型パラメーターの構文には Python 3.12 以降が必要です",
        "futureImportLocationNotAllowed": "__future__ からのインポートは、ファイルの先頭にある必要があります",
        "generatorAsyncReturnType": "async ジェネレーター関数の戻り値の型は、\"AsyncGenerator[{yieldType}, Any]\" と互換性がある必要があります",
        "generatorNotParenthesized": "ジェネレーター式は、唯一の引数でない場合はかっこで囲む必要があります",
        "generatorSyncReturnType": "ジェネレーター関数の戻り値の型は、\"Generator[{yieldType}, Any, Any]\" と互換性がある必要があります",
        "genericBaseClassNotAllowed": "\"Generic\" 基底クラスを型パラメーター構文と共に使用することはできません",
        "genericClassAssigned": "ジェネリック クラス型を割り当てることはできません",
        "genericClassDeleted": "ジェネリック クラス型を削除できません",
        "genericInstanceVariableAccess": "クラスを介したジェネリック インスタンス変数へのアクセスがあいまいです",
        "genericNotAllowed": "\"Generic\" はこのコンテキストでは無効です",
        "genericTypeAliasBoundTypeVar": "クラス内のジェネリック型エイリアスはバインドされた型変数 {names} を使用できません",
        "genericTypeArgMissing": "\"Generic\" には少なくとも 1 つの型引数が必要です",
        "genericTypeArgTypeVar": "\"Generic\" の型引数は型変数である必要があります",
        "genericTypeArgUnique": "\"Generic\" の型引数は一意である必要があります",
        "globalReassignment": "\"{name}\" は global 宣言の前に割り当てられます",
        "globalRedefinition": "\"{name}\" は既に global として宣言されています",
        "implicitStringConcat": "暗黙的な文字列連結は許可されていません",
        "importCycleDetected": "インポート チェーンで循環が検出されました",
        "importDepthExceeded": "インポート チェーンの深さが {depth} を超えました",
        "importResolveFailure": "インポート \"{importName}\" を解決できませんでした",
        "importSourceResolveFailure": "インポート \"{importName}\" をソースから解決できませんでした",
        "importSymbolUnknown": "\"{name}\" は不明なインポート シンボルです",
        "incompatibleMethodOverride": "メソッド \"{name}\" は互換性のない方法でクラス \"{className}\" をオーバーライドします",
        "inconsistentIndent": "元のサイズが前のインデントと一致しません",
        "inconsistentTabs": "インデントでのタブとスペースの一貫性のない使用",
        "initMethodSelfParamTypeVar": "\"__init__\" メソッドの \"self\" パラメーターの型注釈に、クラス スコープ型の変数を含めることはできません",
        "initMustReturnNone": "\"__init__\" の戻り値の型は None でなければなりません",
        "initSubclassCallFailed": "__init_subclass__ メソッドのキーワード引数が正しくありません",
        "initSubclassClsParam": "__init_subclass__ オーバーライドは \"cls\" パラメーターを受け取る必要があります",
        "initVarNotAllowed": "\"InitVar\" はこのコンテキストでは許可されていません",
        "instanceMethodSelfParam": "インスタンス メソッドは \"self\" パラメーターを受け取る必要があります",
        "instanceVarOverridesClassVar": "インスタンス変数 \"{name}\" は、クラス \"{className}\" の同じ名前のクラス変数をオーバーライドします",
        "instantiateAbstract": "抽象クラス \"{type}\" をインスタンス化できません",
        "instantiateProtocol": "Protocol クラス \"{type}\" をインスタンス化できません",
        "internalBindError": "ファイル \"{file}\" のバインド中に内部エラーが発生しました: {message}",
        "internalParseError": "ファイル \"{file}\" の解析中に内部エラーが発生しました: {message}",
        "internalTypeCheckingError": "ファイル \"{file}\" の種類チェック中に内部エラーが発生しました: {message}",
        "invalidIdentifierChar": "識別子の無効な文字",
        "invalidStubStatement": "ステートメントは、型 stub ファイル内では意味がありません",
        "invalidTokenChars": "トークン内の無効な文字 \"{text}\"",
        "isInstanceInvalidType": "\"isinstance\" の 2 番目の引数は、クラスまたはクラスの tuple である必要があります",
        "isSubclassInvalidType": "\"issubclass\" の 2 番目の引数は、クラスまたはクラスの tuple である必要があります",
        "keyValueInSet": "キーと値のペアは set 内では使用できません",
        "keywordArgInTypeArgument": "キーワード引数は型引数リストでは使用できません",
        "keywordArgShortcutIllegal": "キーワード引数のショートカットには Python 3.14 以降が必要です",
        "keywordOnlyAfterArgs": "キーワードのみの引数の区切り記号は、\"*\" パラメーターの後には使用できません",
        "keywordParameterMissing": "1 つ以上のキーワード パラメーターが \"*\" パラメーターの後に続く必要があります",
        "keywordSubscriptIllegal": "添字内のキーワード引数はサポートされていません",
        "lambdaReturnTypePartiallyUnknown": "ラムダの戻り値の型、\"{returnType}\" が部分的に不明です",
        "lambdaReturnTypeUnknown": "ラムダの戻り値の型が不明です",
        "listAssignmentMismatch": "型 \"{type}\" の式をターゲット リストに割り当てることはできません",
        "listInAnnotation": "List 式は型式では使用できません",
        "literalEmptyArgs": "\"Literal\" の後に 1 つ以上の型引数が必要です",
        "literalNamedUnicodeEscape": "名前付き Unicode エスケープ シーケンスは、\"Literal\" 文字列注釈ではサポートされていません",
        "literalNotAllowed": "\"Literal\" は、型引数なしでこのコンテキストでは使用できません",
        "literalNotCallable": "Literal 型はインスタンス化できません",
        "literalUnsupportedType": "\"Literal\" の型引数は None、literal 値 (int、bool、str、または bytes)、または enum 値である必要があります",
        "matchIncompatible": "Match ステートメントには Python 3.10 以降が必要です",
        "matchIsNotExhaustive": "match ステートメント内のケースでは、すべての値が完全に処理されるわけではありません",
        "maxParseDepthExceeded": "解析の最大深さを超えました。式を小さい部分式に分割する",
        "memberAccess": "クラス \"{type}\" の属性 \"{name}\" にアクセスできません",
        "memberDelete": "クラス \"{type}\" の属性 \"{name}\" を削除できません",
        "memberSet": "クラス \"{type}\" の属性 \"{name}\" に割り当てることはできません",
        "metaclassConflict": "派生クラスのメタクラスは、そのすべての基底クラスのメタクラスのサブクラスである必要があります",
        "metaclassDuplicate": "指定できるメタクラスは 1 つだけです",
        "metaclassIsGeneric": "メタクラスをジェネリックにすることはできません",
        "methodNotDefined": "\"{name}\" メソッドが定義されていません",
        "methodNotDefinedOnType": "型 \"{type}\" に \"{name}\" メソッドが定義されていません",
        "methodOrdering": "一貫性のあるメソッドの順序を作成できません",
        "methodOverridden": "\"{name}\" は、クラス \"{className}\" の同じ名前のメソッドを互換性のない型 \"{type}\" でオーバーライドします",
        "methodReturnsNonObject": "\"{name}\" メソッドはオブジェクトを返しません",
        "missingSuperCall": "メソッド \"{methodName}\" は親クラスで同じ名前のメソッドを呼び出しません",
        "mixingBytesAndStr": "Bytes 値と str 値を連結することはできません",
        "moduleAsType": "モジュールを型として使用することはできません",
        "moduleNotCallable": "モジュールは呼び出し可能ではありません",
        "moduleUnknownMember": "\"{memberName}\" はモジュール \"{moduleName}\" の既知の属性ではありません",
        "namedExceptAfterCatchAll": "名前付き except 句は、catch-all except 句の後には使用できません",
        "namedParamAfterParamSpecArgs": "ParamSpec args パラメーターの後にキーワード パラメーター \"{name}\" をシグネチャに含めることはできません",
        "namedTupleEmptyName": "名前付き tuple 内の名前を空にすることはできません",
        "namedTupleEntryRedeclared": "親クラス \"{className}\" が名前付き tuple であるため、\"{name}\" をオーバーライドできません",
        "namedTupleFieldUnderscore": "Named tuple フィールド名をアンダースコアで始めることはできません",
        "namedTupleFirstArg": "最初の引数として名前付き tuple クラス名が必要です",
        "namedTupleMultipleInheritance": "NamedTuple による複数の継承はサポートされていません",
        "namedTupleNameKeyword": "フィールド名をキーワードにすることはできません",
        "namedTupleNameType": "エントリ名と型を指定する 2 エントリの tuple が必要です",
        "namedTupleNameUnique": "名前付き tuple 内の名前は一意である必要があります",
        "namedTupleNoTypes": "\"namedtuple\" は tuple エントリに型を提供しません。代わりに \"NamedTuple\" を使用してください",
        "namedTupleSecondArg": "2 番目の引数として名前付き tuple エントリ list が必要です",
        "newClsParam": "__new__ override は \"cls\" パラメーターを受け取る必要があります",
        "newTypeAnyOrUnknown": "NewType の 2 番目の引数は、Any や Unknown ではなく、既知のクラスでなければなりません",
        "newTypeBadName": "NewType の最初の引数は文字列リテラルである必要があります",
        "newTypeLiteral": "NewType は Literal 型では使用できません",
        "newTypeNameMismatch": "NewType は同じ名前の変数に割り当てる必要があります",
        "newTypeNotAClass": "NewType の 2 番目の引数としてクラスが必要です",
        "newTypeParamCount": "NewType には 2 つの位置引数が必要です",
        "newTypeProtocolClass": "NewType は構造型 (Protocolまたは TypedDict クラス) では使用できません",
        "noOverload": "指定された引数に一致する \"{name}\" のオーバーロードがありません",
        "noReturnContainsReturn": "Function with declared return type \"NoReturn\" cannot include a return statement",
        "noReturnContainsYield": "戻り値の型 \"NoReturn\" を宣言した関数に yield ステートメントを含めることはできません",
        "noReturnReturnsNone": "戻り値の型が \"NoReturn\" として宣言されている関数は \"None\" を返すことができません",
        "nonDefaultAfterDefault": "既定以外の引数は既定の引数の後に続きます",
        "nonLocalInModule": "モジュール レベルでは nonlocal 宣言は許可されません",
        "nonLocalNoBinding": "nonlocal \"{name}\" のバインドが見つかりません",
        "nonLocalReassignment": "\"{name}\" は nonlocal 宣言の前に割り当てられます",
        "nonLocalRedefinition": "\"{name}\" は既に nonlocal として宣言されています",
        "noneNotCallable": "\"None\" 型のオブジェクトを呼び出すことはできません",
        "noneNotIterable": "型 \"None\" のオブジェクトを反復可能な値として使用することはできません",
        "noneNotSubscriptable": "\"None\" 型のオブジェクトは添字可能ではありません",
        "noneNotUsableWith": "Object of type \"None\" cannot be used with \"with\"",
        "noneNotUsableWithAsync": "型 \"None\" と \"async with\" は同時に使用できません",
        "noneOperator": "演算子 \"{operator}\" は \"None\" ではサポートされていません",
        "noneUnknownMember": "\"{name}\" は \"None\" の既知の属性ではありません",
        "nonlocalTypeParam": "型パラメーター \"{name}\" に nonlocal バインドは許可されていません",
        "notRequiredArgCount": "\"NotRequired\" の後に 1 つの型引数が必要です",
        "notRequiredNotInTypedDict": "\"NotRequired\" はこのコンテキストでは許可されていません",
        "objectNotCallable": "型 \"{type}\" のオブジェクトは呼び出し可能ではありません",
        "obscuredClassDeclaration": "クラス宣言 \"{name}\" は、同じ名前の宣言によって隠されています",
        "obscuredFunctionDeclaration": "関数宣言 \"{name}\" は、同じ名前の宣言によって隠されています",
        "obscuredMethodDeclaration": "メソッド宣言 \"{name}\" は、同じ名前の宣言によって隠されています",
        "obscuredParameterDeclaration": "パラメーター宣言 \"{name}\" は、同じ名前の宣言によって隠されています",
        "obscuredTypeAliasDeclaration": "型エイリアス宣言 \"{name}\" は、同じ名前の宣言によって隠されています",
        "obscuredVariableDeclaration": "宣言 \"{name}\" は、同じ名前の宣言によって隠されています",
        "operatorLessOrGreaterDeprecated": "演算子 \"<>\" は Python 3 ではサポートされていません。代わりに \"!=\" を使用してください",
        "optionalExtraArgs": "\"Optional\" の後に 1 つの型引数が必要です",
        "orPatternIrrefutable": "参照不可能なパターンは、\"or\" パターンの最後のサブパターンとしてのみ許可されます",
        "orPatternMissingName": "\"or\" パターン内のすべてのサブパターンは、同じ名前をターゲットにする必要があります",
        "overlappingKeywordArgs": "入力された辞書はキーワード パラメーターと重複しています: {names}",
        "overlappingOverload": "パラメーターがオーバーロード {obscuredBy} と重複しているため、\"{name}\" のオーバーロード {obscured} は使用されません",
        "overloadAbstractImplMismatch": "オーバーロードは実装の抽象状態と一致する必要があります",
        "overloadAbstractMismatch": "オーバーロードはすべて抽象であるか抽象でない必要があります",
        "overloadClassMethodInconsistent": "\"{name}\" のオーバーロードでは、@classmethod を不整合に使用します",
        "overloadFinalImpl": "@final デコレーターは実装にのみ適用する必要があります",
        "overloadFinalNoImpl": "最初のオーバーロードのみを @final に設定する必要があります",
        "overloadImplementationMismatch": "オーバーロードされた実装がオーバーロード {index} のシグネチャと一致しません",
        "overloadOverrideImpl": "@override デコレーターは実装にのみ適用する必要があります",
        "overloadOverrideNoImpl": "最初のオーバーロードのみを @override に設定する必要があります",
        "overloadReturnTypeMismatch": "\"{name}\" のオーバーロード {prevIndex} はオーバーロード {newIndex} と重複し、互換性のない型を返します",
        "overloadStaticMethodInconsistent": "\"{name}\" のオーバーロードでは、@staticmethod を不整合に使用します",
        "overloadWithoutImplementation": "\"{name}\" は overload としてマークされていますが、実装が提供されていません",
        "overriddenMethodNotFound": "メソッド \"{name}\" は override としてマークされていますが、同じ名前の基本メソッドが存在しません",
        "overrideDecoratorMissing": "メソッド \"{name}\" は override としてマークされていませんが、クラス \"{className}\" のメソッドをオーバーライドしています",
        "paramAfterKwargsParam": "パラメーターは \"**\" パラメーターの後に続けることはできません",
        "paramAlreadyAssigned": "パラメーター \"{name}\" は既に割り当て済みです",
        "paramAnnotationMissing": "パラメーター \"{name}\" に型注釈がありません",
        "paramAssignmentMismatch": "型 \"{sourceType}\" の式を型 \"{paramType}\" のパラメーターに割り当てることはできません",
        "paramNameMissing": "\"{name}\" という名前のパラメーターがありません",
        "paramSpecArgsKwargsDuplicate": "ParamSpec \"{type}\" の引数は既に指定されています",
        "paramSpecArgsKwargsUsage": "ParamSpec の \"args\" 属性と \"kwargs\" 属性の両方が関数シグネチャ内に含まれている必要があります",
        "paramSpecArgsMissing": "ParamSpec \"{type}\" の引数がありません",
        "paramSpecArgsUsage": "ParamSpec の \"args\" 属性は、*args パラメーターと共に使用する場合にのみ有効です",
        "paramSpecAssignedName": "ParamSpec は 、\"{name}\" という名前の変数に割り当てる必要があります",
        "paramSpecContext": "ParamSpec はこのコンテキストでは許可されていません",
        "paramSpecDefaultNotTuple": "ParamSpec の既定値には、省略記号、tuple 式、または ParamSpec が必要です",
        "paramSpecFirstArg": "最初の引数として ParamSpec の名前が必要です",
        "paramSpecKwargsUsage": "ParamSpec の \"kwargs\" 属性は、**kwargs パラメーターと共に使用する場合にのみ有効です",
        "paramSpecNotUsedByOuterScope": "ParamSpec \"{name}\" はこのコンテキストでは意味がありません",
        "paramSpecUnknownArg": "ParamSpec は複数の引数をサポートしていません",
        "paramSpecUnknownMember": "\"{name}\" は ParamSpec の既知の属性ではありません",
        "paramSpecUnknownParam": "\"{name}\" は ParamSpec に対する不明なパラメーターです",
        "paramTypeCovariant": "共変の型変数はパラメーター型では使用できません",
        "paramTypePartiallyUnknown": "パラメーター \"{paramName}\" の型が部分的に不明です",
        "paramTypeUnknown": "パラメーター \"{paramName}\" の型が不明です",
        "parenthesizedContextManagerIllegal": "Parentheses within \"with\" statement requires Python 3.9 or newer",
        "patternNeverMatches": "サブジェクトの種類 \"{type}\" のパターンは一致しません",
        "positionArgAfterNamedArg": "キーワード引数の後に位置引数を指定することはできません",
        "positionArgAfterUnpackedDictArg": "キーワード引数のアンパックの後に位置引数を指定することはできません",
        "positionOnlyAfterArgs": "\"*\" パラメーターの後に位置のみのパラメーターの区切り文字を使用することはできません",
        "positionOnlyAfterKeywordOnly": "\"/\" パラメーターは 、\"*\" パラメーターの前に指定する必要があります",
        "positionOnlyAfterNon": "位置のみのパラメーターの後に位置のみのパラメーターを指定することはできません",
        "positionOnlyFirstParam": "位置のみのパラメーターの区切り記号を最初のパラメーターとして使用することはできません",
        "positionOnlyIncompatible": "位置のみのパラメーターの区切り文字には Python 3.8 以降が必要です",
        "privateImportFromPyTypedModule": "\"{name}\" はモジュール \"{module}\" からエクスポートされていません",
        "privateUsedOutsideOfClass": "\"{name}\" はプライベートであり、宣言されているクラスの外部で使用されます",
        "privateUsedOutsideOfModule": "\"{name}\" はプライベートであり、それが宣言されているモジュールの外部で使用されています",
        "propertyOverridden": "\"{name}\" は、クラス \"{className}\" の同じ名前の property を誤ってオーバーライドします",
        "propertyStaticMethod": "静的メソッドは、property の getter、setter または deleter に対して許可されません",
        "protectedUsedOutsideOfClass": "\"{name}\" は保護され、宣言されているクラスの外部で使用されます",
        "protocolBaseClass": "Protocol クラス \"{classType}\" は非 Protocol クラス \"{baseType}\" から派生できません",
        "protocolBaseClassWithTypeArgs": "型パラメーター構文を使用する場合、Protocol クラスでは型引数を使用できません",
        "protocolIllegal": "\"Protocol\" を使用するには Python 3.7 以降が必要です",
        "protocolNotAllowed": "\"Protocol\" はこのコンテキストでは使用できません",
        "protocolTypeArgMustBeTypeParam": "\"Protocol\" の型引数は型パラメーターである必要があります",
        "protocolUnsafeOverlap": "クラスが安全でない方法で \"{name}\" と重複しており、実行時に一致する可能性があります",
        "protocolVarianceContravariant": "ジェネリック Protocol \"{class}\" で使用される型変数 \"{variable}\" は反変である必要があります",
        "protocolVarianceCovariant": "ジェネリック Protocol \"{class}\" で使用される型変数 \"{variable}\" は共変である必要があります",
        "protocolVarianceInvariant": "ジェネリック Protocol \"{class}\" で使用される型変数 \"{variable}\" は不変である必要があります",
        "pyrightCommentInvalidDiagnosticBoolValue": "Pyright コメント ディレクティブの後には \"=\" と値 true または false を指定する必要があります",
        "pyrightCommentInvalidDiagnosticSeverityValue": "Pyright コメント ディレクティブの後に \"=\" と true、false、error、warning、information または none の値を指定する必要があります",
        "pyrightCommentMissingDirective": "Pyright コメントの後にディレクティブ (basic または strict) または診断規則を指定する必要があります",
        "pyrightCommentNotOnOwnLine": "ファイル レベルの設定を制御するために使用する Pyright コメントは、独自の行に表示する必要があります",
        "pyrightCommentUnknownDiagnosticRule": "\"{rule}\" は pyright コメントの不明な診断規則です",
        "pyrightCommentUnknownDiagnosticSeverityValue": "\"{value}\" は、pyright コメントの無効な値です。true、false、error、warning、information または none が必要です",
        "pyrightCommentUnknownDirective": "\"{directive}\" は、pyright コメントの不明なディレクティブです。\"strict\" または \"basic\" が必要です",
        "readOnlyArgCount": "\"ReadOnly\" の後に 1 つの型引数が必要です",
        "readOnlyNotInTypedDict": "\"ReadOnly\" はこのコンテキストでは許可されていません",
        "recursiveDefinition": "\"{name}\" の型は、それ自体を参照しているため、特定できませんでした",
        "relativeImportNotAllowed": "相対インポートは、\"import .a\" フォームでは使用できません。代わりに \"from . import a\" を使用します。",
        "requiredArgCount": "\"Required\" の後に 1 つの型引数が必要です",
        "requiredNotInTypedDict": "このコンテキストでは \"Required\" は許可されません",
        "returnInAsyncGenerator": "値を持つ return ステートメントは、async ジェネレーターでは使用できません",
        "returnInExceptionGroup": "\"except*\" ブロックでは \"return\" を使用できません",
        "returnMissing": "戻り値の型が \"{returnType}\" として宣言されている関数は、すべてのコード パスで値を返す必要があります",
        "returnOutsideFunction": "\"return\" は関数内でのみ使用できます",
        "returnTypeContravariant": "反変の型変数は戻り値の型では使用できません",
        "returnTypeMismatch": "型 \"{exprType}\" は戻り値の型 \"{returnType}\" に割り当てできません",
        "returnTypePartiallyUnknown": "戻り値の型 \"{returnType}\" は部分的に不明です",
        "returnTypeUnknown": "戻り値の型が不明です",
        "revealLocalsArgs": "\"reveal_locals\" 呼び出しに引数が必要ありません",
        "revealLocalsNone": "このスコープには locals がありません",
        "revealTypeArgs": "\"reveal_type\" 呼び出しに 1 つの位置引数が必要です",
        "revealTypeExpectedTextArg": "関数 \"reveal_type\" の \"expected_text\" 引数は、str リテラル値である必要があります",
        "revealTypeExpectedTextMismatch": "入力テキストの不一致;\"{expected}\" が必要ですが、\"{received}\" を受信しました",
        "revealTypeExpectedTypeMismatch": "型が一致しません。\"{expected}\" が必要ですが、\"{received}\" を受信しました",
        "selfTypeContext": "\"Self\" はこのコンテキストでは無効です",
        "selfTypeMetaclass": "\"Self\" はメタクラス (\"type\" のサブクラス) 内では使用できません",
        "selfTypeWithTypedSelfOrCls": "\"Self\" は、\"Self\" 以外の型注釈を持つ 'self' または 'cls' パラメーターを持つ関数では使用できません",
        "setterGetterTypeMismatch": "property setter 値の型は、getter の戻り値の型に割り当てることができません",
        "singleOverload": "\"{name}\" はオーバーロードとしてマークされていますが、追加のオーバーロードがありません",
        "slotsAttributeError": "__slots__で \"{name}\" が指定されていません",
        "slotsClassVarConflict": "\"{name}\" が __slots__ で宣言されたインスタンス変数と競合しています",
        "starPatternInAsPattern": "スター パターンを \"as\" ターゲットと共に使用することはできません",
        "starPatternInOrPattern": "スター パターンを他のパターン内で OR 化することはできません",
        "starStarWildcardNotAllowed": "** はワイルドカード \"_\" と共に使用できません",
        "staticClsSelfParam": "静的メソッドに \"self\" または \"cls\" パラメーターを指定することはできません",
        "stdlibModuleOverridden": "\"{path}\" は stdlib モジュール \"{name}\" をオーバーライドしています",
        "stringNonAsciiBytes": "非 ASCII 文字はバイト文字列リテラルでは使用できません",
        "stringNotSubscriptable": "型式では文字列式を添字にすることはできません。式全体を引用符で囲んでください",
        "stringUnsupportedEscape": "文字列リテラルでサポートされていないエスケープ シーケンス",
        "stringUnterminated": "文字列リテラルが未終了です",
        "stubFileMissing": "\"{importName}\" の stub ファイルが見つかりません",
        "stubUsesGetAttr": "型 stub ファイルが不完全です。\"__getattr__\" はモジュールの型エラーを隠します",
        "sublistParamsIncompatible": "Python 3.x では sublist パラメーターはサポートされていません",
        "superCallArgCount": "\"super\" 呼び出しには 2 つ以下の引数が必要です",
        "superCallFirstArg": "\"super\" 呼び出しの最初の引数としてクラス型が必要ですが、\"{type}\" を受け取りました",
        "superCallSecondArg": "\"super\" 呼び出しの 2 番目の引数は、\"{type}\" から派生したオブジェクトまたはクラスである必要があります",
        "superCallZeroArgForm": "\"super\" 呼び出しの 0 引数形式は、メソッド内でのみ有効です",
        "superCallZeroArgFormStaticMethod": "\"super\" 呼び出しの 0 引数形式は、静的メソッド内では有効ではありません",
        "symbolIsPossiblyUnbound": "\"{name}\" はバインドされていない可能性があります",
        "symbolIsUnbound": "\"{name}\" はバインドされていません",
        "symbolIsUndefined": "\"{name}\" が定義されていません",
        "symbolOverridden": "\"{name}\" はクラス \"{className}\" の同じ名前のシンボルをオーバーライドします",
        "ternaryNotAllowed": "3 項式は型式では使用できません",
        "totalOrderingMissingMethod": "total_orderingを使用するには、クラスで \"__lt__\"、\"__le__\"、\"__gt__\"、または \"__ge__\" のいずれかを定義する必要があります",
        "trailingCommaInFromImport": "末尾のコンマはかっこで囲まずには使用できません",
        "tryWithoutExcept": "Try ステートメントには、少なくとも 1 つの except 句または finally 句が必要です",
        "tupleAssignmentMismatch": "型 \"{type}\" の式はターゲット tuple に割り当てることができません",
        "tupleInAnnotation": "tuple 式は型式では使用できません",
        "tupleIndexOutOfRange": "インデックス {index} が型 {type} の範囲外です",
        "typeAliasIllegalExpressionForm": "型エイリアス定義の式フォームが無効です",
        "typeAliasIsRecursiveDirect": "型エイリアス \"{name}\" は、その定義でそれ自体を使用できません",
        "typeAliasNotInModuleOrClass": "TypeAlias は、モジュールまたはクラススコープ内でのみ定義できます",
        "typeAliasRedeclared": "\"{name}\" は TypeAlias として宣言されており、1 回だけ割り当てることができます",
        "typeAliasStatementBadScope": "type ステートメントは、モジュールまたはクラススコープ内でのみ使用できます",
        "typeAliasStatementIllegal": "型エイリアス ステートメントには Python 3.12 以降が必要です",
        "typeAliasTypeBadScope": "型エイリアスは、モジュールまたはクラス スコープ内でのみ定義できます",
        "typeAliasTypeBaseClass": "\"type\" ステートメントで定義された型エイリアスを基底クラスとして使用することはできません",
        "typeAliasTypeMustBeAssigned": "TypeAliasType は、型エイリアスと同じ名前の変数に割り当てる必要があります",
        "typeAliasTypeNameArg": "TypeAliasType の最初の引数は、型エイリアスの名前を表す文字列リテラルである必要があります",
        "typeAliasTypeNameMismatch": "型エイリアスの名前は、それが割り当てられている変数の名前と一致する必要があります",
        "typeAliasTypeParamInvalid": "型パラメーター リストは、TypeVar、TypeVarTuple、または ParamSpec のみを含む tuple である必要があります",
        "typeAnnotationCall": "型式では呼び出し式を使用できません",
        "typeAnnotationVariable": "型式では変数を使用できません",
        "typeAnnotationWithCallable": "\"type\" の型引数はクラスである必要があります。呼び出し可能関数はサポートされていません",
        "typeArgListExpected": "ParamSpec、省略記号、または型の list が必要です",
        "typeArgListNotAllowed": "この型引数には list 式は使用できません",
        "typeArgsExpectingNone": "クラス \"{name}\" に型引数が必要ありません",
        "typeArgsMismatchOne": "1 つの型引数が必要ですが、{received} を受け取りました",
        "typeArgsMissingForAlias": "ジェネリック型エイリアス \"{name}\" に必要な型引数",
        "typeArgsMissingForClass": "ジェネリック クラス \"{name}\" に必要な型引数",
        "typeArgsTooFew": "\"{name}\" に指定された型引数が少なすぎます。{expected} が必要ですが、{received} を受信しました",
        "typeArgsTooMany": "\"{name}\" に指定された型引数が多すぎます。{expected} が必要ですが、{received} を受信しました",
        "typeAssignmentMismatch": "型 \"{sourceType}\" は宣言された型 \"{destType}\" に割り当てできません",
        "typeAssignmentMismatchWildcard": "インポート シンボル \"{name}\" には型 \"{sourceType}\" があり、宣言された型 \"{destType}\" には割り当てできません",
        "typeCallNotAllowed": "type() 呼び出しは型式で使用しないでください",
        "typeCheckOnly": "\"{name}\" は@type_check_onlyとしてマークされており、型注釈でのみ使用できます",
        "typeCommentDeprecated": "type コメントの使用は非推奨です。代わりに type 注釈を使用してください",
        "typeExpectedClass": "クラスが必要ですが、\"{type}\" を受け取りました",
        "typeFormArgs": "\"TypeForm\" は 1 つの位置引数を受け取ります",
        "typeGuardArgCount": "\"TypeGuard\" または \"TypeIs\" の後に 1 つの型引数が必要です",
        "typeGuardParamCount": "ユーザー定義型ガード関数とメソッドには、少なくとも 1 つの入力パラメーターが必要です",
        "typeIsReturnType": "TypeIs の戻り値の型 (\"{returnType}\") と値パラメーターの型 (\"{type}\") が一致しません",
        "typeNotAwaitable": "\"{type}\" は awaitable ではありません",
        "typeNotIntantiable": "\"{type}\" をインスタンス化できません",
        "typeNotIterable": "\"{type}\" は反復できません",
        "typeNotSpecializable": "型 \"{type}\" を特殊化できませんでした",
        "typeNotSubscriptable": "型 \"{type}\" のオブジェクトは添字可能ではありません",
        "typeNotSupportBinaryOperator": "演算子 \"{operator}\" は型 \"{leftType}\" と \"{rightType}\" ではサポートされていません",
        "typeNotSupportBinaryOperatorBidirectional": "型 \"{leftType}\" と \"{rightType}\" に対して演算子 \"{operator}\" はサポートされていません。予期された型が \"{expectedType}\" の場合",
        "typeNotSupportUnaryOperator": "演算子 \"{operator}\" は型 \"{type}\" ではサポートされていません",
        "typeNotSupportUnaryOperatorBidirectional": "型 \"{type}\" が \"{expectedType}\" の場合、演算子 \"{operator}\" はサポートされていません",
        "typeNotUsableWith": "型 \"{type}\" のオブジェクトは、{method} を正しく実装していないため、\"with\" と共に使用できません",
        "typeNotUsableWithAsync": "型 \"{type}\" のオブジェクトは、{method} を正しく実装していないため、\"async with\" と共に使用できません",
        "typeParameterBoundNotAllowed": "バインドまたは制約を可変個引数型パラメーターまたは ParamSpec と共に使用することはできません",
        "typeParameterConstraintTuple": "型パラメーター制約は、2 つ以上の型のタプルである必要があります",
        "typeParameterExistingTypeParameter": "型パラメーター \"{name}\" は既に使用されています",
        "typeParameterNotDeclared": "型パラメーター \"{name}\" は、\"{container}\" の型パラメーターリストに含まれていません",
        "typeParametersMissing": "少なくとも 1 つの型パラメーターを指定する必要があります",
        "typePartiallyUnknown": "\"{name}\" の種類が部分的に不明です",
        "typeUnknown": "\"{name}\" の種類が不明です",
        "typeVarAssignedName": "TypeVar は 、\"{name}\" という名前の変数に割り当てる必要があります",
        "typeVarAssignmentMismatch": "型 \"{type}\" を型変数 \"{name}\" に割り当てることはできません",
        "typeVarBoundAndConstrained": "TypeVar をバインドと制約の両方にすることはできません",
        "typeVarBoundGeneric": "TypeVar バインド型をジェネリックにすることはできません",
        "typeVarConstraintGeneric": "TypeVar 制約型をジェネリックにすることはできません",
        "typeVarDefaultBoundMismatch": "TypeVar の既定の型はバインドされた型のサブタイプである必要があります",
        "typeVarDefaultConstraintMismatch": "TypeVar の既定の型は、制約付き型のいずれかである必要があります",
        "typeVarDefaultIllegal": "型変数の既定の型には Python 3.13 以降が必要です",
        "typeVarDefaultInvalidTypeVar": "型パラメーター \"{name}\" には、スコープ外の 1 つ以上の型変数を参照する既定の型があります",
        "typeVarFirstArg": "最初の引数として TypeVar の名前が必要です",
        "typeVarInvalidForMemberVariable": "属性型は、ローカル メソッドにスコープ指定された型変数 \"{name}\" を使用できません",
        "typeVarNoMember": "TypeVar \"{type}\" には属性 \"{name}\" がありません",
        "typeVarNotSubscriptable": "TypeVar \"{type}\" は添字可能ではありません",
        "typeVarNotUsedByOuterScope": "型変数 \"{name}\" は、このコンテキストでは意味がありません",
        "typeVarPossiblyUnsolvable": "呼び出し元がパラメーター \"{param}\" に引数を指定しない場合、型変数 \"{name}\" は解決されない可能性があります",
        "typeVarSingleConstraint": "TypeVar には少なくとも 2 つの制約付き型が必要です",
        "typeVarTupleConstraints": "TypeVarTuple に値制約を持たせることはできません",
        "typeVarTupleContext": "TypeVarTuple はこのコンテキストでは許可されていません",
        "typeVarTupleDefaultNotUnpacked": "TypeVarTuple の既定の型は、アンパックされた tuple または TypeVarTuple である必要があります",
        "typeVarTupleMustBeUnpacked": "TypeVarTuple 値にはアンパック演算子が必要です",
        "typeVarTupleUnknownParam": "\"{name}\" は TypeVarTuple に対する不明なパラメーターです",
        "typeVarUnknownParam": "\"{name}\" は TypeVar に対する不明なパラメーターです",
        "typeVarUsedByOuterScope": "TypeVar \"{name}\" は外部スコープで既に使用されています",
        "typeVarUsedOnlyOnce": "TypeVar \"{name}\" はジェネリック関数シグネチャに 1 回だけ出現します",
        "typeVarVariance": "TypeVar を共変と反変の両方にすることはできません",
        "typeVarWithDefaultFollowsVariadic": "TypeVar \"{typeVarName}\" には既定値があり、TypeVarTuple \"{variadicName}\" の後に続けることはできません",
        "typeVarWithoutDefault": "\"{name}\" は既定の型がないため、型パラメーター リストの \"{other}\" の後に表示できません",
        "typeVarsNotInGenericOrProtocol": "Generic[] または Protocol[] には、すべての型変数を含める必要があります",
        "typedDictAccess": "TypedDict の項目にアクセスできませんでした",
        "typedDictAssignedName": "TypedDict は \"{name}\" という名前の変数に割り当てる必要があります",
        "typedDictBadVar": "TypedDict クラスには型注釈のみを含めることができます",
        "typedDictBaseClass": "TypedDict クラスのすべての基底クラスも TypedDict クラスである必要があります",
        "typedDictBoolParam": "\"{name}\" パラメーターの値は True または False である必要があります",
        "typedDictClosedExtras": "基底クラス \"{name}\" は、余分な項目の型を型 \"{type}\" に制限する TypedDict です",
        "typedDictClosedNoExtras": "基底クラス \"{name}\" は closed した TypedDict です。追加の項目は許可されていません",
        "typedDictDelete": "TypedDict の項目を削除できませんでした",
        "typedDictEmptyName": "TypedDict 内の名前を空にすることはできません",
        "typedDictEntryName": "辞書エントリ名に文字列リテラルが必要です",
        "typedDictEntryUnique": "ディクショナリ内の名前は一意である必要があります",
        "typedDictExtraArgs": "追加の TypedDict 引数はサポートされていません",
        "typedDictExtraItemsClosed": "TypedDict は \"closed\" または \"extra_items\" を使用できますが、両方を使用することはできません",
        "typedDictFieldNotRequiredRedefinition": "TypedDict アイテム \"{name}\" を NotRequired として再定義することはできません",
        "typedDictFieldReadOnlyRedefinition": "TypedDict アイテム \"{name}\" を ReadOnly として再定義することはできません",
        "typedDictFieldRequiredRedefinition": "TypedDict アイテム \"{name}\" を Required として再定義することはできません",
        "typedDictFirstArg": "最初の引数として TypedDict クラス名が必要です",
        "typedDictInClassPattern": "TypedDict クラスはクラス パターンでは使用できません",
        "typedDictInitsubclassParameter": "TypedDict は __init_subclass__パラメーター \"{name}\" をサポートしていません",
        "typedDictNotAllowed": "\"TypedDict\" はこのコンテキストでは使用できません",
        "typedDictSecondArgDict": "2 番目のパラメーターとして dict パラメーターまたはキーワード パラメーターが必要です",
        "typedDictSecondArgDictEntry": "単純な辞書エントリが必要です",
        "typedDictSet": "TypedDict で項目を割り当てることができませんでした",
        "unaccessedClass": "クラス \"{name}\" は参照されていません",
        "unaccessedFunction": "関数 \"{name}\" は参照されていません",
        "unaccessedImport": "インポート \"{name}\" は参照されていません",
        "unaccessedSymbol": "\"{name}\" は参照されていません",
        "unaccessedVariable": "変数 \"{name}\" は参照されていません",
        "unannotatedFunctionSkipped": "関数 \"{name}\" の分析は、表示されないためスキップされます",
        "unaryOperationNotAllowed": "単項演算子は型式では使用できません",
        "unexpectedAsyncToken": "\"def\"、\"with\"、または \"for\" が \"async\" の後に続く必要があります",
        "unexpectedExprToken": "式の最後に予期しないトークンが含まれています",
        "unexpectedIndent": "予期しないインデント",
        "unexpectedUnindent": "インデント解除は予期されていません",
        "unhashableDictKey": "辞書キーはハッシュ可能である必要があります",
        "unhashableSetEntry": "set エントリはハッシュ可能である必要があります",
        "uninitializedAbstractVariables": "抽象基底クラスで定義された変数が、final クラス \"{classType}\" で初期化されていません",
        "uninitializedInstanceVariable": "インスタンス変数 \"{name}\" は、クラス本体または__init__ メソッドで初期化されていません",
        "unionForwardReferenceNotAllowed": "Union 構文は文字列オペランドで使用できません。式全体を引用符で囲んでください",
        "unionSyntaxIllegal": "共用体の代替構文には Python 3.10 以降が必要です",
        "unionTypeArgCount": "Union には 2 つ以上の型引数が必要です",
        "unionUnpackedTuple": "Union cannot include an unpacked tuple",
        "unionUnpackedTypeVarTuple": "Union cannot include an unpacked TypeVarTuple",
        "unnecessaryCast": "不要な \"cast\" 呼び出し。型は既に \"{type}\" です",
        "unnecessaryIsInstanceAlways": "不要な isinstance 呼び出し。\"{testType}\" は常に \"{classType}\" のインスタンスです",
        "unnecessaryIsInstanceNever": "不要な isinstance 呼び出し; \"{testType}\" は\"{classType}\" のインスタンスであったことはありません",
        "unnecessaryIsSubclassAlways": "不要な issubclass 呼び出し。\"{testType}\" は常に \"{classType}\" のサブクラスです",
        "unnecessaryIsSubclassNever": "不要な issubclass 呼び出し; \"{testType}\" は \"{classType}\" のサブクラスであったことはありません",
        "unnecessaryPyrightIgnore": "不要な \"# pyright: ignore\" コメント",
        "unnecessaryPyrightIgnoreRule": "不要な \"# pyright: ignore\" ルール: \"{name}\"",
        "unnecessaryTypeIgnore": "不要な \"# type: ignore\" コメント",
        "unpackArgCount": "\"Unpack\" の後に 1 つの型引数が必要です",
        "unpackExpectedTypeVarTuple": "Unpack の型引数として TypeVarTuple または tuple が必要です",
        "unpackExpectedTypedDict": "Unpack に必要な TypedDict 型引数",
        "unpackIllegalInComprehension": "アンパック操作は理解できません",
        "unpackInAnnotation": "アンパック演算子は型式では使用できません",
        "unpackInDict": "アンパック操作はディクショナリで許可されていません",
        "unpackInSet": "アンパック演算子は set 内では使用できません",
        "unpackNotAllowed": "Unpack はこのコンテキストでは許可されていません",
        "unpackOperatorNotAllowed": "このコンテキストではアンパック操作は許可されていません",
        "unpackTuplesIllegal": "Python 3.8 より前のタプルではアンパック操作は許可されていません",
        "unpackedArgInTypeArgument": "アンパックされた引数は、このコンテキストでは使用できません",
        "unpackedArgWithVariadicParam": "アンパックされた引数は TypeVarTuple パラメーターには使用できません",
        "unpackedDictArgumentNotMapping": "** の後の引数式は、\"str\" キー型のマッピングである必要があります",
        "unpackedDictSubscriptIllegal": "下付き文字の辞書アンパック演算子は使用できません",
        "unpackedSubscriptIllegal": "下付き文字の Unpack 演算子には Python 3.11 以降が必要です",
        "unpackedTypeVarTupleExpected": "アンパックされた TypeVarTuple が必要です。Unpack[{name1}] または *{name2} を使用してください",
        "unpackedTypedDictArgument": "アンパックされた TypedDict 引数をパラメーターと一致させることはできません",
        "unreachableCode": "コードに到達できません",
        "unreachableCodeType": "型分析はコードに到達不能であることを示します",
        "unreachableExcept": "例外が既に処理されているため、Except 句に到達できません",
        "unsupportedDunderAllOperation": "\"__all__\" に対する操作はサポートされていないため、エクスポートされたシンボル リストが正しくない可能性があります",
        "unusedCallResult": "呼び出し式の結果は \"{type}\" 型であり、使用されません。これが意図的な場合は変数 \"_\" に代入する",
        "unusedCoroutine": "async 関数呼び出しの結果が使用されていません。\"await\" を使用するか、結果を変数に代入してください。",
        "unusedExpression": "式の値が使用されていません",
        "varAnnotationIllegal": "変数の type 注釈には Python 3.6 以降が必要です。以前のバージョンとの互換性を保つために type コメントを使用してください",
        "variableFinalOverride": "変数 \"{name}\" は Final とマークされ、クラス \"{className}\" の同じ名前の Final 以外の変数をオーバーライドします",
        "variadicTypeArgsTooMany": "型引数リストには、アンパックされた TypeVarTuple または tuple を最大 1 つ含めることができます",
        "variadicTypeParamTooManyAlias": "型エイリアスには TypeVarTuple 型パラメーターを最大 1 つ含めることができますが、複数の ({names}) を受け取りました",
        "variadicTypeParamTooManyClass": "ジェネリック クラスには最大 1 つの TypeVarTuple 型パラメーターを指定できますが、複数の ({names}) を受け取りました",
        "walrusIllegal": "演算子 \":=\" には Python 3.8 以降が必要です",
        "walrusNotAllowed": "演算子 \":=\" は、かっこを囲まないこのコンテキストでは使用できません",
        "wildcardInFunction": "ワイルドカードの import は、クラス内または関数内では許可されません",
        "wildcardLibraryImport": "ライブラリからのワイルドカードの import は許可されていません",
        "wildcardPatternTypePartiallyUnknown": "ワイルドカード パターンによってキャプチャされた型は部分的に不明です",
        "wildcardPatternTypeUnknown": "ワイルドカード パターンによってキャプチャされた型が不明です",
        "yieldFromIllegal": "\"yield from\" を使用するには Python 3.3 以降が必要です",
        "yieldFromOutsideAsync": "async 関数では \"yield from\" は使用できません",
        "yieldOutsideFunction": "関数またはラムダの外部では \"yield\" は許可されません",
        "yieldWithinComprehension": "\"yield\" は内包表記内では使用できません",
        "zeroCaseStatementsFound": "Match ステートメントには、少なくとも 1 つの case ステートメントを含める必要があります",
        "zeroLengthTupleNotAllowed": "このコンテキストでは長さ 0 の tuple は使用できません"
    },
    "DiagnosticAddendum": {
        "annotatedNotAllowed": "\"Annotated\" 特殊フォームは、インスタンスおよびクラスのチェックでは使用できません",
        "argParam": "引数はパラメーター \"{paramName}\" に対応します",
        "argParamFunction": "引数は関数 \"{functionName}\" のパラメーター \"{paramName}\" に対応します",
        "argsParamMissing": "パラメーター \"*{paramName}\" に対応するパラメーターがありません",
        "argsPositionOnly": "位置のみのパラメーターの不一致。{expected} が必要ですが、{received} を受信しました",
        "argumentType": "引数の型は \"{type}\" です",
        "argumentTypes": "引数の型: ({types})",
        "assignToNone": "型は \"None\" に割り当てできません",
        "asyncHelp": "\"async with\" を意味しましたか?",
        "baseClassIncompatible": "基底クラス \"{baseClass}\" は型 \"{type}\" と互換性がありません",
        "baseClassIncompatibleSubclass": "基底クラス \"{baseClass}\" は、型 \"{type}\" と互換性のない \"{subclass}\" から派生しています",
        "baseClassOverriddenType": "基底クラス \"{baseClass}\" は、オーバーライドされる型 \"{type}\" を提供します",
        "baseClassOverridesType": "基底クラス \"{baseClass}\" は型 \"{type}\" でオーバーライドします",
        "bytesTypePromotions": "disableBytesTypePromotions を false に設定して、\"bytearray\" と \"memoryview\" の型昇格動作を有効にします",
        "conditionalRequiresBool": "型 \"{operandType}\" のメソッド __bool__は、\"bool\" ではなく型 \"{boolReturnType}\" を返します",
        "dataClassFieldLocation": "フィールド宣言",
        "dataClassFrozen": "\"{name}\" は固定されています",
        "dataProtocolUnsupported": "\"{name}\" はデータ プロトコルです",
        "descriptorAccessBindingFailed": "記述子クラス \"{className}\" のメソッド \"{name}\" をバインドできませんでした",
        "descriptorAccessCallFailed": "記述子クラス \"{className}\" のメソッド \"{name}\" を呼び出せませんでした",
        "finalMethod": "Final メソッド",
        "functionParamDefaultMissing": "パラメーター \"{name}\" に既定の引数がありません",
        "functionParamName": "パラメーター名の不一致: \"{destName}\" と \"{srcName}\"",
        "functionParamPositionOnly": "位置のみのパラメーターの不一致; パラメーター \"{name}\" は位置のみではありません",
        "functionReturnTypeMismatch": "関数の戻り値の型 \"{sourceType}\" は型 \"{destType}\" と互換性がありません",
        "functionTooFewParams": "関数が受け入れる位置指定パラメーターが少なすぎます。{expected} が必要ですが、{received} を受信しました",
        "functionTooManyParams": "関数が受け入れる位置指定パラメーターが多すぎます。{expected} が必要ですが、{received} を受信しました",
        "genericClassNotAllowed": "インスタンスまたはクラスのチェックでは、型引数を含むジェネリック型は使用できません",
        "incompatibleDeleter": "property deleter メソッドは互換性がありません",
        "incompatibleGetter": "property getter メソッドは互換性がありません",
        "incompatibleSetter": "property setter メソッドは互換性がありません",
        "initMethodLocation": "__init__ メソッドはクラス \"{type}\" で定義されています",
        "initMethodSignature": "__init__の署名は \"{type}\" です",
        "initSubclassLocation": "__init_subclass__ メソッドはクラス \"{name}\" で定義されています",
        "invariantSuggestionDict": "\"dict\" から値の型の共変である \"Mapping\" への切り替えを検討してください",
        "invariantSuggestionList": "\"list\" から共変である \"Sequence\" への切り替えを検討してください",
        "invariantSuggestionSet": "\"set\" から共変である \"Container\" への切り替えを検討してください",
        "isinstanceClassNotSupported": "インスタンスとクラスのチェックでは、\"{type}\" はサポートされていません",
        "keyNotRequired": "\"{name}\" は \"{type}\" の必須キーではないため、アクセスすると実行時例外が発生する可能性があります",
        "keyReadOnly": "\"{name}\" は \"{type}\" の読み取り専用キーです",
        "keyRequiredDeleted": "\"{name}\" は必須キーであり、削除できません",
        "keyUndefined": "\"{name}\" は \"{type}\" で定義されたキーではありません",
        "kwargsParamMissing": "パラメーター \"**{paramName}\" に対応するパラメーターがありません",
        "listAssignmentMismatch": "型 \"{type}\" はターゲット リストと互換性がありません",
        "literalAssignmentMismatch": "\"{sourceType}\" は型 \"{destType}\" に割り当てできません",
        "literalNotAllowed": "\"Literal\" 特殊フォームは、インスタンスおよびクラスのチェックとともに使用できません",
        "matchIsNotExhaustiveHint": "完全な処理が意図されていない場合は、\"case _: pass\" を追加します",
        "matchIsNotExhaustiveType": "ハンドルされない型: \"{type}\"",
        "memberAssignment": "型 \"{type}\" の式をクラス \"{classType}\" の属性 \"{name}\" に割り当てることはできません",
        "memberIsAbstract": "\"{type}.{name}\" は実装されていません",
        "memberIsAbstractMore": "その他 {count} 件...",
        "memberIsClassVarInProtocol": "\"{name}\" はプロトコルで ClassVar として定義されています",
        "memberIsInitVar": "\"{name}\" は init-only フィールドです",
        "memberIsInvariant": "\"{name}\" は変更可能であるため、不変です",
        "memberIsNotClassVarInClass": "プロトコルと互換性を持たせるには、\"{name}\" を ClassVar として定義する必要があります",
        "memberIsNotClassVarInProtocol": "\"{name}\" はプロトコルで ClassVar として定義されていません",
        "memberIsNotReadOnlyInProtocol": "\"{name}\" はプロトコルで読み取り専用ではありません",
        "memberIsReadOnlyInProtocol": "\"{name}\" はプロトコルで読み取り専用です",
        "memberIsWritableInProtocol": "\"{name}\" はプロトコルで書き込み可能です",
        "memberSetClassVar": "属性 \"{name}\" は ClassVar であるため、クラス インスタンスを介して割り当てることはできません",
        "memberTypeMismatch": "\"{name}\" は互換性のない型です",
        "memberUnknown": "属性 \"{name}\" が不明です",
        "metaclassConflict": "メタクラス \"{metaclass1}\" が \"{metaclass2}\" と競合しています",
        "missingDeleter": "property deleter メソッドがありません",
        "missingGetter": "property getter メソッドがありません",
        "missingSetter": "property setter メソッドがありません",
        "namedParamMissingInDest": "余分なパラメーター \"{name}\"",
        "namedParamMissingInSource": "キーワード パラメーター \"{name}\" が見つかりません",
        "namedParamTypeMismatch": "型 \"{sourceType}\" のキーワード パラメーター \"{name}\" は型 \"{destType}\" と互換性がありません",
        "namedTupleNotAllowed": "NamedTuple はインスタンスまたはクラスのチェックには使用できません",
        "newMethodLocation": "__new__ メソッドはクラス \"{type}\" で定義されています",
        "newMethodSignature": "__new__の署名は \"{type}\" です",
        "newTypeClassNotAllowed": "NewType で作成されたクラスは、インスタンスおよびクラスのチェックでは使用できません",
        "noOverloadAssignable": "型 \"{type}\" に一致するオーバーロードされた関数はありません",
        "noneNotAllowed": "インスタンスまたはクラスのチェックには None 使用できません",
        "orPatternMissingName": "名前がありません: {name}",
        "overloadIndex": "オーバーロード {index} が最も近い一致です",
        "overloadNotAssignable": "\"{name}\" の 1 つ以上のオーバーロードが割り当て可能ではありません",
        "overloadSignature": "オーバーロードシグネチャはここで定義されています",
        "overriddenMethod": "オーバーライドされたメソッド",
        "overriddenSymbol": "オーバーライドされたシンボル",
        "overrideInvariantMismatch": "オーバーライドの型 \"{overrideType}\" が基本データ型 \"{baseType}\" と同じではありません",
        "overrideIsInvariant": "変数は変更可能であるため、その型は不変です",
        "overrideNoOverloadMatches": "オーバーライドのオーバーロード シグネチャが基本メソッドと互換性がありません",
        "overrideNotClassMethod": "基本メソッドは classmethod として宣言されていますが、オーバーライドはされていません",
        "overrideNotInstanceMethod": "基本メソッドはインスタンス メソッドとして宣言されていますが、オーバーライドは宣言されていません",
        "overrideNotStaticMethod": "基本メソッドは staticmethod として宣言されていますが、オーバーライドは宣言されていません",
        "overrideOverloadNoMatch": "オーバーライドは基本メソッドのすべてのオーバーロードを処理しません",
        "overrideOverloadOrder": "オーバーライド メソッドのオーバーロードは、基本メソッドと同じ順序にする必要があります",
        "overrideParamKeywordNoDefault": "キーワード パラメーター \"{name}\" の不一致: 基本パラメーターに既定の引数値があり、オーバーライド パラメーターにはありません",
        "overrideParamKeywordType": "キーワード パラメーター \"{name}\" の型が一致しません: 基本パラメーターは型 \"{baseType}\"、オーバーライド パラメーターは型 \"{overrideType}\" です",
        "overrideParamName": "パラメーター {index} 名が一致しません: ベース パラメーターの名前は \"{baseName}\"、オーバーライド パラメーターは \"{overrideName}\" です",
        "overrideParamNameExtra": "パラメーター \"{name}\" が ベース に見つかりません",
        "overrideParamNameMissing": "パラメーター \"{name}\" がオーバーライドに見つかりません",
        "overrideParamNamePositionOnly": "パラメーター {index} の不一致: ベース パラメーター \"{baseName}\" はキーワード パラメーターで、オーバーライド パラメーターは位置のみです",
        "overrideParamNoDefault": "パラメーター {index} の不一致: 基本パラメーターに既定の引数値があり、オーバーライド パラメーターが指定されていません",
        "overrideParamType": "パラメーター {index} の型が一致しません: 基本パラメーターは型 \"{baseType}\"、オーバーライド パラメーターは型 \"{overrideType}\" です",
        "overridePositionalParamCount": "位置指定パラメーター数が一致しません。基本メソッドには {baseCount} がありますが、オーバーライドには {overrideCount} があります",
        "overrideReturnType": "戻り値の型の不一致: 基本メソッドは型 \"{baseType}\" を返し、オーバーライドは型 \"{overrideType}\" を返します",
        "overrideType": "基底クラスは型を \"{type}\" として定義します",
        "paramAssignment": "パラメーター {index}: 型 \"{sourceType}\" は型 \"{destType}\" と互換性がありません",
        "paramSpecMissingInOverride": "ParamSpec パラメーターが override メソッドに見つかりません",
        "paramType": "パラメーターの型は \"{paramType}\" です",
        "privateImportFromPyTypedSource": "代わりに \"{module}\" からインポートする",
        "propertyAccessFromProtocolClass": "プロトコル クラス内で定義されたプロパティにクラス変数としてアクセスできない",
        "propertyMethodIncompatible": "property メソッド \"{name}\" は互換性がありません",
        "propertyMethodMissing": "property メソッド \"{name}\" がオーバーライドにありません",
        "propertyMissingDeleter": "property \"{name}\" に定義された deleter がありません",
        "propertyMissingSetter": "property \"{name}\" に定義された setter がありません",
        "protocolIncompatible": "\"{sourceType}\" はプロトコル \"{destType}\" と互換性がありません",
        "protocolMemberMissing": "\"{name}\" が存在しません",
        "protocolRequiresRuntimeCheckable": "インスタンスとクラスのチェックで使用するには、Protocol クラスが @runtime_checkable である必要があります",
        "protocolSourceIsNotConcrete": "\"{sourceType}\" は具象クラス型ではないため、型 \"{destType}\" に割り当てることはできません",
        "protocolUnsafeOverlap": "\"{name}\" の属性の名前がプロトコルの名前と同じです",
        "pyrightCommentIgnoreTip": "\"# pyright: ignore[<diagnostic rules>] を使用して 1 行の診断を抑制します",
        "readOnlyAttribute": "属性 \"{name}\" は読み取り専用です",
        "seeClassDeclaration": "クラス宣言を参照してください",
        "seeDeclaration": "宣言を参照してください",
        "seeFunctionDeclaration": "関数の宣言を参照してください",
        "seeMethodDeclaration": "メソッド宣言を参照してください",
        "seeParameterDeclaration": "パラメーター宣言を参照してください",
        "seeTypeAliasDeclaration": "型のエイリアス宣言を参照してください",
        "seeVariableDeclaration": "変数宣言を参照してください",
        "tupleAssignmentMismatch": "型 \"{type}\" はターゲット tuple と互換性がありません",
        "tupleEntryTypeMismatch": "tuple エントリ {entry} の型が正しくありません",
        "tupleSizeIndeterminateSrc": "Tuple のサイズが一致しません。{expected} が必要ですが、受け取りは不確定です",
        "tupleSizeIndeterminateSrcDest": "Tuple のサイズが一致しません。{expected} 以上が必要ですが、受け取りは不確定です",
        "tupleSizeMismatch": "tuple のサイズが一致しません。{expected} が必要ですが、{received} を受信しました",
        "tupleSizeMismatchIndeterminateDest": "Tuple のサイズが一致しません。{expected} 以上が必要ですが、{received} を受信しました",
        "typeAliasInstanceCheck": "\"type\" ステートメントで作成された型エイリアスは、インスタンスとクラスのチェックでは使用できません",
        "typeAssignmentMismatch": "型 \"{sourceType}\" は型 \"{destType}\" に割り当てできません",
        "typeBound": "型 \"{sourceType}\" は、型変数 \"{name}\" の上限 \"{destType}\" に割り当てできません",
        "typeConstrainedTypeVar": "型 \"{type}\" は制約付き型変数 \"{name}\" に割り当てできません",
        "typeIncompatible": "\"{sourceType}\" は \"{destType}\" に割り当てできません",
        "typeNotClass": "\"{type}\" はクラスではありません",
        "typeNotStringLiteral": "\"{type}\" は文字列リテラルではありません",
        "typeOfSymbol": "\"{name}\" の型は \"{type}\" です",
        "typeParamSpec": "型 \"{type}\" は ParamSpec \"{name}\" と互換性がありません",
        "typeUnsupported": "型 \"{type}\" はサポートされていません",
        "typeVarDefaultOutOfScope": "型変数 \"{name}\" はスコープ内にありません",
        "typeVarIsContravariant": "型パラメーター \"{name}\" は反変ですが、\"{sourceType}\" は \"{destType}\" のスーパータイプではありません",
        "typeVarIsCovariant": "型パラメーター \"{name}\" は共変ですが、\"{sourceType}\" は \"{destType}\" のサブタイプではありません",
        "typeVarIsInvariant": "型パラメーター \"{name}\" は不変ですが、\"{sourceType}\" は \"{destType}\" と同じではありません",
        "typeVarNotAllowed": "TypeVar は、インスタンスまたはクラスのチェックには使用できません",
        "typeVarTupleRequiresKnownLength": "TypeVarTuple を不明な長さの tuple にバインドすることはできません",
        "typeVarUnnecessarySuggestion": "代わりに {type} を使用してください",
        "typeVarUnsolvableRemedy": "引数が指定されていない場合に戻り値の型を指定するオーバーロードを指定します",
        "typeVarsMissing": "型変数がありません: {names}",
        "typedDictBaseClass": "クラス \"{type}\" は TypedDict ではありません",
        "typedDictClassNotAllowed": "TypedDict クラスはインスタンスまたはクラスのチェックには使用できません",
        "typedDictClosedExtraNotAllowed": "アイテム \"{name}\" を追加できません",
        "typedDictClosedExtraTypeMismatch": "型 \"{type}\" のアイテム \"{name}\" を追加できません",
        "typedDictClosedFieldNotRequired": "アイテム \"{name}\" を追加できません。これは NotRequired である必要があるためです。",
        "typedDictExtraFieldNotAllowed": "\"{name}\" は \"{type}\" に存在しません",
        "typedDictExtraFieldTypeMismatch": "\"{name}\" の型は、\"{type}\" の \"extra_items\" 型と互換性がありません",
        "typedDictFieldMissing": "\"{name}\" が \"{type}\" に見つかりません",
        "typedDictFieldNotReadOnly": "\"{name}\" は \"{type}\" では読み取り専用ではありません",
        "typedDictFieldNotRequired": "\"{name}\" は \"{type}\" には必要ありません",
        "typedDictFieldRequired": "\"{name}\" は \"{type}\" に必要です",
        "typedDictFieldTypeMismatch": "型 \"{type}\" は、アイテム \"{name}\" に割り当てできません",
        "typedDictFieldUndefined": "\"{name}\" は型 \"{type}\" の未定義のアイテムです",
        "typedDictKeyAccess": "[\"{name}\"] を使用して TypedDict の項目を参照する",
        "typedDictNotAllowed": "TypedDict はインスタンスまたはクラスのチェックには使用できません",
        "unhashableType": "型 \"{type}\" はハッシュ可能ではありません",
        "uninitializedAbstractVariable": "インスタンス変数 \"{name}\" は抽象基本クラス \"{classType}\" で定義されていますが、初期化されていません",
        "unreachableExcept": "\"{exceptionType}\" は \"{parentType}\" のサブクラスです",
        "useDictInstead": "辞書の種類を示すには、dict[T1, T2] を使用します",
        "useListInstead": "list[T] を使用して list 型を示すか、T1 | T2 を使用して union 型を示します",
        "useTupleInstead": "tuple[T1, ..., Tn] を使用して tuple 型を示すか、T1 | T2 を使用して union 型を示します",
        "useTypeInstead": "代わりに type[T] を使用する",
        "varianceMismatchForClass": "型引数 \"{typeVarName}\" の分散は、基底クラス \"{className}\" と互換性がありません",
        "varianceMismatchForTypeAlias": "型引数 \"{typeVarName}\" の分散は \"{typeAliasParam}\" と互換性がありません"
    },
    "Service": {
        "longOperation": "ワークスペース ソース ファイルの列挙に時間がかかっています。代わりにサブフォルダーを開く方法を検討してください。[詳細情報](https://aka.ms/workspace-too-many-files)"
    }
}
