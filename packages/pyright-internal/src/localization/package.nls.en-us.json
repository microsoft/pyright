{
    "Diagnostic": {
        "annotatedParamCountMismatch": "Parameter annotation count mismatch: expected {expected} but received {received}",
        "annotatedTypeArgMissing": "Expected one type argument and one or more annotations for \"Annotated\"",
        "annotationFormatString": "Type annotations cannot use format string literals (f-strings)",
        "annotationNotSupported": "Type annotation not supported for this type of expression",
        "annotationSpansStrings": "Type annotations cannot span multiple string literals",
        "annotationStringEscape": "Type annotations cannot contain escape characters",
        "annotationTripleQuote": "Type annotations cannot use triple quotes",
        "argAssignment": "Argument of type \"{argType}\" cannot be assigned to parameter of type \"{paramType}\"",
        "argAssignmentFunction": "Argument of type \"{argType}\" cannot be assigned to parameter of type \"{paramType}\" in function \"{functionName}\"",
        "argAssignmentParam": "Argument of type \"{argType}\" cannot be assigned to parameter \"{paramName}\" of type \"{paramType}\"",
        "argAssignmentParamFunction": "Argument of type \"{argType}\" cannot be assigned to parameter \"{paramName}\" of type \"{paramType}\" in function \"{functionName}\"",
        "argMissingForParam": "Argument missing for parameter {name}",
        "argMissingForParams": "Arguments missing for parameters {names}",
        "argMorePositionalExpectedCount": "Expected {expected} more positional arguments",
        "argMorePositionalExpectedOne": "Expected 1 more positional argument",
        "argPositional": "Expected positional argument",
        "argPositionalExpectedCount": "Expected {expected} positional arguments",
        "argPositionalExpectedOne": "Expected 1 positional argument",
        "argTypePartiallyUnknown": "Argument type is partially unknown",
        "argTypeUnknown": "Argument type is unknown",
        "assertAlwaysTrue": "Assert expression always evaluates to true",
        "assignmentExprContext": "Assignment expression must be within module, function or lambda",
        "assignmentExprComprehension": "Assignment expression target \"{name}\" cannot use same name as comprehension for target",
        "assignmentInProtocol": "Assignment to instance or class variables not allowed within a Protocol class",
        "assignmentTargetExpr": "Expression cannot be assignment target",
        "awaitIllegal": "Use of \"await\" requires Python 3.5 or newer",
        "awaitNotInAsync": "\"await\" allowed only within async function",
        "backticksIllegal": "Expressions surrounded by backticks are not supported in Python 3.x; use repr instead",
        "baseClassCircular": "Class cannot derive from itself",
        "baseClassFinal": "Base class \"{type}\" is marked final and cannot be subclassed",
        "baseClassInvalid": "Argument to class must be a base class",
        "baseClassUnknown": "Base class type is unknown, obscuring type of derived class",
        "bindTypeMismatch": "Could not bind method \"{methodName}\" because \"{type}\" is not assignable to parameter \"{paramName}\"",
        "breakOutsideLoop": "\"break\" can be used only within a loop",
        "callableExtraArgs": "Expected only two type arguments to \"Callable\"",
        "callableFirstArg": "Expected parameter type list or \"...\"",
        "callableSecondArg": "Expected return type as second type argument for \"Callable\"",
        "casePatternIsIrrefutable": "Irrefutable pattern is allowed only for the last case statement",
        "classDecoratorTypeUnknown": "Untyped class decorator obscures type of class; ignoring decorator",
        "classGetItemClsParam": "__class_getitem__ override should take a \"cls\" parameter",
        "classMethodClsParam": "Class methods should take a \"cls\" parameter",
        "classNotRuntimeSubscriptable": "Subscript for class \"{name}\" will generate runtime exception; enclose type annotation in quotes",
        "classVarFirstArgMissing": "Expected a type argument after \"ClassVar\"",
        "classVarTooManyArgs": "Expected only one type argument after \"ClassVar\"",
        "comprehensionInDict": "Comprehension cannot be used with other dictionary entries",
        "comprehensionInSet": "Comprehension cannot be used with other set entries",
        "concatenateParamSpecMissing": "Last type argument for \"Concatenate\" must be a ParamSpec",
        "concatenateTypeArgsMissing": "\"Concatenate\" requires at least two type arguments",
        "constantRedefinition": "\"{name}\" is constant and cannot be redefined",
        "continueInFinally": "\"continue\" cannot be used within a finally clause",
        "continueOutsideLoop": "\"continue\" can be used only within a loop",
        "constructorNoArgs": "Expected no arguments to \"{type}\" constructor",
        "dataClassBaseClassNotFrozen": "A frozen dataclass cannot inherit from a dataclass that is not frozen",
        "dataClassFieldWithDefault": "Dataclass fields without default value cannot appear after data fields with default values",
        "declaredReturnTypePartiallyUnknown": "Declared return type, \"{returnType}\", is partially unknown",
        "declaredReturnTypeUnknown": "Declared return type is unknown",
        "defaultValueContainsCall": "Function calls within default value initializer are not permitted",
        "defaultValueNotAllowed": "Parameter with \"*\" or \"**\" cannot have default value",
        "defaultValueNotEllipsis": "Default values in stub files should be specified as \"...\"",
        "delTargetExpr": "Expression cannot be deleted",
        "dictExpandIllegalInComprehension": "Dictionary expansion not allowed in comprehension",
        "dictInAnnotation": "Dictionary expression not allowed in type annotation",
        "dictKeyValuePairs": "Dictionary entries must contain key/value pairs",
        "dictUnpackIsNotMapping": "Expected mapping for dictionary unpack operator",
        "duplicateArgsParam": "Only one \"*\" parameter allowed",
        "duplicateBaseClass": "Duplicate base class not allowed",
        "duplicateCatchAll": "Only one catch-all except clause allowed",
        "duplicateImport": "\"{importName}\" is imported more than once",
        "duplicateKwargsParam": "Only one \"**\" parameter allowed",
        "duplicateNameOnly": "Only one \"*\" separator allowed",
        "duplicateParam": "Duplicate parameter \"{name}\"",
        "duplicateCapturePatternTarget": "Capture target \"{name}\" cannot appear more than once within the same pattern",
        "duplicateStarPattern": "Only one \"*\" pattern allowed in a pattern sequence",
        "duplicateStarStarPattern": "Only one \"**\" entry allowed",
        "duplicatePositionOnly": "Only one \"/\" parameter allowed",
        "duplicateUnpack": "Only one unpack operation allowed in list",
        "ellipsisContext": "\"...\" not allowed in this context",
        "ellipsisSecondArg": "\"...\" allowed only as the second of two arguments",
        "exceptionTypeIncorrect": "\"{type}\" does not derive from BaseException",
        "exceptionTypeNotClass": "\"{type}\" is not valid exception class",
        "exceptionTypeNotInstantiable": "Constructor for exception type \"{type}\" requires one or more arguments",
        "expectedAfterDecorator": "Expected function or class declaration after decorator",
        "expectedArrow": "Expected \"->\" followed by return type annotation",
        "expectedAsAfterException": "Expected \"as\" after exception type",
        "expectedAssignRightHandExpr": "Expected expression to the right of \"=\"",
        "expectedBinaryRightHandExpr": "Expected expression to the right of operator",
        "expectedBoolLiteral": "Expected True or False",
        "expectedCase": "Expected \"case\" statement",
        "expectedClassName": "Expected class name",
        "expectedCloseBrace": "Expected \"}\"",
        "expectedCloseBracket": "Expected \"]\"",
        "expectedCloseParen": "Expected \")\"",
        "expectedColon": "Expected \":\"",
        "expectedComplexNumberLiteral": "Expected complex number literal for pattern matching",
        "expectedDecoratorExpr": "Expression form not supported for decorator prior to Python 3.9",
        "expectedDecoratorName": "Expected decorator name",
        "expectedDecoratorNewline": "Expected new line at end of decorator",
        "expectedDelExpr": "Expected expression after \"del\"",
        "expectedElse": "Expected \"else\"",
        "expectedExceptionClass": "Invalid exception class or object",
        "expectedExceptionObj": "Expected exception object or None",
        "expectedExpr": "Expected expression",
        "expectedIdentifier": "Expected identifier",
        "expectedImport": "Expected \"import\"",
        "expectedImportAlias": "Expected symbol after \"as\"",
        "expectedImportSymbols": "Expected one or more symbol names after import",
        "expectedIndentedBlock": "Expected indented block",
        "expectedInExpr": "Expected expression after \"in\"",
        "expectedIn": "Expected \"in\"",
        "expectedFunctionAfterAsync": "Expected function definition after \"async\"",
        "expectedFunctionName": "Expected function name after \"def\"",
        "expectedMemberName": "Expected member name after \".\"",
        "expectedModuleName": "Expected module name",
        "expectedNameAfterAs": "Expected symbol name after \"as\"",
        "expectedNamedParameter": "Keyword parameter must follow \"*\"",
        "expectedNewline": "Expected newline",
        "expectedNewlineOrSemicolon": "Statements must be separated by newlines or semicolons",
        "expectedOpenParen": "Expected \"(\"",
        "expectedParamName": "Expected parameter name",
        "expectedPatternExpr": "Expected pattern expression",
        "expectedPatternValue": "Expected pattern value expression of the form \"a.b\"",
        "expectedReturnExpr": "Expected expression after \"return\"",
        "expectedSliceIndex": "Expected index or slice expression",
        "expectedTypeNotString": "Expected type but received a string literal",
        "expectedYieldExpr": "Expected expression in yield statement",
        "finalContext": "\"Final\" not allowed in this context",
        "finalMethodOverride": "Method \"{name}\" cannot override final method defined in class \"{className}\"",
        "finalReassigned": "\"{name}\" is declared as Final and cannot be reassigned",
        "finalRedeclaration": "\"{name}\" was previously declared as Final",
        "finalRedeclarationBySubclass": "\"{name}\" cannot be redeclared because parent class \"{className}\" declares it as Final",
        "finalTooManyArgs": "Expected a single type argument after \"Final\"",
        "finalUnassigned": "\"{name}\" is declared Final, but value is not assigned",
        "formatStringBrace": "Single close brace not allowed within f-string literal; use double close brace",
        "formatStringBytes": "Format string literals (f-strings) cannot be binary",
        "formatStringEscape": "Escape sequence (backslash) not allowed in expression portion of f-string",
        "formatStringInPattern": "Format string not allowed in pattern",
        "formatStringUnicode": "Format string literals (f-strings) cannot be unicode",
        "formatStringIllegal": "Format string literals (f-strings) require Python 3.6 or newer",
        "formatStringUnterminated": "Unterminated expression in f-string; missing close brace",
        "functionDecoratorTypeUnknown": "Untyped function decorator obscures type of function; ignoring decorator",
        "genericClassAssigned": "Generic class type cannot be assigned",
        "genericClassDeleted": "Generic class type cannot be deleted",
        "genericNotAllowed": "\"Generic\" is not valid in this context",
        "genericTypeArgMissing": "\"Generic\" requires at least one type argument",
        "genericTypeArgTypeVar": "Type argument for \"Generic\" must be a type variable",
        "genericTypeArgUnique": "Type arguments for \"Generic\" must be unique",
        "globalReassignment": "\"{name}\" is assigned before global declaration",
        "globalRedefinition": "\"{name}\" was already declared global",
        "implicitStringConcat": "Implicit string concatenation not allowed",
        "importCycleDetected": "Cycle detected in import chain",
        "importDepthExceeded": "Import chain depth exceeded {depth}",
        "importResolveFailure": "Import \"{importName}\" could not be resolved",
        "importSourceResolveFailure": "Import \"{importName}\" could not be resolved from source",
        "importSymbolUnknown": "\"{name}\" is unknown import symbol",
        "incompatibleMethodOverride": "Method \"{name}\" overrides class \"{className}\" in an incompatible manner",
        "inconsistentIndent": "Unindent amount does not match previous indent",
        "inconsistentTabs": "Inconsistent use of tabs and spaces in indentation",
        "initSubclassClsParam": "__init_subclass__ override should take a \"cls\" parameter",
        "instanceMethodSelfParam": "Instance methods should take a \"self\" parameter",
        "internalBindError": "An internal error occurred while binding file \"{file}\": {message}",
        "internalParseError": "An internal error occurred while parsing file \"{file}\": {message}",
        "internalTypeCheckingError": "An internal error occurred while type checking file \"{file}\": {message}",
        "invalidIdentifierChar": "Invalid character in identifier",
        "invalidStubStatement": "Statement is meaningless within a type stub file",
        "invalidTokenChars": "Invalid character in token \"{text}\"",
        "isInstanceInvalidType": "Second argument to \"isinstance\" must be a class or tuple of classes",
        "isSubclassInvalidType": "Second argument to \"issubclass\" must be a class or tuple of classes",
        "keyRequiredDeleted": "\"{name}\" is a required key and cannot be deleted",
        "keyValueInSet": "Key/value pairs are not allowed within a set",
        "keywordArgInTypeArgument": "Keyword arguments cannot be used in type argument lists",
        "keywordSubscriptIllegal": "Keyword arguments within subscripts requires Python 3.10 or newer",
        "lambdaReturnTypeUnknown": "Return type of lambda is unknown",
        "lambdaReturnTypePartiallyUnknown": "Return type of lambda, \"{returnType}\", is partially unknown",
        "listInAnnotation": "List expression not allowed in type annotation",
        "literalUnsupportedType": "Type arguments for \"Literal\" must be None, a literal value (int, bool, str, or bytes), or an enum value",
        "literalEmptyArgs": "Expected one or more type arguments after \"Literal\"",
        "literalNotCallable": "Literal type cannot be instantiated",
        "matchIncompatible": "Match statements require Python 3.10 or newer",
        "memberAccess": "Cannot access member \"{name}\" for type \"{type}\"",
        "memberDelete": "Cannot delete member \"{name}\" for type \"{type}\"",
        "memberSet": "Cannot assign member \"{name}\" for type \"{type}\"",
        "metaclassConflict": "The metaclass of a derived class must be a subclass of the metaclasses of all its base classes",
        "metaclassDuplicate": "Only one metaclass can be provided",
        "methodNotDefined": "\"{name}\" method not defined",
        "methodNotDefinedOnType": "\"{name}\" method not defined on type \"{type}\"",
        "methodOrdering": "Cannot create consistent method ordering",
        "methodOverridden": "\"{name}\" overrides method of same name in class \"{className}\" with incompatible type \"{type}\"",
        "methodReturnsNonObject": "\"{name}\" method does not return an object",
        "moduleContext": "Module not allowed in this context",
        "moduleUnknownMember": "\"{name}\" is not a known member of module",
        "namedExceptAfterCatchAll": "A named except clause cannot appear after catch-all except clause",
        "namedParamAfterParamSpecArgs": "Keyword parameter \"{name}\" cannot appear in signature after ParamSpec args parameter",
        "namedTupleEmptyName": "Names within a named tuple cannot be empty",
        "namedTupleFirstArg": "Expected named tuple class name as first argument",
        "namedTupleNameString": "Expected string literal for tuple entry name",
        "namedTupleNameType": "Expected two-entry tuple specifying entry name and type",
        "namedTupleNameUnique": "Names within a named tuple must be unique",
        "namedTupleNoTypes": "\"namedtuple\" provides no types for tuple entries; use \"NamedTuple\" instead",
        "namedTupleSecondArg": "Expected named tuple entry list as second argument",
        "newClsParam": "__new__ override should take a \"cls\" parameter",
        "newTypeLiteral": "NewType cannot be used with Literal type",
        "newTypeNotAClass": "Expected class as second argument to NewType",
        "newTypeProtocolClass": "NewType cannot be used with protocol class",
        "nonDefaultAfterDefault": "Non-default argument follows default argument",
        "noneNotCallable": "Object of type \"None\" cannot be called",
        "noneNotIterable": "Object of type \"None\" cannot be used as iterable value",
        "noneOperator": "Operator \"{operator}\" not supported for \"None\"",
        "noneNotSubscriptable": "Object of type \"None\" is not subscriptable",
        "noneNotUsableWith": "Object of type \"None\" cannot be used with \"with\"",
        "noneUnknownMember": "\"{name}\" is not a known member of \"None\"",
        "nonLocalNoBinding": "No binding for nonlocal \"{name}\" found",
        "nonLocalReassignment": "\"{name}\" is assigned before nonlocal declaration",
        "nonLocalRedefinition": "\"{name}\" was already declared nonlocal",
        "nonLocalInModule": "Nonlocal declaration not allowed at module level",
        "noOverload": "No overloads for \"{name}\" match the provided arguments",
        "noReturnContainsReturn": "Function with declared return type \"NoReturn\" cannot include a return statement",
        "noReturnContainsYield": "Function with declared return type \"NoReturn\" cannot include a yield statement",
        "noReturnReturnsNone": "Function with declared type of \"NoReturn\" cannot return \"None\"",
        "objectNotCallable": "Object of type \"{type}\" is not callable",
        "obscuredClassDeclaration": "Class declaration \"{name}\" is obscured by a declaration of the same name",
        "obscuredFunctionDeclaration": "Function declaration \"{name}\" is obscured by a declaration of the same name",
        "obscuredMethodDeclaration": "Method declaration \"{name}\" is obscured by a declaration of the same name",
        "obscuredParameterDeclaration": "Parameter declaration \"{name}\" is obscured by a declaration of the same name",
        "obscuredVariableDeclaration": "Declaration \"{name}\" is obscured by a declaration of the same name",
        "operatorLessOrGreaterDeprecated": "Operator \"<>\" is not supported in Python 3; use \"!=\" instead",
        "optionalExtraArgs": "Expected one type argument after \"Optional\"",
        "orPatternIrrefutable": "Irrefutable pattern allowed only as the last subpattern in an \"or\" pattern",
        "orPatternMissingName": "All subpatterns within an \"or\" pattern must target the same names",
        "overlappingOverload": "Overload {obscured} for \"{name}\" will never be used because its parameters overlap overload {obscuredBy}",
        "overloadAbstractMismatch": "Overloaded methods must all be abstract or not",
        "overloadReturnTypeMismatch": "Overload {prevIndex} for \"{name}\" overlaps overload {newIndex} and returns an incompatible type",
        "paramAfterKwargsParam": "Parameter cannot follow \"**\" parameter",
        "paramAlreadyAssigned": "Parameter \"{name}\" is already assigned",
        "paramNameMissing": "No parameter named \"{name}\"",
        "paramSpecAssignedName": "ParamSpec must be assigned to a variable named \"{name}\"",
        "paramSpecContext": "ParamSpec not allowed in this context",
        "paramSpecIllegal": "ParamSpec requires Python 3.10 or newer",
        "paramSpecFirstArg": "Expected name of ParamSpec as first argument",
        "paramSpecNotBound": "Param spec \"{type}\" has no bound value",
        "paramSpecUnknownArg": "ParamSpec does not support more than one argument",
        "paramSpecUnknownMember": "\"{name}\" is not a known member of ParamSpec",
        "paramSpecUnknownParam": "\"{name}\" is unknown parameter to ParamSpec",
        "paramAssignmentMismatch": "Expression of type \"{sourceType}\" cannot be assigned to parameter of type \"{paramType}\"",
        "paramTypeCovariant": "Covariant type variable cannot be used in parameter type",
        "paramTypeUnknown": "Type of parameter \"{paramName}\" is unknown",
        "paramTypePartiallyUnknown": "Type of parameter \"{paramName}\" is partially unknown",
        "parenthesizedContextManagerIllegal": "Parentheses within \"with\" statement requires Python 3.10 or newer",
        "positionArgAfterNamedArg": "Positional argument cannot appear after keyword arguments",
        "positionOnlyAfterNameOnly": "\"/\" parameter must appear before \"*\" parameter",
        "positionOnlyIncompatible": "Position-only argument separator requires Python 3.8 or newer",
        "positionOnlyFirstParam": "Position-only argument separator not allowed as first parameter",
        "privateUsedOutsideOfClass": "\"{name}\" is private and used outside of the class in which it is declared",
        "privateUsedOutsideOfModule": "\"{name}\" is private and used outside of the module in which it is declared",
        "propertyOverridden": "\"{name}\" incorrectly overrides property of same name in class \"{className}\"",
        "propertyStaticMethod": "Static methods not allowed for property getter, setter or deleter",
        "protectedUsedOutsideOfClass": "\"{name}\" is protected and used outside of the class in which it is declared",
        "protocolBaseClass": "Protocol class \"{classType}\" cannot derive from non-protocol class \"{baseType}\"",
        "protocolIllegal": "Use of \"Protocol\" requires Python 3.7 or newer",
        "protocolUsedInCall": "Protocol class cannot be used in \"{name}\" call",
        "raiseParams": "\"raise\" requires one or more parameters when used outside of except clause",
        "relativeImportNotAllowed": "Relative imports cannot be used with \"import .a\" form; use \"from . import a\" instead",
        "recursiveDefinition": "Type of \"{name}\" could not be determined because it refers to itself",
        "returnOutsideFunction": "\"return\" can be used only within a function",
        "returnMissing": "Function with declared type of \"{returnType}\" must return value",
        "returnTypeContravariant": "Contravariant type variable cannot be used in return type",
        "returnTypeMismatch": "Expression of type \"{exprType}\" cannot be assigned to return type \"{returnType}\"",
        "returnTypeUnknown": "Return type is unknown",
        "returnTypePartiallyUnknown": "Return type, \"{returnType}\", is partially unknown",
        "revealLocalsNone": "No locals in this scope",
        "setterGetterTypeMismatch": "Property setter value type is not assignable to the getter return type",
        "singleOverload": "\"{name}\" is marked as overload, but additional overloads are missing",
        "starPatternInAsPattern": "Star pattern cannot be used with \"as\" target",
        "starPatternInOrPattern": "Star pattern cannot be ORed within other patterns",
        "starStarWildcardNotAllowed": "** cannot be used with wildcard \"_\"",
        "staticClsSelfParam": "Static methods should not take a \"self\" or \"cls\" parameter",
        "stringNonAsciiBytes": "Non-ASCII character not allowed in bytes string literal",
        "stringNotSubscriptable": "String expression cannot be subscripted in type annotation; enclose entire annotation in quotes",
        "stringUnsupportedEscape": "Unsupported escape sequence in string literal",
        "stringUnterminated": "String literal is unterminated",
        "stubFileMissing": "Stub file not found for \"{importName}\"",
        "stubUsesGetAttr": "Type stub file is incomplete; \"__getattr__\" obscures type errors for module",
        "sublistParamsIncompatible": "Sublist parameters are not supported in Python 3.x",
        "superCallArgCount": "Expected no more than two arguments to \"super\" call",
        "superCallFirstArg": "Expected class type as first argument to \"super\" call but received \"{type}\"",
        "superCallSecondArg": "Second argument to \"super\" call must be object or class that derives from \"{type}\"",
        "superCallZeroArgForm": "Zero-argument form of \"super\" call is valid only within a class",
        "symbolIsUnbound": "\"{name}\" is unbound",
        "symbolIsUndefined": "\"{name}\" is not defined",
        "symbolIsPossiblyUnbound": "\"{name}\" is possibly unbound",
        "symbolOverridden": "\"{name}\" overrides symbol of same name in class \"{className}\"",
        "tryWithoutExcept": "Try statement must have at least one except or finally clause",
        "tupleInAnnotation": "Tuple expression not allowed in type annotation",
        "tupleIndexOutOfRange": "Index {index} is out of range for tuple with length {length}",
        "tupleSizeMismatch": "Tuple size mismatch: expected {expected} but received {received}",
        "typeAbstract": "Cannot instantiate abstract class \"{type}\"",
        "typeAliasIsRecursive": "Type alias \"{name}\" cannot use itself in its definition",
        "typeAliasNotInModule": "A TypeAlias can be defined only within a module scope",
        "typeAliasRedeclared": "\"{name}\" is declared as a TypeAlias and can be assigned only once",
        "typeArgListNotAllowed": "List expression not allowed for this type argument",
        "typeArgsExpectingNone": "Expected no type arguments",
        "typeArgsMismatchOne": "Expected one type argument but received {received}",
        "typeArgsMissingForAlias": "Expected type arguments for generic type alias \"{name}\"",
        "typeArgsMissingForClass": "Expected type arguments for generic class \"{name}\"",
        "typeArgsTooFew": "Too few type arguments provided for class \"{name}\"; expected {expected} but received {received}",
        "typeArgsTooMany": "Too many type arguments provided for class \"{name}\"; expected {expected} but received {received}",
        "typeAssignmentMismatch": "Expression of type \"{sourceType}\" cannot be assigned to declared type \"{destType}\"",
        "typeCallNotAllowed": "type() call should not be used in type annotation",
        "typedDictAccess": "Could not access item in TypedDict",
        "typedDictBadVar": "TypedDict classes can contain only type annotations",
        "typedDictBaseClass": "All base classes for \"TypedDict\" classes must also be \"TypedDict\" classes",
        "typedDictDelete": "Could not delete item in TypedDict",
        "typedDictEmptyName": "Names within a TypedDict cannot be empty",
        "typedDictEntryName": "Expected string literal for dictionary entry name",
        "typedDictEntryUnique": "Names within a dictionary must be unique",
        "typedDictExtraArgs": "Extra TypedDict arguments not supported",
        "typedDictFirstArg": "Expected TypedDict class name as first argument",
        "typedDictSecondArgDict": "Expected dict or keyword parameter as second parameter",
        "typedDictSecondArgDictEntry": "Expected simple dictionary entry",
        "typedDictSet": "Could not assign item in TypedDict",
        "typedDictTotalParam": "Expected \"total\" parameter to have a value of True or False",
        "typeExpectedClass": "Expected class type but received \"{type}\"",
        "typeGuardArgCount": "Expected a single type argument after \"TypeGuard\"",
        "typeNotAwaitable": "\"{type}\" is not awaitable",
        "typeNotCallable": "\"{expression}\" has type \"{type}\" and is not callable",
        "typeNotIntantiable": "\"{type}\" cannot be instantiated",
        "typeNotIterable": "\"{type}\" is not iterable",
        "typeNotSpecializable": "Could not specialize type \"{type}\"",
        "typeNotSubscriptable": "Object of type \"{type}\" is not subscriptable",
        "typeNotUsableWith": "Object of type \"{type}\" cannot be used with \"with\" because it does not implement {method}",
        "typeNotSupportBinaryOperator": "Operator \"{operator}\" not supported for types \"{leftType}\" and \"{rightType}\"",
        "typeNotSupportUnaryOperator": "Operator \"{operator}\" not supported for type \"{type}\"",
        "typePartiallyUnknown": "Type of \"{name}\" is partially unknown",
        "typeUnknown": "Type of \"{name}\" is unknown",
        "typeVarAssignedName": "TypeVar must be assigned to a variable named \"{name}\"",
        "typeVarAssignmentMismatch": "Type \"{type}\" cannot be assigned to TypeVar \"{name}\"",
        "typeVarBoundAndConstrained": "TypeVar cannot be both bound and constrained",
        "typeVarFirstArg": "Expected name of TypeVar as first argument",
        "typeVarGeneric": "TypeVar bound type cannot be generic",
        "typeVarNoMember": "TypeVar \"{type}\" has no member \"{name}\"",
        "typeVarNotSubscriptable": "TypeVar \"{type}\" is not subscriptable",
        "typeVarNotUsedByOuterScope": "TypeVar \"{name}\" has no meaning in this context",
        "typeVarSingleConstraint": "TypeVar cannot have only a single constraint",
        "typeVarTupleContext": "TypeVarTuple not allowed in this context",
        "typeVarUnknownParam": "\"{name}\" is unknown parameter to TypeVar",
        "typeVarUsedByOuterScope": "TypeVar \"{name}\" is already in use by an outer scope",
        "typeVarUsedOnlyOnce": "TypeVar \"{name}\" appears only once in generic function signature",
        "typeVarVariance": "TypeVar cannot be both covariant and contravariant",
        "unaccessedClass": "Class \"{name}\" is not accessed",
        "unaccessedFunction": "Function \"{name}\" is not accessed",
        "unaccessedImport": "Import \"{name}\" is not accessed",
        "unaccessedSymbol": "\"{name}\" is not accessed",
        "unaccessedVariable": "Variable \"{name}\" is not accessed",
        "unexpectedAsyncToken": "Expected \"def\", \"with\" or \"for\" to follow \"async\"",
        "unexpectedExprToken": "Unexpected token at end of expression",
        "unexpectedIndent": "Unexpected indentation",
        "unexpectedUnindent": "Unindent not expected",
        "unionSyntaxIllegal": "Alternative syntax for unions requires Python 3.10 or newer",
        "unnecessaryCast": "Unnecessary \"cast\" call; type is already \"{type}\"",
        "unnecessaryIsInstanceAlways": "Unnecessary isinstance call; \"{testType}\" is always an instance of \"{classType}\"",
        "unnecessaryIsInstanceNever": "Unnecessary isinstance call; \"{testType}\" is never an instance of \"{classType}\"",
        "unnecessaryIsSubclassAlways": "Unnecessary issubclass call; \"{testType}\" is always a subclass of \"{classType}\"",
        "unnecessaryIsSubclassNever": "Unnecessary issubclass call; \"{testType}\" is never a subclass of \"{classType}\"",
        "unpackArgCount": "Expected a single type argument after \"Unpack\"",
        "unpackedArgInTypeArgument": "Unpacked arguments cannot be used in type argument lists",
        "unpackedArgWithVariadicParam": "Unpacked argument cannot be used for TupleTypeVar parameter",
        "unpackedDictArgumentNotMapping": "Argument expression after ** must be a mapping with a \"str\" key type",
        "unpackedSubscriptIllegal": "Unpack operator in subscript requires Python 3.10 or newer",
        "unpackedTypeVarTupleExpected": "Expected unpacked TypeVarTuple; use Unpack[{name1}] or *{name2}",
        "unpackExpectedTypeVarTuple": "Expected TypeVarTuple as type argument for Unpack",
        "unpackIllegalInComprehension": "Unpack operation not allowed in comprehension",
        "unpackInDict": "Unpack operation not allowed in dictionaries",
        "unpackInSet": "Unpack operator not allowed within a set",
        "unpackNotAllowed": "Unpack operation not allowed in this context",
        "unpackTuplesIllegal": "Unpack operation not allowed in tuples prior to Python 3.8",
        "unreachableCode": "Code is unreachable",
        "unsupportedDunderAllAssignment": "Expression assigned to \"__all__\" is not supported, so exported symbol list may be incorrect; use list or tuple of string literal values in assignment",
        "unsupportedDunderAllOperation": "Operation on \"__all__\" is not supported, so exported symbol list may not be incorrect",
        "unusedCallResult": "Result of call expression is of type \"{type}\" and is not used; assign to variable \"_\" if this is intentional",
        "unusedCoroutine": "Result of async function call is not used; use \"await\" or assign result to variable",
        "varAnnotationIllegal": "Type annotations for variables requires Python 3.6 or newer; use type comment for compatibility with previous versions",
        "variadicTypeParamNotAtEnd": "TypeVarTuple \"{name}\" must be the last type parameter",
        "variadicTypeParamTooManyAlias": "Type alias can have at most one TypeVarTuple type parameter but received multiple ({names})",
        "variadicTypeParamTooManyClass": "Generic class can have at most one TypeVarTuple type parameter but received multiple ({names})",
        "walrusIllegal": "Operator \":=\" requires Python 3.8 or newer",
        "walrusNotAllowed": "Operator \":=\" not allowed in this context",
        "wildcardInFunction": "Wildcard import not allowed within a class or function",
        "wildcardLibraryImport": "Wildcard import from a library not allowed",
        "yieldFromIllegal": "Use of \"yield from\" requires Python 3.3 or newer",
        "yieldFromOutsideAsync": "\"yield from\" not allowed in an async function",
        "yieldOutsideFunction": "\"yield\" not allowed outside of a function or lambda",
        "yieldTypeMismatch": "Expression of type \"{exprType}\" cannot be assigned to yield type \"{yieldType}\"",
        "zeroCaseStatementsFound": "Match statement must include at least one case statement",
        "zeroLengthTupleNotAllowed": "Zero-length tuple not allowed in this context"
    },
    "DiagnosticAddendum": {
        "argParam": "Argument corresponds to parameter \"{paramName}\"",
        "argParamFunction": "Argument corresponds to parameter \"{paramName}\" in function \"{functionName}\"",
        "argsParamMissing": "Parameter *{paramName} has no corresponding parameter",
        "argsParamWithVariadic": "Parameter *{paramName} is not compatible with TypeVarTuple",
        "argumentType": "Argument type is \"{type}\"",
        "argumentTypes": "Argument types: ({types})",
        "assignToNone": "Cannot assign to \"None\"",
        "asyncHelp": "Did you mean \"async with\"?",
        "dataclassFrozen": "Dataclass \"{name}\" is frozen",
        "finalMethod": "Final method",
        "keyUndefined": "\"{name}\" is not a defined key in \"{type}\"",
        "functionReturnTypeMismatch": "Function return type \"{sourceType}\" is not compatible with type \"{destType}\"",
        "functionTooFewParams": "Function accepts too few positional parameters; expected {expected} but received {received}",
        "functionTooManyParams": "Function accepts too many positional parameters; expected {expected} but received {received}",
        "incompatibleGetter": "Property getter method is incompatible",
        "incompatibleSetter": "Property setter method is incompatible",
        "incompatibleDeleter": "Property deleter method is incompatible",
        "literalAssignmentMismatch": "\"{sourceType}\" cannot be assigned to type \"{destType}\"",
        "memberSetClassVar": "Member \"{name}\" cannot be assigned through a class instance because it is a ClassVar",
        "memberAssignment": "Expression of type \"{type}\" cannot be assigned to member \"{name}\" of class \"{classType}\"",
        "memberIsAbstract": "\"{type}.{name}\" is abstract",
        "memberIsAbstractMore": "and {count} more...",
        "memberTypeMismatch": "\"{name}\" is an incompatible type",
        "memberUnknown": "Member \"{name}\" is unknown",
        "missingGetter": "Property getter method is missing",
        "missingSetter": "Property setter method is missing",
        "missingDeleter": "Property deleter method is missing",
        "namedParamMissingInDest": "Keyword parameter \"{name}\" is missing in destination",
        "namedParamMissingInSource": "Keyword parameter \"{name}\" is missing in source",
        "namedParamTypeMismatch": "Keyword parameter \"{name}\" of type \"{sourceType}\" cannot be assigned to type \"{destType}\"",
        "noOverloadAssignable": "No overloaded function matches type \"{type}\"",
        "orPatternMissingName": "Missing names: {name}",
        "overloadNotAssignable": "One or more overloads of \"{name}\" is not assignable",
        "overriddenMethod": "Overridden method",
        "overriddenSymbol": "Overridden symbol",
        "overrideParamCount": "Parameter count mismatch; base method has {baseCount}, but override has {overrideCount}",
        "overrideParamName": "Parameter {index} name mismatch: base parameter is named \"{baseName}\", override parameter is named \"{overrideName}\"",
        "overrideParamType": "Parameter {index} type mismatch: base parameter is type \"{baseType}\", override parameter is type \"{overrideType}\"",
        "overrideReturnType": "Return type mismatch: base method returns type \"{baseType}\", override returns type \"{overrideType}\"",
        "overrideType": "Base class defines type as \"{type}\"",
        "paramAssignment": "Parameter {index}: type \"{sourceType}\" cannot be assigned to type \"{destType}\"",
        "paramSpecOverload": "ParamSpec cannot be used with overloaded function",
        "paramType": "Parameter type is \"{paramType}\"",
        "propertyMethodIncompatible": "Property method \"{name}\" is incompatible",
        "propertyMethodMissing": "Property method \"{name}\" is missing in override",
        "propertyMissingDeleter": "Property \"{name}\" has no defined deleter",
        "propertyMissingSetter": "Property \"{name}\" has no defined setter",
        "protocolMemberMissing": "\"{name}\" is not present",
        "protocolMemberClassVar": "\"{name}\" is not a class variable",
        "seeDeclaration": "See declaration",
        "seeClassDeclaration": "See class declaration",
        "seeFunctionDeclaration": "See function declaration",
        "seeMethodDeclaration": "See method declaration",
        "seeParameterDeclaration": "See parameter declaration",
        "seeVariableDeclaration": "See variable declaration",
        "tupleEntryTypeMismatch": "Tuple entry {entry} is incorrect type",
        "tupleSizeMismatch": "Tuple size mismatch; expected {expected} but received {received}",
        "tupleSizeMismatchIndeterminate": "Tuple size mismatch; expected {expected} but received indeterminate number",
        "typeAssignmentMismatch": "Type \"{sourceType}\" cannot be assigned to type \"{destType}\"",
        "typeBound": "Type \"{sourceType}\" is not compatible with bound type \"{destType}\" for TypeVar \"{name}\"",
        "typeConstrainedTypeVar": "Type \"{type}\" is not compatible with constrained TypeVar \"{name}\"",
        "typeConstraint": "Type \"{type}\" is not compatible with constrained type \"{name}\"",
        "typedDictFieldMissing": "\"{name}\" is missing from \"{type}\"",
        "typedDictFieldNotRequired": "\"{name}\" is not required in \"{type}\"",
        "typedDictFieldRequired": "\"{name}\" is required in \"{type}\"",
        "typedDictFieldTypeMismatch": "Type \"{type}\" is not assignable to field \"{name}\"",
        "typedDictFieldUndefined": "\"{name}\" is an undefined field in type \"{type}\"",
        "typeIncompatible": "\"{sourceType}\" is incompatible with \"{destType}\"",
        "typeNotCallable": "Type \"{type}\" is not callable",
        "typeNotClass": "\"{type}\" is not a class",
        "typeParamSpec": "Type \"{type}\" is not compatible with ParamSpec \"{name}\"",
        "typeNotStringLiteral": "\"{type}\" is not a string literal",
        "typeOfSymbol": "Type of \"{name}\" is \"{type}\"",
        "typeUnsupported": "Type \"{type}\" is unsupported",
        "typeVarIsContravariant": "TypeVar \"{name}\" is contravariant",
        "typeVarIsCovariant": "TypeVar \"{name}\" is covariant",
        "typeVarIsInvariant": "TypeVar \"{name}\" is invariant",
        "typeVarNotAllowed": "TypeVar or generic type with type arguments not allowed",
        "typeVarTupleRequiresKnownLength": "TypeVarTuple cannot be bound to a tuple of unknown length",
        "useDictInstead": "Use Dict[T1, T2] to indicate a dictionary type",
        "useListInstead": "Use List[T] to indicate a list type or Union[T1, T2] to indicate a union type",
        "useTupleInstead": "Use Tuple[T1, ..., Tn] to indicate a tuple type or Union[T1, T2] to indicate a union type",
        "useTypeInstead": "Use Type[T] instead"
    },
    "CodeAction": {
        "addOptionalToAnnotation": "Add \"Optional\" to Type Annotation",
        "createTypeStub": "Create Type Stub",
        "createTypeStubFor": "Create Type Stub For \"{moduleName}\"",
        "executingCommand": "Executing command",
        "filesToAnalyzeOne": "1 file to analyze",
        "filesToAnalyzeCount": "{count} files to analyze",
        "findingReferences": "Finding references",
        "organizeImports": "Organize Imports"
    }
}
